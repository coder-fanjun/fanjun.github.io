{"meta":{"title":"Twilight's Blog","subtitle":"wangchao","description":null,"author":"wangchao","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-03-10T14:44:00.244Z","updated":"2018-03-10T14:44:00.244Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Introduction 考研狗一只，热衷于技术，却渐行渐远。 宅男程序猿一位，爱看电影，偏爱惊险刺激暴力血腥。 某二本院校HFUU的渣渣一枚，任重而道远。 半坛醋文艺青年一位，无聊时爱看书，种类不限 ヘ(￣ω￣ヘ) 。 技术宅一位。略懂web开发，略懂Java，略懂 Linux、略懂前端 ContactGithub： github.com/1601436878QQ： MTYwMTQzNjg3OA==Email: twilight0402@163.com &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你背单词时 阿拉斯加的鳕鱼正跃出水面 你算数学时 太平洋彼岸的海鸥振翅掠过城市上空 你晚自习时 极图中的夜空散漫了五彩斑斓 但是少年你别着急 在你为自己未来踏踏实实地努力时 那些你感觉从来不会看到的景色 那些你觉得终身不会遇到的人 正一步步向你走来 ……."},{"title":"","date":"2018-02-05T09:51:45.000Z","updated":"2018-02-05T10:48:06.767Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":"test test"}],"posts":[{"title":"非root用户开启tomcat报错Permission denied","slug":"非root用户开启tomcat报错Permission denied","date":"2018-01-18T02:57:34.000Z","updated":"2018-02-07T08:27:00.447Z","comments":true,"path":"2018/01/18/非root用户开启tomcat报错Permission denied/","link":"","permalink":"http://yoursite.com/2018/01/18/非root用户开启tomcat报错Permission denied/","excerpt":"","text":"开启tomcat失败，报错提示 Permission denied 报错信息如下： 123456789101112Caused by: java.net.SocketException: Permission denied at sun.nio.ch.Net.bind0(Native Method) at sun.nio.ch.Net.bind(Net.java:433) at sun.nio.ch.Net.bind(Net.java:425) at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223) at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74) at org.apache.tomcat.util.net.NioEndpoint.bind(NioEndpoint.java:210) at org.apache.tomcat.util.net.AbstractEndpoint.init(AbstractEndpoint.java:1082) at org.apache.tomcat.util.net.AbstractJsseEndpoint.init(AbstractJsseEndpoint.java:267) at org.apache.coyote.AbstractProtocol.init(AbstractProtocol.java:581) at org.apache.coyote.http11.AbstractHttp11Protocol.init(AbstractHttp11Protocol.java:66) at org.apache.catalina.connector.Connector.initInternal(Connector.java:993) 原因是在Centos7 中，非root用户不能开启1024以下的端口。比如我用twilight用户开启tomcat，就会报错。解决方法是通过iptables防火墙重定向端口，将80端口重定向到8080端口上去。在Centos7中，默认的防火墙是 firewalld 需要先挂关闭它，再使用iptables防火墙。1234关闭firewall防火墙systemctl stop firewalld.service关闭firewall开机自启systemctl disable firewalld.service 接着安装iptables1yum install iptables-services 开放端口：123456// 查看现有的iptables 规则iptables -L -n// 开放端口，临时的，重启会失效iptables -I OUTPUT -p tcp --dport 22 -m state --state NEW -j ACCEPTiptables -I INPUT -p tcp --dport 22 -m state --state NEW -j ACCEPT 将80 端口 重定向到80801iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 永久保存iptable配置12// 保存iptables-save &gt; /etc/sysconfig/iptables","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Hibernate 映射","slug":"Hibernate-映射","date":"2018-01-09T07:42:21.000Z","updated":"2018-01-09T08:04:29.833Z","comments":true,"path":"2018/01/09/Hibernate-映射/","link":"","permalink":"http://yoursite.com/2018/01/09/Hibernate-映射/","excerpt":"","text":"表的结构如下：出版社表 publisher 书籍表 book 单向 N-1 关联无连接表的单向 N-1 关联JoinColumn 表示book表中的外键字段的名字123@ManyToOne(targetEntity=Publisher.class,fetch=FetchType.EAGER)@JoinColumn(name=&quot;publisherid&quot;)private Publisher publish; 有连接表的单向 N-1 关联单向 1-1 关联外键单向 1-1 关联有连接表的单向 1-1 关联单向 1-N无连接表的 1-N 关联有连接表的 1-N 关联双向 1-N 关联无连接表的双向 1-N有连接表的双向 1-N双向 N-N 关联双向 1-1 关联外键双向 1-1 关联有连接表的 双向 1-1 关联","categories":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/categories/Hibernate/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"}]},{"title":"Centos7安装Hadoop","slug":"Centos7安装Hadoop","date":"2018-01-05T15:28:47.000Z","updated":"2018-01-14T02:11:12.864Z","comments":true,"path":"2018/01/05/Centos7安装Hadoop/","link":"","permalink":"http://yoursite.com/2018/01/05/Centos7安装Hadoop/","excerpt":"","text":"修改 Centos7为字符界面Centos7取消了之前的 inittab文件的作用，改用命令实现， systemctl get-default ： 获得默认启动方式 systemctl set-default multi-user.target ： 设置字符界面启动方式(level3) systemctl set-default graphical.target ： 设置图形化启动方式(level5) 修改主机名 Centos7 中 ：hostnamectl set-hostname xxx Centos6 修改 network文件即可 ：vim /etc/sysconfig/network 修改hosts文件保证三台机器可以ping通123hadoop-master 192.168.178.1slave1 192.168.178.1slave2 192.168.178.1 安装SSH检查是否已经安装ssh rpm –qa | grep openssh rpm –qa | grep rsync 如果没有安装 ssh 和 rsync，用下面的命令安装 yum install ssh yum install rsync service sshd restart 配置无密码登陆 机器上生成密码对 ssh-keygen –t rsa 把 id_rsa.pub 追加到授权的 key 里面 去 cat id_rsa.pub &gt;&gt; authorized_keys 修改文件”authorized_keys”权限 chmod 600 authorized_keys 修改 SSH 配置文件 /etc/ssh/sshd_config (所有机器都要配) RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 重启ssh服务 service sshd restart 将公钥复制到所有slave机器上 scp id_rsa.pub hadoop@slave1:/home/hadoop/ 追加 authorized_keys cp id_rsa.pub .sshcat id_rsa.pub &gt;&gt; .ssh/authorized_keyschmod 600 .ssh/authorized_keysservice sshd restart 验证是否成功 ssh slave1 如果可以直接登陆则表示成功 [hadoop@localhost .ssh]$ ssh slave1Last login: Fri Jan 5 21:11:48 2018 from hadoop-master Java 环境安装 卸载已安装的java rpm -qa | grep javarpm -e –nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64rpm -e –nodeps javapackages-tools-3.4.1-11.el7.noarchrpm -e –nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64rpm -e –nodeps tzdata-java-2016g-2.el7.noarchrpm -e –nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64rpm -e –nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64 安装java 解压tar -zxvf jdk-8u131-linux-x64.tar.gz将目录名改为 jdk1.8mv jdk1.8.0_131/ jdk1.8编辑环境变量vim /etc/profile// 添加以下内容# set java environmentexport JAVA_HOME=/usr/jdk1.8export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin 使配置文件生效source /etc/profile 安装Hadoop 解压 hadoop-2.7.0.tar.gz，并重命名 tar zxvf hadoop-2.7.5.tar.gzmv hadoop-2.7.0 hadoop 在/usr/hadoop下面创建tmp文件夹 mkdir tmp 配置 /etc/profile 文件 vim /etc/profile 添加以下内容export HADOOP_INSTALL=/usr/hadoopexport PATH=${HADOOP_INSTALL}/bin:${HADOOP_INSTALL}/sbin${PATH}export HADOOP_MAPRED_HOME=${HADOOP_INSTALL}export HADOOP_COMMON_HOME=${HADOOP_INSTALL}export HADOOP_HDFS_HOME=${HADOOP_INSTALL}export YARN_HOME=${HADOOP_INSTALLL}export HADOOP_COMMON_LIB_NATIVE_DIR=${HADOOP_INSTALL}/lib/natvieexport HADOOP_OPTS=”-Djava.library.path=${HADOOP_INSTALL}/lib:${HADOOP_INSTALL}/lib/native”使生效source /etc/profile 配置hadoop 配置 hadoop-env.sh,配置java环境变量 export JAVA_HOME=/usr/java/jdk1.8 配置core-site.xml文件 123456789101112// 内容如下&lt;configuration&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/hadoop/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://hadoop-master:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置mapred-site.xml文件 123456789101112131415161718192021222324&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobtracker.http.address&lt;/name&gt; &lt;value&gt;hadoop-master:50030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;hadoop-master:10020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;hadoop-master:19888&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;http://hadoop-master:9001&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置yarn-site.xml文件 12345678910111213141516171819202122232425262728293031&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;hadoop-master&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;hadoop-master:8032&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;hadoop-master:8030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;hadoop-master:8031&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;hadoop-master:8033&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;hadoop-master:8088&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 将hadoop传入slave中 scp -r /usr/hadoop root@slave1:/usr/ 修改Master主机上的slaves文件 123456vim /usr/hadoop/etc/hadoop/slaves将内容改为：slave1slave2 启动hadoop 关闭防火墙 systemctl stop firewalld.service 关闭防火墙开机自启systemctl disable firewalld.service 格式化 hadoop namenode -format 启动hadoop /usr/hadoop/sbin/start-all.sh 验证，jps， 若出现下列信息表示安装成功 123456789101112主节点：[hadoop@hadoop-master usr]$ jps13138 Jps12563 SecondaryNameNode12708 ResourceManager12375 NameNode从节点：[root@slave1 ~]# jps12786 Jps12205 DataNode12317 NodeManager","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://yoursite.com/categories/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://yoursite.com/tags/Hadoop/"}]},{"title":"《活着》---感","slug":"《活着》-感","date":"2017-12-24T12:58:12.000Z","updated":"2017-12-24T13:04:48.580Z","comments":true,"path":"2017/12/24/《活着》-感/","link":"","permalink":"http://yoursite.com/2017/12/24/《活着》-感/","excerpt":"","text":"我听到了一首美国民歌《老黑奴》，歌中那位老黑奴经历了一生的苦难，家人都先他而去，而他依然友好地对待世界，没有一句抱怨的话。这首歌深深打动了我，我决定写下一篇这样的小说，就是这篇《活着》。– 余华 周末。心情很差，一晚上时间看完了之前买的短片小说《活着》。说实话，这是我看过的最悲伤的故事。主人公福贵原来是一个富家子弟，赌博输掉家产后，父亲死去。 “我爹从粪缸上摔了下来，那佃户听到声音急忙转过身来，看到我爹斜躺在地上，脑袋靠着粪缸一动不动·····我爹问到他‘你先前看到过我掉下来没有？’他说’没有，老爷。‘我爹像是有些高兴，又问‘第一次掉下来？’他说‘是的，老爷。我爹嘿嘿笑了几下，笑完后闭上了眼睛，脖子一歪，脑袋顺着粪缸滑到了地上。” 家族破落，年老的老人临死前的笑似乎包含了他一生的遗憾。遗憾他败掉了家里的一半的家产，遗憾他的儿子彻底败掉的所有的家产，这是一种无奈与解脱。接着是有庆。 ”那时候有庆已经不行了，可出来个医生说血还不够用。抽血的是个乌龟王八蛋，把我儿子的血差不多抽干了，有庆嘴唇都青了，他还不住手，等到有庆脑袋一歪摔在地上，那人才慌了，去叫来医生，医生蹲在地上拿听筒听了听说：’心跳都没了。‘医生也没怎么当回事，只是骂了一声抽血的：‘你真是胡闹’就跑进产房去救县长的女人了。“ 看到这里我真的是感觉到了那个时代的可怕，福贵的儿子死了，为了救县长的夫人而死，而就在这之前他刚刚得了校运动会的第一名，刚刚破晓的一点希望，就这样破灭了。接着是凤霞，大出血而死。二喜，被水泥板夹死。苦根，吃豆子撑死。家珍，躺在床上安然的死去。最后的最后，只剩下年老的福贵和一个和他一样老的老牛，老牛也叫福贵。福贵一生经历了那个多的苦难，他依然没有放弃生的念头，也许已经没有什么苦难可以打倒他了吧。借用网上的一段话： 现在的社会中，每个人经历的坎坷太多，抱怨也太多。生活就像一面镜子，你冲它笑，它不会冲你哭。当我们承受着太多的辛劳时，背负着太多的责任时，享受着太少的成功时，想想福贵，想想活着的意义。 不要问活着的意义是什么，活着本身就是意义。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Shell---Shell常用命令（tr、sed、cut）","slug":"Shell-Shell常用命令（tr、sed、cut）","date":"2017-10-28T03:46:18.000Z","updated":"2018-02-07T06:03:40.169Z","comments":true,"path":"2017/10/28/Shell-Shell常用命令（tr、sed、cut）/","link":"","permalink":"http://yoursite.com/2017/10/28/Shell-Shell常用命令（tr、sed、cut）/","excerpt":"","text":"trtr 命令用于转换或删除文件中的字符。从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。 tr [-cdst][--help][--version][第一字符集][第二字符集] 参数： -c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换 -d, –delete：删除指令字符 -s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符 -t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等 –help：显示程序用法信息 –version：显示程序本身的版本信息 1234567891011# 将所有小写字符转换成大写cat testfile |tr a-z A-Z # 压缩多个空格为1个echo &quot;fdas fadsfaf&quot; | tr -s &quot; &quot;# 把文件中的数字0-9替换为a-jcat file | tr [0-9] [a-j]# 删除文件file中出现的换行&apos;\\n&apos;、制表&apos;\\t&apos;字符cat file | tr -d &quot;\\n\\t&quot; sedsed [-nefri] ‘command’ 输入文本 -n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。 -e∶直接在指令列模式上进行 sed 的动作编辑； -f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作； -r∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法) -i∶直接修改读取的档案内容，而不是由萤幕输出。 a ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行) c ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ∶删除，d后面不接参数 i ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作 s ∶取代，可以直接进行取代的工作，例如 1,20s/old/new/g 就是啦！ 替换一行中的某部分 格式： sed &#39;s/要替换的字符串/新的字符串/g&#39; （要替换的字符串可以用正则表达式） 12345678910111213141516171819202122232425262728293031323334353637383940414243# ab 为文件名 删除某行 [root@localhost ruby] # sed &apos;1d&apos; ab #删除第一行 [root@localhost ruby] # sed &apos;$d&apos; ab #删除最后一行 [root@localhost ruby] # sed &apos;1,2d&apos; ab #删除第一行到第二行 [root@localhost ruby] # sed &apos;2,$d&apos; ab #删除第二行到最后一行 显示某行. [root@localhost ruby] # sed -n &apos;1p&apos; ab #显示第一行 (如果不加-n就会全部显示) [root@localhost ruby] # sed -n &apos;$p&apos; ab #显示最后一行 [root@localhost ruby] # sed -n &apos;1,2p&apos; ab #显示第一行到第二行 [root@localhost ruby] # sed -n &apos;2,$p&apos; ab #显示第二行到最后一行 使用模式进行查询 [root@localhost ruby] # sed -n &apos;/ruby/p&apos; ab #查询包括关键字ruby所在所有行 [root@localhost ruby] # sed -n &apos;/\\$/p&apos; ab #查询包括关键字$所在所有行，使用反斜线\\屏蔽特殊含义 #第一行后增加字符串&quot;drink tea&quot; sed &apos;1a drink tea&apos; ab #第一行到第三行后增加字符串&quot;drink tea&quot; sed &apos;1,3a drink tea&apos; ab #第一行后增加多行，使用换行符\\n sed &apos;1a drink tea\\nor coffee&apos; ab #第一行代替为Hi sed &apos;1c Hi&apos; ab #第一行到第二行代替为Hi sed &apos;1,2c Hi&apos; ab #替换ruby为bird sed -n &apos;/ruby/p&apos; ab | sed &apos;s/ruby/bird/g&apos; # 替换 \\#!为23333 cat cal.sh | sed -n &quot;s/#\\!/23333/g&quot; # 将\\#!替换成空，即删除这两个字符 cat cal.sh | sed &quot;s/#\\!//g&quot; #在文件ab中最后一行直接输入&quot;bye&quot; sed -i &apos;$a bye&apos; ab cutcut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。不能处理多空格为分隔符的行123cut [-bn] [file]cut [-c] [file]cut [-df] [file] -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 -c ：以字符为单位进行分割。 -d ：自定义分隔符，默认为制表符。 -f ：与-d一起使用，指定显示哪个区域。 -n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 12345678# 提取每行的第三个字符who | cut -b 3# 提取第3，第4、第5和第8个字节who|cut -b 3-5,8# 以 `:`为分隔符，选取第一个cat /etc/passwd | cut -d &quot;:&quot; -f 1 当有多个空格为分隔符时，可用awk命令12345# 选出第一列（以多个空格分隔）[root@localhost sh]# ll | awk &apos;&#123;print $1&#125;&apos;-rwxr-xr-x.-rwxr-xr-x.-rwxr-xr-x.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell---for循环","slug":"Shell-for循环","date":"2017-10-28T01:37:15.000Z","updated":"2018-02-07T06:04:40.970Z","comments":true,"path":"2017/10/28/Shell-for循环/","link":"","permalink":"http://yoursite.com/2017/10/28/Shell-for循环/","excerpt":"","text":"for 循环语法一： 1234for 变量 in value1 value2 value3... do // do something done 语法二 ：1234for (( 初始值;循环控制条件;变量变化 )) do // do something done 案例一：123456#!/bin/bashfor i in 1 2 3 4 5 do echo $i done 案例二：12345678#!/bin/bashresult=0for ((i=1;i&lt;=100;i=i+1)) do result=$(($result+$i)) doneecho $result 案例三，批量添加用户：12345678910111213141516171819202122#!/bin/bashread -p &quot;请输入用户名：&quot; nameread -p &quot;请输入创建用户的数量&quot; numberread -p &quot;请输入密码：&quot; passwordif [ -n &quot;$name&quot; -a -n &quot;$number&quot; -a -n &quot;$password&quot; ] then # 判断数量是否是数字 flag=`echo $number | sed &quot;s/[0-9]//g&quot; ` if [ -n flag ] then for (( i=1;i&lt;=$number;i=i+1 )) do /usr/sbin/useradd $name$i echo $passwd | /usr/bin/passwd --stdin $name$i echo &quot;成功添加用户$name$i,密码$passwd\\n&quot; done fielse echo &quot;不能为空&quot;fi 案例四，批量删除用户：1234567891011#!/bin/bash# 批量删除用户read -p &quot;请输入需要删除的用户名:&quot; namelist=$(cat /etc/passwd | grep $name | cut -d &quot;:&quot; -f 1)for i in $list do userdel $i done while 和 util语法：12345# 条件满足时执行循环while [ 条件判断式 ] do // do something done 12345# 条件满足时退出循环until [ 条件判断式 ] do // do something done 案例五：1234567891011121314[root@localhost sh]# vim while.sh #!/bin/bash# 测试while循环i=1s=0while [ &quot;$i&quot; -le 100 ] do s=$(( $s+$i )) i=$(( $i+1 )) doneecho $s 案例六：1234567891011#!/bin/bashi=1s=0until [ &quot;$i&quot; -gt 100 ] do s=$(( $s+$i )) i=$(( $i+1 )) doneecho $s","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell---判断(if)和分支(case)","slug":"Shell-判断-if-和分支-case","date":"2017-10-28T01:33:01.000Z","updated":"2018-02-07T06:04:45.307Z","comments":true,"path":"2017/10/28/Shell-判断-if-和分支-case/","link":"","permalink":"http://yoursite.com/2017/10/28/Shell-判断-if-和分支-case/","excerpt":"","text":"if 判断单分支if条件语句语法：123if [ 条件判断式 ];then # do somethingfi 或者1234if [ 条件判断式 ] then # do somethingfi 案例一，获取当前用户名，当然用 whoami 也可：123456#!/bin/bashtest=`env | grep &quot;USER&quot; | cut -d &quot;=&quot; -f 2`if [ test==&quot;root&quot; ];then echo &quot;This user is root&quot;fi 案例二，检查磁盘容量：1234567#!/bin/bashrate=`df -h | grep &quot;sda1&quot; | awk &apos;&#123; print $5 &#125;&apos; | cut -d &quot;%&quot; -f 1`if [ $rate -gt &quot;10&quot; ];then echo &quot;/ is Full&quot;fi PS： 条件判断式就是test命令判断，可以用test命令替代，中括号中间必须有空格 -gt 当变量值为空时会报错 双分支if语法：123456if [ 条件判断式 ] then ... else ...fi 案例三，判断目录的属性：12345678910#!/bin/bashread -t 30 -p &quot;input a dir:&quot; dirif [ -d $dir ] then echo &quot;This is a directory&quot; else echo &quot;no no no &quot;fi 案例四，判断tomcat服务是否开启：12345678910111213#!/bin/bashtest=`ps aux | grep tomcat | grep -v grep`if [ -n &quot;$test&quot; ] then echo &quot;tomcat is running&quot; else echo &quot;tomcat is not running&quot; /etc/init.d/tomcat start# service tomcat start 不建议使用 echo &quot;tomcat is started&quot;fi PS： if判断中的变量最好加上引号，因为如果变量的值中包含空格，将出现too many arguments 错误，所以还是写成 if [ -n &quot;$test&quot; ] 较安全 多分支if语法：123456789101112if [ 条件判断 ] then # do somethingelif [ 条件判断 ] then # do something...else # do somethingfi 案例五，简易计算器：12345678910111213141516171819202122232425262728293031323334353637383940#!/bin/bashread -p &quot;please input num1:&quot; num1read -p &quot;please input operator:&quot; opread -p &quot;please input num2:&quot; num2if [ -z &quot;$num1&quot; -o -z &quot;$num2&quot; -o -z &quot;$op&quot; ] then echo &quot;value shoud not be null&quot; exit 2 else # 把所有数字替换成空,如果替换后不为空，则表示变量中不符合规范 test1=`echo $num1 | sed &apos;s/[0-9]//g&apos;` test2=`echo $num2 | sed &apos;s/[0-9]//g&apos;` if [ -n &quot;$test1&quot; -o -n &quot;$test2&quot; ];then echo &quot;数值格式错误&quot; exit 4 fi if [ &quot;$op&quot; == &quot;+&quot; ] then result=$(($num1+$num2)) elif [ &quot;$op&quot; == &quot;-&quot; ] then result=$(($num1-$num2)) elif [ &quot;$op&quot; == &quot;*&quot; ] then result=$(($num1*$num2)) elif [ &quot;$op&quot; == &quot;/&quot; ] then let &quot;result=$num1/$num2&quot; else echo &quot;operator is wrong&quot; exit 3 fifiecho $&#123;num1&#125;$&#123;op&#125;$&#123;num2&#125;=$&#123;result&#125; 案例六，判断文件类型：123456789101112131415161718192021#!/bin/bashread -p &quot;请输入文件或目录名：&quot; pathif [ -z &quot;$path&quot; ] then echo &quot;请输入内容！&quot; exit 10elif [ ! -e &quot;$path&quot; ] then echo &quot;文件或目录不存在&quot; exit 11elif [ -f &quot;$path&quot; ] then echo &quot;输入的是一个文件&quot;elif [ -d &quot;$path&quot; ] then echo &quot;输入的是一个目录&quot;else echo &quot;输入的式其他类型的文件&quot;fi case 分支语法：1234567891011121314case $变量名 in &quot;值1&quot;) // do something,变量的值等于值1 ;; &quot;值2&quot;) // do something，变量的值等于值2 ;; ... *) // do something，变量的值与上面都不同 ;;esca 案例1234567891011121314#!/bin/bashread -p &quot;请输入 yes/no&quot; resultcase &quot;$result&quot; in &quot;yes&quot;) echo &quot;你输入的式yes&quot; ;; &quot;no&quot;) echo &quot;你输入的是no&quot; ;; *) echo &quot;请输入正确的选择&quot;esac","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Shell---条件判断和判断参数","slug":"Shell-条件判断和判断参数","date":"2017-10-27T01:39:37.000Z","updated":"2018-02-07T06:04:37.147Z","comments":true,"path":"2017/10/27/Shell-条件判断和判断参数/","link":"","permalink":"http://yoursite.com/2017/10/27/Shell-条件判断和判断参数/","excerpt":"","text":"条件判断两种方式表示判断： test -e 文件名 [ -e 文件名 ] // 中括号中间有空格 以上的命令在命令行中执行，不能看到结果，需要用$?查看上一次执行的结果 一种可以直接输出结果的方式： [ -d /root ] &amp;&amp; echo “yes” || echo “no” test -e /root &amp;&amp; echo “yes” || echo “no” 按照文件类型判断相关参数如下: 权限判断只要有相应权限就为真，不分用户 文件属性的比较 两个整数数值的比较 字符串比较 多重条件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Linux中常见配置文件","slug":"Linux中常见配置文件","date":"2017-10-26T11:52:57.000Z","updated":"2017-10-28T01:58:36.585Z","comments":true,"path":"2017/10/26/Linux中常见配置文件/","link":"","permalink":"http://yoursite.com/2017/10/26/Linux中常见配置文件/","excerpt":"","text":"sourcesource 配置文件 或 . 配置文件使配置文件生效 常见配置文件： /etc/profile /etc/profile.d/*.sh ~/.bash_profile ~/.bashrc /etc/bashrc 文件的作用及关系如下: 其他配置文件 ~/.bash_logout 退出登陆时自动执行， ~/.bash_history 保存历史命令，当前登陆的历史命令保存在内存中，退出后保存到文件中。 /etc/issue 本地终端登陆之前，显示的信息 /etc/issue.net 远程终端的登陆时，显示的信息 /etc/motd 在登陆之后显示信息，不管本地还是远程 常见转义符： PS： 对于 /etc/issue.net,转义符不起作用，只能显示普通文本.。由/etc/ssh/sshd_config 控制。Banner有参数时 Banner /etc/issue.net 才能显示","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Shell---常用命令、常用环境变量、PS1、语系变量、位置变量、预定义变量、数值运算","slug":"Shell-常用命令、常用环境变量、PS1、语系变量、位置变量、预定义变量、数值运算","date":"2017-10-19T09:37:28.000Z","updated":"2018-02-07T06:04:32.022Z","comments":true,"path":"2017/10/19/Shell-常用命令、常用环境变量、PS1、语系变量、位置变量、预定义变量、数值运算/","link":"","permalink":"http://yoursite.com/2017/10/19/Shell-常用命令、常用环境变量、PS1、语系变量、位置变量、预定义变量、数值运算/","excerpt":"","text":"常用命令set 查询所有正在运行的变量 -u 当查看不存在的变量时会提示报错 unset 删除变量(不是删除值，不需要加$) unset name env 只查看环境变量export 声明环境变量 12export 变量名=变量值export 变量名 常用环境变量 HOSTNAME: 主机名 SHELL：当前shell TERM: 终端环境 HISTSIZE: 历史命令条数 SSH_CLIENT：记录客户端ip SSH_TTY：ssh连接的终端 USER:当前登录的用户 PS1 变量 \\d:日期”星期 月 日” \\H:显示完整的主机名 \\t:显示24小时制时间 “HH:MM:SS” \\A:显示24小时制时间 “HH:MM” \\u:显示当前用户名 \\w:显示当前所在目录的完整名称 \\W:显示当前所在目录的最后一个目录 \\$:提示符 语系变量 locale 查询正在使用系统语系 locale -a 查看支持的所有语系 /etc/sysconfig/i18n 默认语系环境（下次开机后的环境） LANG：定义系统主语系的变量 LC_ALL:定义整个语系的变量 位置变量 位置参数变量 作用 $n n为数字，$0代表命令本身，$1 ~ $9 代表第一到第九个参数。十以上的参数需要用大括号包含，如${10} $* 代表命令行中的所有参数（不包括$0），把所有参数当成一个整体 $@ 代表命令好中的所有参数（不包括$0），把所有参数区分对待 $# 代表命令行中所有参数的个数 预定义变量 预定义变量 作用 $? 最后一次执行的命令的返回状态。如果这个 变量的值是0，证明上一个命令正确执行；如果这个变量的值为非零（由命令自己决定），则证明上一个命令执行不正确 $$ 当前进程的进程号（PID） $! 后台运行的最后一个进程的进程号(PID) read 用户输入read [选项] [变量名] -p “提示信息”：在等待read输入时，输出提示信息 -t 秒数 ：等待用户输入，制定等待时间 -n 字符数：直接受指定的字符数，就会执行 -s ：隐藏输入的数据 运算符declare 声明变量类型declare [+/-] [选项] 变量名 -：给变量设定类型属性 +：取消变量的类型属性 -a:数组型 -i:整数型 -x:环境变量 -r:只读变量 -p:显示指定变量的被声明类型 使用下标访问数组 array[0] : 访问第一个 array ： 访问第一个 array[*] :访问所有的元素 1234567# 整形 a=1 b=2 declare -i c=$a+$b echo $c---3 123456789array[0]=aarray[1]=bdeclare -a array[3]=$&#123;array[0]&#125;$&#123;array[1]&#125;echo &quot;array[0]&quot;:$&#123;array[0]&#125;echo &quot;array&quot;:$&#123;array&#125;echo &quot;array[*]&quot;:$&#123;array[*]&#125;echo &quot;array[2]&quot;:$&#123;array[2]&#125; declare -p 查看变量的所有类型。如果不加变量名就表示显示所有变量的所有类型12[root@localhost test]# declare -p cdeclare -i c=&quot;3&quot; 数值运算expr 或 let 数值运算工具 result=$(expr $num1+$num2) 或 result=&#96;expr $num1+$num2&#96; let “result=$num1+$num2” 12345[root@localhost test]# a=1[root@localhost test]# b=2[root@localhost test]# c=$(expr $a+$b)[root@localhost test]# echo $c3 1[root@localhost test]# let &quot;d=$a+$b&quot; $((运算式)) 或 $[运算式]12[root@localhost test]# c=$(($a+$b))[root@localhost test]# d=$[$a+$b] 变量测试较复杂。。。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"我记得","slug":"我记得","date":"2017-08-28T01:50:20.000Z","updated":"2017-08-28T02:10:48.188Z","comments":true,"path":"2017/08/28/我记得/","link":"","permalink":"http://yoursite.com/2017/08/28/我记得/","excerpt":"我记得叶赛宁我记得，亲爱的，记得 你那柔发的闪光；","text":"我记得叶赛宁我记得，亲爱的，记得 你那柔发的闪光； 命运使我离开了你， 我的心沉重而悲伤。 我记得那些秋夜， 白桦树叶簌簌响； 愿白昼变得短暂， 愿月光光照得时间更长。 我记得你对我说过： “美好的年华就要变成以往， 你会忘记我，亲爱的， 和别的女友成对成双。” 今天菩提树又开花了， 引起我心中无限惆怅； 那时我是何等的温柔， 把花瓣撒落到你的鬈发上。 啊，爱恋别人心中愁烦， 我的心不会变凉， 它会从别人身上想起你， 像读本心爱的小说那样欢畅。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux系统管理---工作管理（后台程序管理）","slug":"Linux系统管理-工作管理（后台程序管理）","date":"2017-08-26T10:05:24.000Z","updated":"2017-08-26T10:10:08.772Z","comments":true,"path":"2017/08/26/Linux系统管理-工作管理（后台程序管理）/","link":"","permalink":"http://yoursite.com/2017/08/26/Linux系统管理-工作管理（后台程序管理）/","excerpt":"简介工作管理指的是在当个登陆终端中同时管理多个工作的行为。","text":"简介工作管理指的是在当个登陆终端中同时管理多个工作的行为。 注意事项 当前的登陆终端，只能管理当前终端的工作，而不能管理其他登陆终端的工作 放入后台的命令必须可以持续运行一段事件，这样我们才能捕捉和操作这个工作 放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行。放入后台类似于Windows中的最小化 工作管理的方法 命令 &amp; : 把命令放入后台，并在后台执行 ctrl + z : 按下 ctrl + z快捷键，放在后台暂停 后台执行ping命令，发送20个数据包，并将结果保存到文件：1ping -c 20 www.baidu.com &gt; baidu.ping &amp; 如果使用 ctrl + z，进程会放到后台，并暂停123[root@localhost ~]# ping -c 20 www.baidu.com &gt; baidu.ping ^Z[1]+ Stopped ping -c 20 www.baidu.com &gt; baidu.ping jobs 命令显示所有后台的进程 参数： -l ： 显示工作的PID PS： + 表示最近一个放入后台的工作，页就是工作恢复时，默认恢复的工作。- 代表倒数第二个放入后台的工作 123[root@localhost ~]# jobs[1]+ Stopped ping -c 20 www.baidu.com &gt; baidu.ping[2]- Running ping -c 20 www.baidu.com &gt; baidu.ping &amp; 恢复到前台执行 fg %工作号 将后台正在运行的进程后者暂停的进程恢复到前台运行状态。% 可以省略工作号可以用 + 或 - 表示，也可以不写，默认是+。 12[root@localhost ~]# fg %1ping -c 20 www.baidu.com &gt; baidu.ping 恢复到后台执行 bg %工作号 将后台暂停的进程恢复到在后台运行，对已经在运行的进程不生效后台恢复执行的命令是不能和前台有及交互的，否则不能恢复到前台执行12[root@localhost ~]# bg 1 [1]+ ping -c 20 www.baidu.com &gt; baidu.ping &amp; 如果该进程已经在后台运行,则不会生效：12[root@localhost ~]# bg 1 -bash: bg: job 1 already in background 脱离终端命令放入后台执行，只能在当前登录的终端只当，一旦用户退出当前终端后台程序就会终止。使后台进程脱离终端执行的方法有： 第一种方法是把需要后台执行的命令加入/etc/rc.local文件。参考 Linux服务管理—系统运行级别、rpm启动与自启动、源码包的启动与自启动 第二种方法是使用系统定时任务，让系统在指定的时间执行某个后台命令 第三种方法是使用nohup命令，标准方法 nohup 命令 nohup 命令 &amp;是命令脱离终端，在终端关闭后依然能够存在 123[root@localhost ~]# nohup ping -c 10 www.baidu.com &gt; baidu.ping &amp;[1] 28065[root@localhost ~]# nohup: 忽略输入重定向错误到标准输出端","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux系统管理---进程管理（查看进程、终止进程、更改进程优先级）","slug":"Linux系统管理-进程管理（查看进程、终止进程、更改进程优先级）","date":"2017-08-25T09:55:38.000Z","updated":"2017-09-12T01:20:08.635Z","comments":true,"path":"2017/08/25/Linux系统管理-进程管理（查看进程、终止进程、更改进程优先级）/","link":"","permalink":"http://yoursite.com/2017/08/25/Linux系统管理-进程管理（查看进程、终止进程、更改进程优先级）/","excerpt":"查看进程ps ps aux 查看所有进程，使用BSD操作系统格式 ps -le 查看系统所有进程，使用Linux标准命令格式","text":"查看进程ps ps aux 查看所有进程，使用BSD操作系统格式 ps -le 查看系统所有进程，使用Linux标准命令格式 参数 a ：显示一个终端的所有进程， u ：显示进程的归属用户及内存的使用情况 x ：显示没有控制终端的进程 -l ：长格式显示。显示更加详细的信息 -e ：显示所有进程，和-A作用一致 输出:1234567891011[root@localhost ~]# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.1 19348 1616 ? Ss Aug01 0:02 /sbin/initroot 2 0.0 0.0 0 0 ? S Aug01 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S Aug01 0:00 [migration/0root 4 0.0 0.0 0 0 ? S Aug01 0:00 [ksoftirqd/0root 5 0.0 0.0 0 0 ? S Aug01 0:00 [stopper/0]root 6 0.0 0.0 0 0 ? S Aug01 0:00 [watchdog/0]root 7 0.1 0.0 0 0 ? S Aug01 0:37 [events/0]root 8 0.0 0.0 0 0 ? S Aug01 0:00 [events/0]... 参数 含义 USER 该进程是由哪个用户产生的 PID 进程的ID号 %CPU 改进程占用的CPU资源的百分比，占用越高，进程越耗费资源 %MEM 该进程占用的物理内存的百分比，占用越高，进程越耗费资源 VSZ 该进程占用的虚拟内存大小，单位是KB RSS 该进程占用的物理内存大小，单位是KB TTY 该进程是在哪个终端中运行的。tty1-tty7表示本地控制台，pts/0-255表示虚拟终端 STAT 进程状态。常见状态有 R:运行 S：睡眠 T:停止状态 s：包含子进程 +：位于后台 START 该进程的启动时间 TIME 该进程占用CPU的运算时间，不是系统时间 COMMAND 产生此进程的命令名 pstree 命令显示进程树 -p：显示进程的PID -u：显示进程的所属用户 执行结果如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost ~]# pstree -upinit(1)─┬─NetworkManager(1581)─┬─dhclient(3561) │ └─&#123;NetworkManager&#125;(1645) ├─abrtd(1960) ├─acpid(1680) ├─atd(1987) ├─auditd(1462)───&#123;auditd&#125;(1463) ├─automount(1767)─┬─&#123;automount&#125;(1768) │ ├─&#123;automount&#125;(1769) │ ├─&#123;automount&#125;(1772) │ └─&#123;automount&#125;(1775) ├─certmonger(2003) ├─console-kit-dae(2584)─┬─&#123;console-kit-da&#125;(2585) │ ├─&#123;console-kit-da&#125;(2586) │ ├─&#123;console-kit-da&#125;(2587) │ ├─&#123;console-kit-da&#125;(2588) │ ├─&#123;console-kit-da&#125;(2589) │ ├─&#123;console-kit-da&#125;(2590) │ ├─&#123;console-kit-da&#125;(2591) │ ├─&#123;console-kit-da&#125;(2592) ├─crond(1972) ├─cupsd(1647) ├─dbus-daemon(1567,dbus)───&#123;dbus-daemon&#125;(1570) ├─hald(1692,haldaemon)─┬─hald-runner(1693,root)─┬─hald-addon-acpi(1738,haldaemon) │ │ └─hald-addon-inpu(1737) │ └─&#123;hald&#125;(1694) ├─login(3126)───bash(3166) ├─master(1931)─┬─pickup(21672,postfix) │ └─qmgr(1942,postfix) ├─mingetty(2050) ├─mingetty(2052) ├─mingetty(2054) ├─mingetty(2056) ├─mingetty(2064) ├─modem-manager(1588) ├─polkitd(2720) ├─rpc.statd(1604,rpcuser) ├─rpcbind(1547,rpc) ├─rsyslogd(1496)─┬─&#123;rsyslogd&#125;(1497) │ ├─&#123;rsyslogd&#125;(1498) │ └─&#123;rsyslogd&#125;(1499) ├─sshd(1835)───sshd(21691)───bash(21695)───pstree(21739) ├─udevd(548)─┬─udevd(2062) │ └─udevd(2063) └─wpa_supplicant(1648) top 命令查看系统健康状态 参数 -d： 秒数：指定top命令每隔几秒更新。默认3秒 -b： 使用批处理模式输出，一般和 -n 合用 -n： 次数：指定top命令执行的次数。一般和-b合用 交互命令： ？或h：显示帮助信息 P:以CPU使用率排序，默认是此选项 M：以内存使用率排序 N：以PID排序 q：退出top 1234567891011121314151617181920212223242526[root@localhost ~]# toptop - 02:42:13 up 9:01, 2 users, load average: 0.06, 0.04, 0.05Tasks: 97 total, 1 running, 96 sleeping, 0 stopped, 0 zombieCpu(s): 0.2%us, 0.4%sy, 0.0%ni, 99.0%id, 0.4%wa, 0.0%hi, 0.1%si, 0.0%stMem: 1004136k total, 824820k used, 179316k free, 39408k buffersSwap: 2031612k total, 0k used, 2031612k free, 596492k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 7 root 20 0 0 0 0 S 2.0 0.0 0:39.59 events/0 1 root 20 0 19348 1616 1304 S 0.0 0.2 0:02.90 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.01 kthreadd 3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 migration/0 4 root 20 0 0 0 0 S 0.0 0.0 0:00.12 ksoftirqd/0 5 root RT 0 0 0 0 S 0.0 0.0 0:00.00 stopper/0 6 root RT 0 0 0 0 S 0.0 0.0 0:00.12 watchdog/0 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 events/0 9 root 20 0 0 0 0 S 0.0 0.0 0:00.00 events_long/0 10 root 20 0 0 0 0 S 0.0 0.0 0:00.00 events_power_ef 11 root 20 0 0 0 0 S 0.0 0.0 0:00.00 cgroup 12 root 20 0 0 0 0 S 0.0 0.0 0:00.00 khelper 13 root 20 0 0 0 0 S 0.0 0.0 0:00.00 netns 14 root 20 0 0 0 0 S 0.0 0.0 0:00.00 async/mgr 15 root 20 0 0 0 0 S 0.0 0.0 0:00.00 pm 16 root 20 0 0 0 0 S 0.0 0.0 0:00.27 sync_supers 17 root 20 0 0 0 0 S 0.0 0.0 0:00.25 bdi-default 18 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kintegrityd/0 第一行 内容 说明 02:42:13 系统当前时间 up 9:01 系统的运行时间 2 users 当前用户数 load average: 0.06, 0.04, 0.05 系统在之前1分钟、5分钟、15分钟的平均负载。 第二行 内容 说明 Tasks: 97 total 系统中的进程总数 1 running 正在运行的进程数 96 sleeping 睡眠的进程数 0 stopped 正在停止的进程数 0 zombie 僵尸进程 第三行 内容 说明 Cpu(s): 0.2%us 用户模式占用的CPU百分比 0.4%sy 系统模式占用的CPU百分比 0.0%ni 改变过优先级的用户进程占用的CPU百分比 99.0%id 空闲的CPU百分比 0.4%wa 等该输入/输出的进程占用百分比 0.0%hi 硬中断请求服务占用的CPU百分比 0.1%si 软中断请求服务占用的CPU百分比 0.0%st st（Steal time）虚拟时间百分比，就是当有虚拟机时，虚拟机CPU等待实际CPU的时间百分比 第四行 内容 说明 Mem: 1004136k total 物理内存的总量，单位KB 824820k used 已经使用的物理内存数量 179316k free 空闲的物理内存数量 39408k buffers 作为缓冲区的内存数量 第五行 内容 说明 Swap: 2031612k total 交换分区（虚拟内存）的总大小 824820k used 已经使用的交换分区的大小 0k used 已经使用的交换分区的大小 2031612k free 空闲交换分区的大小 596492k cached 作为环迅的交换分区的大小 终止进程kill -l 命令 kill -[信号] pid根据进程id杀死单一进程 常见信号如下： 信号代码 信号名称 说明 1 SIGHUP 平滑重启，关闭进程，重新读取配置文件后重启 9 SIGNKILL 进程法伤问题时，强制结束进程 15 SIGTERM 正常结束的金浩，kill命令的默认信号 杀死pid为14942的进程：12kill -1 14942kill -HUP 14942 killall 命令 killall [信号] [选项] 进程名按照进程名杀死进程 选项： -i 交互式。询问是否要杀死某个进程 -I 忽略进程名的大小写 杀死tomcat进程：1killall -9 -I java pkill 命令 pkill [信号] [选项] 进程名按照进程名杀死进程 该命令的作用与killall类似，只是多出了一个按照终端号结束用户终端的功能 -t 终端号： 按照终端号踢出用户。 只有root用户可以操作 w命令查看当前用户。可知有一个本地终端和两个远程终端。WHAT表示该终端正在执行的命令。pts/1是当前终端的终端号。123456[root@localhost bin]# w 17:10:02 up 50 min, 3 users, load average: 0.71, 0.21, 0.07USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 - 16:24 41:19 0.15s 0.15s -bashtwilight pts/0 192.168.226.1 16:27 42:17 0.08s 0.08s -bashroot pts/1 192.168.226.1 16:29 0.00s 0.33s 0.05s w 根据终端号杀死pts/0用户的终端：1pkill -9 -t pts/0 修改进程优先级ps -le可以查看所有进程的信息，其中包括进程的优先级。PRI表示priority，NI表示nice。两个都是优先级，数字越小代表优先级越高。 注意事项： NI的范围是-20 到 19 普通用户调整NI值得范围是0~19，而且只能调整自己的进程 普通用户只能调高NI值，而不能降低 root用户才能设定进程NI值为负值，而且可以调整任何用户的进程 PRI(最终值) = PRI(原始值) + NI 用户只能修改NI的值，不能直接修改PRI nice 命令 nice [选项] 命令nice可以给新执行的命令直接赋予NI值，但是不能修改已经存在进程的NI值。 选项： -n NI值： 给命令赋予NI值 例如：1nice -n -5 service httpd start renice 命令 renice [优先级] PID修改已经存在的进程的NI值的命令 例如：1renice -10 2125","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux服务管理---系统运行级别、rpm启动与自启动、源码包的启动与自启动","slug":"Linux服务管理-系统运行级别、rpm启动与自启动、源码包的启动与自启动","date":"2017-08-05T03:58:00.000Z","updated":"2017-08-05T09:20:31.036Z","comments":true,"path":"2017/08/05/Linux服务管理-系统运行级别、rpm启动与自启动、源码包的启动与自启动/","link":"","permalink":"http://yoursite.com/2017/08/05/Linux服务管理-系统运行级别、rpm启动与自启动、源码包的启动与自启动/","excerpt":"系统运行级别 runlevel 查看运行级别 init num 设置运行级别","text":"系统运行级别 runlevel 查看运行级别 init num 设置运行级别 运行级别 含义 0 关机 1 单用户模式，可以想象为安全模式，主要用户系统修复 2 不完全的命令行模式 3 完全的命令行模式，标准字符界面 4 系统保留 5 图形模式 6 重启动 123[root@localhost ~]# init 3[root@localhost ~]# runlevel5 3 修改默认运行级别传统方式是更改/etc/inittab文件。但是在Centos7中，该文件的内容：12345678910111213141516# inittab is no longer used when using systemd.## ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target## systemd uses &apos;targets&apos; instead of runlevels. By default, there are two main targets:## multi-user.target: analogous to runlevel 3# graphical.target: analogous to runlevel 5## To view current default target, run:# systemctl get-default## To set a default target, run:# systemctl set-default TARGET.target 表示该文件已经不起作用，可以使用命令方式修改： multi-user.target: runlevel 3 graphical.target: runlevel 5 使用 systemctl get-default 获取默认级别。使用 systemctl set-default TARGET.target 设置默认级别 获得默认运行级别12[root@localhost etc]# systemctl get-defaultgraphical.target 设置默认运行级别为字符界面：123[root@localhost etc]# systemctl set-default multi-user.targetRemoved symlink /etc/systemd/system/default.target.Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target. 查看自启动状态chkconfig –list查看服务自启动状态,可以看到所有RPM包安装的服务 12345678[root@localhost rc.d]# chkconfig --listNetworkManager 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭abrt-ccpp 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭abrtd 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭acpid 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭atd 0:关闭 1:关闭 2:关闭 3:启用 4:启用 5:启用 6:关闭auditd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭autofs 0:关闭 1:关闭 2:关闭 3:启用 4:启用 5:启用 6:关闭 查看已启动的软件 netstat -an 查看所有端口，查看已连接端口 netstat -tulnp 查看已开启的监听状态的端口 rpm如何启动软件 通过绝对路径启动（标准启动方式） /etc/init.d/httpd start/etc/rc.d/init.d/httpd start service 命令启动（rethat系统专有命令）service httpd start|stop|restart|status 设置自启动状态 chkconfig [–level] [独立服务名] [on|off] 123[root@localhost rc.d]# chkconfig --level 2345 httpd on[root@localhost rc.d]# chkconfig --list | grep httpdhttpd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 修改/etc/rc.d/rc.local 文件，系统启动时会最后执行文件中的内容，可以加上启动特定服务的命令。最后执行的文件。 12345678910#!/bin/sh## This script will be executed *after* all the other init scripts.# You can put your own initialization stuff in here if you don&apos;t# want to do the full Sys V style init stuff.touch /var/lock/subsys/local# 自启动命令/etc/init.d/httpd start ntsysv [级别号] 图形化工具，作用和chkconfig相同。 chkconfig 和 ntsysv 做出的更改会同步，但是在rc.local文件中做出的修改，在chkconfig中无法查看到 源码包的自启动更改 /etc/rc.d/rc.local 文件，将启动命令追加到文件末尾即可。 chkconfig 命令不能识别源码包服务。 让源码包被service识别将源码包的启动脚本复制到init.d目录下，改脚本需要能接受相关参数，比如start|stop等 让源码包的服务能被chkconfig 与ntsysv命令管理 在init.d 目录下的脚本中起始处添加 # chkconfig: 35 86 76 chkconfig： 运行级别 启动顺序 关闭顺序 (/etc/rc3.d/) 在脚本中添加 # description: .. 说明， 内容随意 chkconfig --add 脚本名称 将init.d下的启动脚本加入chkconfig到命令中 相关资料 Tony老师的Linux服务列表","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux软件安装---rpm包、源码包","slug":"Linux软件安装-rpm包、源码包","date":"2017-08-02T13:41:56.000Z","updated":"2017-08-05T09:20:59.428Z","comments":true,"path":"2017/08/02/Linux软件安装-rpm包、源码包/","link":"","permalink":"http://yoursite.com/2017/08/02/Linux软件安装-rpm包、源码包/","excerpt":"","text":"RPM 安装rpm -ivh 全名 安装软件包 选项： -i (install) 安装 -v (verbose) 显示详细信息 -h (hash) 显示进度 升级rpm -Uvh 包全名（旧版本）如果已经安装就更新，如果没有安装就安装 -U (upgrade)升级 卸载rpm -e 包名后台数据库中查找包名对应的文件，然后卸载 -e(erase) –nodeps 不检查依赖性（不提倡使用） 查询(-q) 命令 作用 rpm -q 包名 查询是否安装软件包 rpm -qa 查询所有已安装的软件包 rpm -qi 包名 查询已安装软件包的信息 rpm -qip 包全名 查看未安装的包的信息 rpm -ql 包名 查看包安装位置（未安装也可以查询-p） rpm -qf 文件名 查看系统文件属于哪个软件包 rpm -qR 包名 查看包所依赖的软件包 选项： -q (query) 查询 -a (all) 所有 -i (information) 查询软件包信息 -f (file) 查询系统问价属于哪个软件包 -p (package) 查询未安装包信息 -R (requires) 查询软件包的依赖性 -V (Verify) 文件校验 rpm文件提取rpm2cpio 包全名 | cpio -idv .文件绝对路径从rpm包中提取需要的文件 rpm2cpio ： 将rpm转换为cpio格式的命令 cpio ： 标准工具，用户创建软件档案文件和从档案文件中提取文件 例如，删除ls命令：1rm -rf /bin/ls 从rpm包中提取出ls文件1rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-43.el6.x86_64.rpm | cpio -idv ./bin/ls yum在线安装yum源文件yum的源文件位于 /etc/yum.repos.d/CentOS-Base.repo ，具体文件内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.##[base]name=CentOS-$releasever - Base - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osgpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-6#released updates [updates]name=CentOS-$releasever - Updates - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/updates/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesgpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-6#additional packages that may be useful[extras]name=CentOS-$releasever - Extras - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasgpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-6#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplusgpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-6#contrib - packages by Centos Users[contrib]name=CentOS-$releasever - Contrib - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=contribgpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-6 相关参数： [base] 容器名称，一定要放在[]中 name 容器说明，随便写 mirrorlist 镜像站点 baseurl yum源服务器的地址 enabled 是否生效，1是生效，0不生效，默认生效 gpgcheck 1指数字证书生效 gpgkey 数字证书的公钥文件保存位置。不用修改 更换阿里的源 备份mv CentOS-Base.repo CentOS-Base.repo.backup 下载新的源文件，替换原来的源wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo 生成缓存yum makecache 光盘搭建yum 挂载光盘mount -t iso9660 /dev/sr0 /mnt/cdrom/ 使网络yum失效。将网络源文件改名为其他文件，或者将 enabled 设为0： 12// 将网络源文件改名为其他文件mv CentOS-Base.repo CentOS-Base.repo.ali.backup 更改 CentOS-Media.repo 文件。将baseurl 改成光盘目录，将enable改为1: 12345678[c6-media]name=CentOS-$releasever - Mediabaseurl=file:///mnt/cdrom# file:///media/cdrom/# file:///media/cdrecorder/gpgcheck=1enabled=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 验证。再次使用 yum list ，可以看到所有源的名称都变成了 c6-media。正是光盘源的名称: 123456789101112131415161718192021...vte.i686 0.25.1-9.el6 c6-media vte-devel.i686 0.25.1-9.el6 c6-media vte-devel.x86_64 0.25.1-9.el6 c6-media w3m.x86_64 0.5.2-19.el6 c6-media w3m-img.x86_64 0.5.2-19.el6 c6-media watchdog.x86_64 5.6-5.el6 c6-media wavpack.i686 4.60-1.1.el6 c6-media wavpack-devel.i686 4.60-1.1.el6 c6-media wavpack-devel.x86_64 4.60-1.1.el6 c6-media webalizer.x86_64 2.21_02-3.3.el6 c6-media webkitgtk.i686 1.4.3-9.el6_6 c6-media webkitgtk-devel.i686 1.4.3-9.el6_6 c6-media webkitgtk-devel.x86_64 1.4.3-9.el6_6 c6-media webkitgtk-doc.x86_64 1.4.3-9.el6_6 c6-media werken-xpath.noarch 0.9.4-4.beta.12.6.el6 c6-media werken-xpath-javadoc.noarch 0.9.4-4.beta.12.6.el6 c6-media wireless-tools.i686 1:29-6.el6 c6-media wireless-tools-devel.i686 1:29-6.el6 c6-media wireless-tools-devel.x86_64 1:29-6.el6 c6-media ... 常用 yum 命令 查询所有可用软件包列表yum list 查询和关键字有关的软件包yum search 关键字 自动安装指定软件包yum -y install 包名 升级（如果源中有更新版的软件包）yum -y update 包名 升级所有软件，包括内核yum -y update 卸载软件包yum -y remove 包名 参数： install 安装 remove 卸载 -y 自动回答yes 软件组管理命令 列出所有可用的软件组列表：yum grouplsit 安装指定软件组，组名可以由grouplist查询出来yum groupinstall 软件组名 卸载指定软件组yum groupremove 软件组名 源码包1、进入解压缩命令2、./configure -prefix=/usr/local/apache 安装到指定目录3、make 编译（make clean清除）4、make install编译安装 rpm包与源码包的异同启动方式不同rpm包的启动方式：从/etc/init.d/目录下启动，在执行service时也是从/etc/init.d/目录下启动。因此可以将源码包的启动脚本复制到给目录下，即可用service启动。源码包的启动方式：可以随意指定，一般是 /usr/local/ ，不可以用service命令管理 安装完毕后，仅有的不同是安装位置不同。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux---权限管理（sudo权限）","slug":"Linux-sudo权限","date":"2017-07-26T13:27:35.000Z","updated":"2017-08-25T10:04:44.163Z","comments":true,"path":"2017/07/26/Linux-sudo权限/","link":"","permalink":"http://yoursite.com/2017/07/26/Linux-sudo权限/","excerpt":"","text":"简介sudo命令允许系统管理员让普通用户执行一些或者全部的root命令。不需要暴露root密码，就可以让普通用户执行管理员的命令 修改sudo权限 visudo visudo 会自动打开etc下的sudo文件。在文件中加上允许普通用户执行的命令即可，命令格式如下： 用户名 ALL=(root) 命令 参数 括号中的内容表示在使用sudo时，以括号中的身份来执行命令，之后的命令可以加参数，表示指定命令的指定操作。命令最好是以绝对路径的方式来写。 例如：1twilight ALL=(root) /usr/sbin/shutdown -r twilight用户就可以执行shutdown -r命令，不过仅仅是-r。其他参数还是不允许的1sudo shutdown -r 当我尝试不使用绝对路径，保存退出时会报错：1twilight ALL=(root) useradd 报错信息：123456789[root@localhost ~]# visudovisudo：&gt;&gt;&gt; /etc/sudoers：syntax error 在行 94 附近&lt;&lt;&lt;现在做什么？选项有： 重新编辑 sudoers 文件(e) 退出，不保存对 sudoers 文件的更改(x) 退出并将更改保存到 sudoers 文件(危险！)(Q)现在做什么？x sudo -l可以使用 sudo -l查看当前普通用户能使用 sudo 执行的权限：12345678910111213[twilight@localhost root]$ sudo -l[sudo] password for twilight: 匹配此主机上 twilight 的默认条目： !visiblepw, always_set_home, env_reset, env_keep=&quot;COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS&quot;, env_keep+=&quot;MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE&quot;, env_keep+=&quot;LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;, env_keep+=&quot;LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;, env_keep+=&quot;LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot;, secure_path=/sbin\\:/bin\\:/usr/sbin\\:/usr/bin用户 twilight 可以在该主机上运行以下命令： (root) /usr/sbin/useradd Centos在执行sudo命令时可以不指定绝对路径：1[twilight@localhost root]$ sudo useradd tom 查看是否生效：12[twilight@localhost root]$ cat /etc/passwd | grep tom tom:x:1004:1006::/home/tom:/bin/bash 安全性如果用sudo给普通用户赋予passwd命令的权限，那么普通用户就可以用sudo命令来修改root密码，这是十分不安全的。不过，在赋予权限时可以加上一些限制，将普通用户可用的命令限制在合理范围内。 可以使用正则表达式，不需要加引号 使用 ! 取反，表示不允许执行这条命令 例如以下权限。twilight用户只能更改普通用户的密码：1twilight ALL=/usr/bin/passwd [a-zA-Z]*, !/usr/bin/passwd root, !/usr/bin/passwd &quot;&quot; 此时查看twilight的sudo权限：12345678910[root@localhost ~]# su twilight[twilight@localhost root]$ sudo -l匹配此主机上 twilight 的默认条目： !visiblepw, always_set_home, env_reset, env_keep=&quot;COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS&quot;, env_keep+=&quot;MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE&quot;, env_keep+=&quot;LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;, env_keep+=&quot;LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;, env_keep+=&quot;LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot;, secure_path=/sbin\\:/bin\\:/usr/sbin\\:/usr/bin用户 twilight 可以在该主机上运行以下命令： (root) /usr/bin/passwd [a-zA-Z]*, (root) !/usr/bin/passwd root, (root) !/usr/bin/passwd \\&quot;\\&quot; 此时尝试更改root密码：123[twilight@localhost root]$ sudo passwd root [sudo] password for twilight: 对不起，用户 twilight 无权以 root 的身份在 localhost.localdomain 上执行 /bin/passwd root。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux---权限管理（ACL权限）","slug":"Linux-ACL权限","date":"2017-07-25T13:44:18.000Z","updated":"2017-08-02T11:15:25.063Z","comments":true,"path":"2017/07/25/Linux-ACL权限/","link":"","permalink":"http://yoursite.com/2017/07/25/Linux-ACL权限/","excerpt":"","text":"ACL简介目前已知的三种权限分别是，所有者权限，所属组权限，和其他人权限。这三种权限有时并不能很好的指定所有用户的权限。当无法使用这三种权限准确的指定一个用户的权限时，可以使用acl给用户或用户组指定特定的权限。例如，所有者和所属组具有最高权限。其他人具有0权限。此时我希望给一个用户设定r-x权限。这时用以上三种权限很难实现。就可以用acl指定该用户的权限。 设定/查看 ACL权限 getfacl 文件名 ： 查看acl权限 setfacl 选项 文件名 ： 设置acl权限 常见参数： -m 设定ACL权限 -x 删除指定的ACL权限 -b 删除所有的ACL权限 -d 设定默认ACL权限 -k 删除默认ACL权限 -R 递归设定ACL权限 给特定用户设置acl权限： setfacl -m u:username:rx 文件或目录 给特定用户组设置acl权限： setfacl -m g:groupname:rx 文件或目录 例如有test目录，所有者是twilight，所属组是stu，都具有最高权限，具体属性如下：1drwxrwx---. 2 twilight stu 6 7月 25 20:05 test 如果此时希望添加一个lw用户，使之具有r-x权限，可以使用acl：1setfacl -m u:lw:rx test 用getfacl查看acl权限：123456789[root@localhost home]# getfacl test# file: test# owner: twilight# group: stuuser::rwxuser:lw:r-xgroup::rwxmask::rwxother::--- 此时查看test目录的属性：1drwxrwx---+ 2 twilight stu 6 7月 25 20:05 test 最大有效权限 maskmask 是最大权限，用户指定的权限需要与mask进行与运算，运算的结果才是用户实际具有的权限。setfacl -m m:r-x 文件或目录 12345678910[root@localhost home]# setfacl -m m:r-x test[root@localhost home]# getfacl test# file: test# owner: twilight# group: stuuser::rwxuser:lw:rwx #effective:r-xgroup::rwx #effective:r-xmask::r-xother::--- 删除 ACL 权限 删除指定用户的acl权限 setfacl -x u:用户名 文件或目录 删除指定用户组的acl权限 setfacl -x g:用户组名 文件或目录 删除文件的所有acl权限 setfacl -b 文件名 123456789[root@localhost home]# setfacl -x u:lw test[root@localhost home]# getfacl test# file: test# owner: twilight# group: stuuser::rwxgroup::rwxmask::rwxother::--- 递归权限父目录在设定acl权限是，所有的已存在的子文件俺和子目录也会具有相同的acl权限。只能针对目录setfacl -m u:lw:r-x -R 目录名 给test目录赋予r-x递归权限：1setfacl -m u:lw:r-x -R test test的子目录和子文件都会有acl权限：1234[root@localhost test]# ll总用量 0drwxrwxr-x+ 2 root root 6 7月 25 21:15 dir-rw-rw-r--+ 1 root root 0 7月 25 21:15 file 但是此时会出现一个问题，test的权限是r-x，代表可以对目录进行读和进入目录操作。但是同样的r-x对于文件来说作用是不同的。对于文件r-x表示读和执行，执行权限是最高权限。这样给文件赋予r-x权限是很不安全的。这种情况叫做权限溢出。这是acl最大的缺陷，只能手动的修改权限。 默认权限父目录中给所有新建的子文件都会集成父目录的ACL权限。setfacl -m d:u:用户名:r-x 目录名 123456789101112131415[root@localhost home]# setfacl -m d:u:lw:r-x test[root@localhost home]# getfacl test# file: test# owner: twilight# group: stuuser::rwxuser:lw:rw-group::rwxmask::rwxother::---default:user::rwxdefault:user:lw:r-xdefault:group::rwxdefault:mask::rwxdefault:other::--- 递归权限 和 默认权限的异同 递归权限：对当前已存在的文件 默认权限： 对该目录接下来新建的子文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux---Vim常用命令","slug":"Linux-Vim常用命令","date":"2017-07-25T07:34:59.000Z","updated":"2017-07-25T13:56:09.946Z","comments":true,"path":"2017/07/25/Linux-Vim常用命令/","link":"","permalink":"http://yoursite.com/2017/07/25/Linux-Vim常用命令/","excerpt":"","text":"先上图： 打开文件vim 文件名 ： 光标定位到最后一行，vim +[num] 文件名 ： 定位到第num行，如果num过大，热到最后一行vim +/str 文件名 ： 定位到str第一次出现的行。此时按n可以在所有的str之间切换vim 文件1 文件2 文件… ： 创建多个文件 :n 向后切换文件 :N(:prev) 向前切换文件 底行模式 :w 保存 :q 退出 :! 强制退出 :ls 列出所有文件 :n 下一个 :N(:prev) 前一个 :l5 定位到第5行 /xxx 从光标位置向后搜索，将光标定位在xxx第一次出现的位置 ?xxx 从光标位置向前搜索，将光标定位在xxx第一次出现的位置 编辑模式 hjkl左下上右 crtl + f 向下翻页 crtl + b 向上翻页 crtl + d 向下翻半页 crtl + u 向上翻半页 命令模式 dd 删除光标所在行 o 在光标所在行的下方插入一行，并切换到输入模式 yy 复制光标所在行 p(小写) 在光标所在行的下方粘贴 P(大写) 在光标所在行的上方粘贴 Ctrl + v 从光标当前位置开始，选中光标起点和终点所构成的矩形区域，再按一下Ｃtrl + v结束 x 删除光标所在字符 j 删除两行之间的换行符 u 撤销 U 撤销一行的全部操作 追加 i 命令可以在当前光标之前插入文本。 a 命令可以在当前光标之后插入文本。 o 命令可以在当前行的下面另起一行，并使当前模式转为Insert模式。 O 命令(注意是大写的字母O)将在当前行的上面另起一行。 放弃编辑 :q! 丢弃所有的修改并退出 :e! 放弃所有修改并重新载入该文件的原始内容","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux---权限管理（chmod、umask）","slug":"Linux-权限管理（chmod、umask）","date":"2017-07-25T02:58:24.000Z","updated":"2017-07-25T13:56:49.607Z","comments":true,"path":"2017/07/25/Linux-权限管理（chmod、umask）/","link":"","permalink":"http://yoursite.com/2017/07/25/Linux-权限管理（chmod、umask）/","excerpt":"","text":"chmod 命令chmod [选项] 模式 文件名选项： -R 递归 模式： [ugoa][+-=][rwx] 对指定的用户增加和删除权限 [mode=421] 用数字表示权限 -u 所有者 -g 所属组 -o 其他人 -a 所有人 1234chmod u+x testdata 给所有者添加执行权限chmod u-x testdata 删除所有者的执行权限chmod a+x testdata 给所有用户添加执行权限chmod u+x,o+w testdata 不同用户之间用逗号隔开 1234chmod u=rwx testdata 赋予所有者rwxchmod u=rw- testdata 所有者rw-chmod u=r testdata 所有者r--chmod u=rw,g=r,o=r testdata 所有者rw-,所有组r--,其他人r-- 权限数字表示： r–4w–2x–1 常用权限 777–rwxrwxrwx 755–rwxr-xr-x 644–rw-r–r– 1chmod 777 testdata 权限对文件的作用 r：读取文件内容（cat more head tail） w：编辑、新增、修改文件内容（vi echo） x：可执行 有写权限并不能删除文件，因为文件的信息保存在目录中，还需要目录也有相应的权限。 权限对目录的作用 r:可以查看目录下的文件名（ls） w：具有修改目录结构的权限。如新建文件和目录，删除目录下的文件和目录，重命名此目录下的文件和目录，剪切（touch rm mv cp） x：可以进入目录（cd） 文件最高权限是：x 目录的最高权限是：w（5，7） chmod chown 所有者[:|.]所属组 如果需要让某个用户具有某个文件的所有权限，可以用chown将文件的所有者改为该用户，然后给文件的所有者赋予最高权限即可。之前的o是对于所有其他用户赋予的权限，不安全。 例如，abc文件的属性如下，只有root用户可以修改文件，如果我现在想让twilight用户对这个文件具有修改权限。可以把文件的所有者改为twilight1-rw-r--r--. 1 root root 12 7月 25 09:09 abc 更改文件所有者，此时twilight用户已经可以修改文件内容了12345chown twilight abc// 查看文件属性[twilight@localhost test]$ ll总用量 4-rw-r--r--. 1 twilight root 12 7月 25 09:09 abc chgrp 将文件赋予用户组，用法与chown类似chgrp 组名 文件名 文件的默认权限umask 查看默认权限umask vlaue 暂时设置umask（root默认是0022） 0 文件特殊权限 022 文件默认权限 文件默认不能有执行权限，必须由手工赋予执行权限 文件的默认权限最大为666 新建文件的默认权限，为666减umask值 目录默认最大权限为777 建立文件之后的默认权限为777减umask值 关于umask的计算方式，网上的说法很多，简单地说,就是从最大权限中拿走对应的权限。如果umask为022，那么新建一个文件时123file: 110 110 110umask: 000 010 010result:110 100 100 如果umask为033，那么结果还是644：123file: 110 110 110umask: 000 011 011result:110 100 100 永久修改umask 需要修改文件 vi /etc/profile","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux---远程登陆Linux、互传文件","slug":"Linux-远程登陆Linux、互传文件","date":"2017-07-25T00:54:32.000Z","updated":"2017-07-25T13:57:32.222Z","comments":true,"path":"2017/07/25/Linux-远程登陆Linux、互传文件/","link":"","permalink":"http://yoursite.com/2017/07/25/Linux-远程登陆Linux、互传文件/","excerpt":"","text":"SSHLinux 与 Linux之间最简单和安全的通信方式 远程登陆Linux服务器： ssh 用户名@ip 第一次使用时需要下载公钥，输入yes即可，之后输入对应账号的密码即可登陆到Linux：12345678$ ssh root@192.168.226.128The authenticity of host &apos;192.168.226.128 (192.168.226.128)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:dOe26KCDHHBXH9pUKk70HlTeAN8ItC+Z8fnUvs9Amhs.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.226.128&apos; (ECDSA) to the list of known hosts.root@192.168.226.128&apos;s password:Last login: Tue Jul 25 08:22:54 2017 from 192.168.226.1 下载文件(-r表示目录)：scp [-r] 用户名@ip:文件路径 本地路径 将远程的文件下载到本地的D盘，因为没有登陆，所以需要输入用户密码：123$ scp root@192.168.226.128:/root/Hexo.md /D/root@192.168.226.128&apos;s password:Hexo.md 上传文件(-r表示目录)：scp [-r] 本地文件 用户名@ip:上传路径 上传一个目录到Linux，要加参数-r123$ scp -r test root@192.168.226.128:/rootroot@192.168.226.128&apos;s password:abc 意外的发现git的Windows客户端完全可以当成一个Linux主机来使用，ssh需要两台Linux主机，而我只有一个虚拟机。而且git本身就是用ssh协议的，因为有git我才能尝试使用上面几个命令。 &lt;(▰˘◡˘▰)&gt; Xshell一款远程Linux登陆工具，可以在Windows上登陆Linux，比SecureCRT更强大，而且免费， 天上当前会话的名称，目的主机的ip、端口号采用默认的22端口，然后确定即可。 winSCP非常好用的工具，很强大，可以在windows和Linux之间互传文件。 首先选择SFTP协议，填上目的主机的ip地址，端口号采取默认的22端口，然后填写用户名和密码 然后可以看到左边是window的目录结构，右边是Linux的目录结构，要复制文件只需要拖拽文件到另外一边即可，很方便 还有一款软件叫SecureCRT，听说是收费的，而且功能不及Xshell，所以已弃用。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"linux---网络管理（常用命令）","slug":"linux-网络管理（常用命令）","date":"2017-07-24T13:41:18.000Z","updated":"2017-07-25T13:58:53.172Z","comments":true,"path":"2017/07/24/linux-网络管理（常用命令）/","link":"","permalink":"http://yoursite.com/2017/07/24/linux-网络管理（常用命令）/","excerpt":"","text":"网络查看 ifconfig ： 查看与临时配置网络 ifdown 网卡设备名 ： 关闭网卡 ifup 网卡设备名 ： 启用网卡 netstat 网络状态查询 -t 列出TCP协议端口 -u 列出UDP协议端口 -n 不适用域名与服务名，而是用ip地址和端口号 -l 仅列出在监听端口 -a 所有的连接 -r 路由表 常用的组合： an 所有的连接和端口 tuln 查看正在监听TCP（t）和UDP（u）的端口 rn 查看网关 route -n 组合命令，查看系统中正在监听的端口数量： netstat -tuln | grep LISTEN | wc -l 123456789101112131415161718192021[root@localhost Tools]# netstat -tulnActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN tcp 0 0 192.168.122.1:53 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN tcp6 0 0 :::111 :::* LISTEN tcp6 0 0 :::22 :::* LISTEN tcp6 0 0 ::1:631 :::* LISTEN tcp6 0 0 ::1:25 :::* LISTEN udp 0 0 0.0.0.0:5353 0.0.0.0:* udp 0 0 0.0.0.0:48437 0.0.0.0:* udp 0 0 127.0.0.1:323 0.0.0.0:* udp 0 0 0.0.0.0:54268 0.0.0.0:* udp 0 0 192.168.122.1:53 0.0.0.0:* udp 0 0 0.0.0.0:67 0.0.0.0:* udp 0 0 0.0.0.0:68 0.0.0.0:* udp6 0 0 ::1:323 :::* udp6 0 0 :::20514 :::* nslookup翻译域名对应的ip和DNS 查看百度的ip，其中Server表示当前的DNS：12345678[root@localhost Tools]# nslookup www.baidu.comServer: 192.168.226.2Address: 192.168.226.2#53Non-authoritative answer:www.baidu.com canonical name = www.a.shifen.com.Name: www.a.shifen.comAddress: 115.239.211.112 ping ip判断网络状况 -c 发送数据包的次数123456789[root@localhost Tools]# ping -c 3 www.baidu.comPING www.a.shifen.com (115.239.210.27) 56(84) bytes of data.64 bytes from 115.239.210.27 (115.239.210.27): icmp_seq=1 ttl=128 time=28.0 ms64 bytes from 115.239.210.27 (115.239.210.27): icmp_seq=2 ttl=128 time=19.8 ms64 bytes from 115.239.210.27 (115.239.210.27): icmp_seq=3 ttl=128 time=28.4 ms--- www.a.shifen.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2004msrtt min/avg/max/mdev = 19.891/25.488/28.485/3.963 ms telnettelnet ip port明文传递数据，不安全，已弃用。现在可以用来探测对方的端口是否开启 windows也有telnet协议，只不过，默认是关闭的，使用telnet探测虚拟机的22端口，会进入一个空白的画面。虽然不能控制虚拟机，但是可以说明22端口是可用的。如果端口不可用会提示链接失败。 1telnet 192.168.226.128 22 traceroute traceroute ip（域名）路由跟踪命令 -n 使用ip，速度更快 -q 每次发送的数据包数量，默认是3 -m 设置跳数，默认是30 win中使用tracert命令达到相同的效果 tcpdump抓包工具 -i 指定网卡 -nn 键给数据包中的域名与服务转为ip和端口 -X 以十六进制和ASCII吗显示数据包内容 port 指定监听的端口 tcpdump -i ens33 -nn -X port 21 检查21端口的数据包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[root@localhost network-scripts]# tcpdump -i ens33 -nn -X tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on ens33, link-type EN10MB (Ethernet), capture size 65535 bytes11:44:39.513385 IP 192.168.42.1.55904 &gt; 239.255.255.250.1900: UDP, length 174 0x0000: 4500 00ca 1342 0000 0111 cb3d c0a8 2a01 E....B.....=..*. 0x0010: efff fffa da60 076c 00b6 3d68 4d2d 5345 .....`.l..=hM-SE 0x0020: 4152 4348 202a 2048 5454 502f 312e 310d ARCH.*.HTTP/1.1. 0x0030: 0a48 4f53 543a 2032 3339 2e32 3535 2e32 .HOST:.239.255.2 0x0040: 3535 2e32 3530 3a31 3930 300d 0a4d 414e 55.250:1900..MAN 0x0050: 3a20 2273 7364 703a 6469 7363 6f76 6572 :.&quot;ssdp:discover 0x0060: 220d 0a4d 583a 2031 0d0a 5354 3a20 7572 &quot;..MX:.1..ST:.ur 0x0070: 6e3a 6469 616c 2d6d 756c 7469 7363 7265 n:dial-multiscre 0x0080: 656e 2d6f 7267 3a73 6572 7669 6365 3a64 en-org:service:d 0x0090: 6961 6c3a 310d 0a55 5345 522d 4147 454e ial:1..USER-AGEN 0x00a0: 543a 2047 6f6f 676c 6520 4368 726f 6d65 T:.Google.Chrome 0x00b0: 2f35 392e 302e 3330 3731 2e31 3034 2057 /59.0.3071.104.W 0x00c0: 696e 646f 7773 0d0a 0d0a indows....11:44:40.514356 IP 192.168.42.1.55904 &gt; 239.255.255.250.1900: UDP, length 174 0x0000: 4500 00ca 1343 0000 0111 cb3c c0a8 2a01 E....C.....&lt;..*. 0x0010: efff fffa da60 076c 00b6 3d68 4d2d 5345 .....`.l..=hM-SE 0x0020: 4152 4348 202a 2048 5454 502f 312e 310d ARCH.*.HTTP/1.1. 0x0030: 0a48 4f53 543a 2032 3339 2e32 3535 2e32 .HOST:.239.255.2 0x0040: 3535 2e32 3530 3a31 3930 300d 0a4d 414e 55.250:1900..MAN 0x0050: 3a20 2273 7364 703a 6469 7363 6f76 6572 :.&quot;ssdp:discover 0x0060: 220d 0a4d 583a 2031 0d0a 5354 3a20 7572 &quot;..MX:.1..ST:.ur 0x0070: 6e3a 6469 616c 2d6d 756c 7469 7363 7265 n:dial-multiscre 0x0080: 656e 2d6f 7267 3a73 6572 7669 6365 3a64 en-org:service:d 0x0090: 6961 6c3a 310d 0a55 5345 522d 4147 454e ial:1..USER-AGEN 0x00a0: 543a 2047 6f6f 676c 6520 4368 726f 6d65 T:.Google.Chrome 0x00b0: 2f35 392e 302e 3330 3731 2e31 3034 2057 /59.0.3071.104.W 0x00c0: 696e 646f 7773 0d0a 0d0a indows....11:44:41.514257 IP 192.168.42.1.55904 &gt; 239.255.255.250.1900: UDP, length 174 0x0000: 4500 00ca 1344 0000 0111 cb3b c0a8 2a01 E....D.....;..*. 0x0010: efff fffa da60 076c 00b6 3d68 4d2d 5345 .....`.l..=hM-SE 0x0020: 4152 4348 202a 2048 5454 502f 312e 310d ARCH.*.HTTP/1.1. 0x0030: 0a48 4f53 543a 2032 3339 2e32 3535 2e32 .HOST:.239.255.2 0x0040: 3535 2e32 3530 3a31 3930 300d 0a4d 414e 55.250:1900..MAN 0x0050: 3a20 2273 7364 703a 6469 7363 6f76 6572 :.&quot;ssdp:discover 0x0060: 220d 0a4d 583a 2031 0d0a 5354 3a20 7572 &quot;..MX:.1..ST:.ur 0x0070: 6e3a 6469 616c 2d6d 756c 7469 7363 7265 n:dial-multiscre 0x0080: 656e 2d6f 7267 3a73 6572 7669 6365 3a64 en-org:service:d 0x0090: 6961 6c3a 310d 0a55 5345 522d 4147 454e ial:1..USER-AGEN 0x00a0: 543a 2047 6f6f 676c 6520 4368 726f 6d65 T:.Google.Chrome 0x00b0: 2f35 392e 302e 3330 3731 2e31 3034 2057 /59.0.3071.104.W 0x00c0: 696e 646f 7773 0d0a 0d0a indows....11:44:42.514598 IP 192.168.42.1.55904 &gt; 239.255.255.250.1900: UDP, length 174 0x0000: 4500 00ca 1345 0000 0111 cb3a c0a8 2a01 E....E.....:..*. 0x0010: efff fffa da60 076c 00b6 3d68 4d2d 5345 .....`.l..=hM-SE 0x0020: 4152 4348 202a 2048 5454 502f 312e 310d ARCH.*.HTTP/1.1. 0x0030: 0a48 4f53 543a 2032 3339 2e32 3535 2e32 .HOST:.239.255.2 0x0040: 3535 2e32 3530 3a31 3930 300d 0a4d 414e 55.250:1900..MAN 0x0050: 3a20 2273 7364 703a 6469 7363 6f76 6572 :.&quot;ssdp:discover 0x0060: 220d 0a4d 583a 2031 0d0a 5354 3a20 7572 &quot;..MX:.1..ST:.ur 0x0070: 6e3a 6469 616c 2d6d 756c 7469 7363 7265 n:dial-multiscre 0x0080: 656e 2d6f 7267 3a73 6572 7669 6365 3a64 en-org:service:d 0x0090: 6961 6c3a 310d 0a55 5345 522d 4147 454e ial:1..USER-AGEN 0x00a0: 543a 2047 6f6f 676c 6520 4368 726f 6d65 T:.Google.Chrome 0x00b0: 2f35 392e 302e 3330 3731 2e31 3034 2057 /59.0.3071.104.W 0x00c0: 696e 646f 7773 0d0a 0d0a indows....^C4 packets captured4 packets received by filter0 packets dropped by kernel ftp是明文传递,可以直接解析ftp包中的用户名和密码，因此telnet和ftp不是绝对安全的","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux---用户、用户组","slug":"Linux-用户、用户组","date":"2017-07-24T12:18:10.000Z","updated":"2017-07-25T14:17:18.516Z","comments":true,"path":"2017/07/24/Linux-用户、用户组/","link":"","permalink":"http://yoursite.com/2017/07/24/Linux-用户、用户组/","excerpt":"","text":"有关文件/etc/group 储存当前系统中所有用户组信息Group : x :123 :abc,def,xyz组名称：密码：编号:用户名 root的编号一定是01~499 是系统预留编号用户手动创建的组编号从500+，默认为最大的组编号+1组密码占位符全部用x表示 组管理者为空，表示组内所有用户都可以管理用户组 /etc/passwd 当前系统中所有用户的信息一行对应一个用户user : x : 123 : 456 : xxxxxx : /home/user/: /bin/bash用户名 : 密码占位符 : 用户编号 : 用户组编号: 用户注释信息 : 用户主目录 : shell类型root编号一定是0 /etc/gshadow 当前系统中所有用户组的密码信息与group文件意义对应Group: * : : abc,def,xyz 组名称：组密码：组管理者：用户名列表 /etc/shadow 当前系统中所有用户的密码信息一行对应一个用户，与passwd对应user : :用户名:密码:密码是加密过的 命令用户组 groupadd name 增加用户组 groupdel name 删除用户组（必须先删除用户） groupmod -n newname oldname 改组名 groupmod -g 编号 name 改编号 groupadd -g 编号 name 创建用户组的同时指定组编号 用户 useradd -g group username 添加到指定用户组 useradd -d /home/xxx imooc 指定个人文件夹(未指定用户组，则创建一个同名用户组) userdel username 删除用户（不删除目录） userdel -r username 删除用户的同时删除目录 usermod -l newname oldname 更改用户名 usermod -c content username 给用户添加备注 usermod -g groupname username 切换用户组 创建一个空文件nologin就可以让出了root以外的用户无法登陆 touch /etc/nologin passwd passwd username 创建或更改用户密码 passwd -l username 锁定用户 passwd -u username 解锁用户 passwd -d username 清除密码 主要组和附属组一个用户可以属于多个组gpasswd -a username[,username2] 附属组名 添加附属组 默认属于主要组 gpasswd -a username groupname 向groupname用户组中添加username用户 gpasswd groupname 更改组密码 newgrp groupname 切换到用户组 gpasswd -d username groupname 移出附属组 useradd -g maingroup -G group2[,group3…] 同时添加主用户组和附属组 常用命令 su username 切换用户（不加username则切换到root） groups username 显示用户所在组 id username 显示用户的用户信息（用户编号、用户名&amp;&amp;主要组编号名称附属组列表） chfn username 设置用户资料 finger username 显示详细资料 useradd username 增加用户 userdel username 删除用户（不删除目录） userdel -r username 删除用户的同时删除目录 usermod -l newname oldname 更改用户名 groupadd name 增加用户组 groupdel name 删除用户组（必须先删除用户） gpasswd -a username groupname 向groupname用户组中添加username用户 usermod -g groupname username 切换用户组","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux--网络管理（7层结构、netstat、ifconfig、配置文件、虚拟机中的网络连接）","slug":"Linux-网络管理（7层结构、netstat、ifconfig）","date":"2017-07-24T11:02:02.000Z","updated":"2017-07-25T14:17:37.724Z","comments":true,"path":"2017/07/24/Linux-网络管理（7层结构、netstat、ifconfig）/","link":"","permalink":"http://yoursite.com/2017/07/24/Linux-网络管理（7层结构、netstat、ifconfig）/","excerpt":"","text":"说到Linux是一个悲伤的故事，早就想学了现在还是小白水平。连个tomcat服务都搞不定。痛哉痛哉 ISO网络7层结构 层次 用途 应用层 用户接口 表示层 数据的表示形式。特定功能的实现（加密） 会话层 对应用会话的管理、同步、是否需要传递 传输层 可靠与不可靠的传输、传输前的错误检测与修正 网络层 提供逻辑地址、选路 数据链路层 帧、用Mac地址访问没接、错误检测与修正 物理层 设备之间的比特流的传递、物理接口、电器特征等 TCP/IP模型 应用层 传输层 网际互联层 网络接口层 netstat -an查看本机启用的端口 -a 查看所有连接和监听端口(ano可同时使用) -n 显示IP地址和端口号，而不是显示域名和服务名 -o 显示活动的 TCP 连接并包括每个连接的进程 ID (PID) -r 显示 IP 路由表的内容。该参数与 route print 命令等价。 端口状态： LISTENING 端口是开放的，等待连接，但还没有被连接。就像你房子的门已经敞开的，但还没有人进来。 ESTABLISHED 表示已经建立连接。两台机器正在通信。 常见端口： FTP 20 21 SSH 22 telnet 23 DNS 53 http 80 SMTP(邮件) 25 POP3(收邮件) 110 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596C:\\Users\\wangchao&gt;netstat -an活动连接 协议 本地地址 外部地址 状态 TCP 0.0.0.0:80 0.0.0.0:0 LISTENING TCP 0.0.0.0:135 0.0.0.0:0 LISTENING TCP 0.0.0.0:445 0.0.0.0:0 LISTENING TCP 0.0.0.0:902 0.0.0.0:0 LISTENING TCP 0.0.0.0:912 0.0.0.0:0 LISTENING TCP 0.0.0.0:1433 0.0.0.0:0 LISTENING TCP 0.0.0.0:49152 0.0.0.0:0 LISTENING TCP 0.0.0.0:49153 0.0.0.0:0 LISTENING TCP 0.0.0.0:49154 0.0.0.0:0 LISTENING TCP 0.0.0.0:49155 0.0.0.0:0 LISTENING TCP 0.0.0.0:49177 0.0.0.0:0 LISTENING TCP 127.0.0.1:1434 0.0.0.0:0 LISTENING TCP 127.0.0.1:4300 0.0.0.0:0 LISTENING TCP 127.0.0.1:4301 0.0.0.0:0 LISTENING TCP 172.25.208.32:139 0.0.0.0:0 LISTENING TCP 172.25.208.32:50180 108.177.97.188:5228 ESTABLISHED TCP 172.25.208.32:50234 115.182.41.173:80 ESTABLISHED TCP 172.25.208.32:52330 223.252.199.6:6003 ESTABLISHED TCP 172.25.208.32:53614 115.182.41.173:80 ESTABLISHED TCP 172.25.208.32:54164 115.182.41.173:80 ESTABLISHED TCP 172.25.208.32:54171 115.182.41.49:7080 ESTABLISHED TCP 172.25.208.32:54526 14.17.52.183:80 CLOSE_WAIT TCP 172.25.208.32:54745 115.182.41.180:80 ESTABLISHED TCP 172.25.208.32:55290 101.201.173.115:80 ESTABLISHED TCP 172.25.208.32:55329 101.201.173.115:80 ESTABLISHED TCP 172.25.208.32:55398 106.120.188.49:80 TIME_WAIT TCP 172.25.208.32:55401 183.36.108.223:443 TIME_WAIT TCP 172.25.208.32:55411 180.163.21.35:80 ESTABLISHED TCP 172.25.208.32:55412 64.233.189.138:443 SYN_SENT TCP 172.25.208.32:55413 64.233.189.102:443 SYN_SENT TCP 172.25.208.32:55414 64.233.189.102:443 SYN_SENT TCP 172.25.208.32:55415 64.233.189.138:443 SYN_SENT TCP 172.25.208.32:55416 59.111.160.195:80 ESTABLISHED TCP 192.168.42.1:139 0.0.0.0:0 LISTENING TCP 192.168.247.1:139 0.0.0.0:0 LISTENING TCP [::]:80 [::]:0 LISTENING TCP [::]:135 [::]:0 LISTENING TCP [::]:445 [::]:0 LISTENING TCP [::]:1433 [::]:0 LISTENING TCP [::]:49152 [::]:0 LISTENING TCP [::]:49153 [::]:0 LISTENING TCP [::]:49154 [::]:0 LISTENING TCP [::]:49155 [::]:0 LISTENING TCP [::]:49177 [::]:0 LISTENING TCP [::1]:1434 [::]:0 LISTENING UDP 0.0.0.0:4018 *:* UDP 0.0.0.0:5353 *:* UDP 0.0.0.0:5353 *:* UDP 0.0.0.0:5353 *:* UDP 0.0.0.0:5353 *:* UDP 0.0.0.0:5353 *:* UDP 0.0.0.0:5353 *:* UDP 0.0.0.0:5353 *:* UDP 0.0.0.0:5355 *:* UDP 0.0.0.0:50020 *:* UDP 0.0.0.0:52451 *:* UDP 0.0.0.0:54543 *:* UDP 0.0.0.0:57313 *:* UDP 0.0.0.0:60018 *:* UDP 0.0.0.0:60019 *:* UDP 0.0.0.0:60020 *:* UDP 0.0.0.0:63636 *:* UDP 0.0.0.0:65532 *:* UDP 127.0.0.1:1900 *:* UDP 127.0.0.1:53883 *:* UDP 172.25.208.32:137 *:* UDP 172.25.208.32:138 *:* UDP 172.25.208.32:1900 *:* UDP 172.25.208.32:53882 *:* UDP 192.168.42.1:137 *:* UDP 192.168.42.1:138 *:* UDP 192.168.42.1:1900 *:* UDP 192.168.247.1:137 *:* UDP 192.168.247.1:138 *:* UDP 192.168.247.1:1900 *:* UDP [::]:5353 *:* UDP [::]:5353 *:* UDP [::]:5353 *:* UDP [::]:5353 *:* UDP [::]:5355 *:* UDP [::1]:1900 *:* UDP [::1]:53881 *:* UDP [fe80::7134:d4df:12f4:7846%16]:546 *:* UDP [fe80::7134:d4df:12f4:7846%16]:546 *:* UDP [fe80::7134:d4df:12f4:7846%16]:1900 *:* UDP [fe80::95c6:d3f1:50e1:8ae4%15]:546 *:* UDP [fe80::95c6:d3f1:50e1:8ae4%15]:546 *:* UDP [fe80::95c6:d3f1:50e1:8ae4%15]:1900 *:* UDP [fe80::f053:ca43:6de1:5420%17]:546 *:* UDP [fe80::f053:ca43:6de1:5420%17]:546 *:* UDP [fe80::f053:ca43:6de1:5420%17]:1900 *:* UDP [fe80::f053:ca43:6de1:5420%17]:53880 *:* ifconfig 临时配置IP地址 ifconfig ：查看网络状态 ifconfig eth0 192.168.254.200 netmask 255.255.255.0 ： 临时配置IP和子网掩码 ifconfig 网卡名 down/up ： 关闭、打开网卡 ifconfig 网卡名 ipv4 ： 设置ipv4地址 修改配置文件配置IP地址/etc/sysconfig/network-scripts/ifcfg-ens33网卡配置文件 DEVICE=eth0 网卡设备名，需要和文件名中的网卡名一致 BOOTPROTO=none(none、dhcp、dhcp) 是否自动获取IP（如果是dhcp，下面的内容无需配置） HWADDR MAC地址 NM_CONTROLLED=yes(no) 是否可以被Network Manager图形管理工具管理 ONBOOT=yes(no) 是否随着网络服务启动(centos6以上默认是no) TYPE=Ethernet 类型为以太网 UUID 唯一识别码 IPADDR ip地址 NETMASK 子网掩码 GATEWAY 网关 DNS1 dns IPV6INIT=no ipv6没有启动 USERCTL=no 不允许非root用户控制网卡 /etc/sysconfig/network 和 /etc/hostname主机名文件CentOS7中主机名文件为hostname，内容是：localhost.localdomain 也可以通过hostname命令临时更改主机名hostname newname 临时更改主机名为newname（不加参数表示查看当前主机名） /etc/resolv.confDNS 配置文件 12nameserver 202.106.0.20(可以写多个)search localhost 其他方式 图形界面 setup工具 虚拟机网络参数配置 将 /etc/sysconfig/network-scripts/文件中的onboot改为yes表示开机自启网络。 将BOOTPROTO设置为dhcp，如果是none则需要手动设置ip地址，设置的方法是在文件尾部加上IPADDR和NETMASK属性表示ip地址和子网掩码 然后用service network restart 重启网络即可生效 虚拟机中的连接方式有三种： 桥接：虚拟机会被当成一个真正的电脑，占用局域网中的一个ip地址， NAT：可以上网，可以连通主机 仅主机模式：只能连通主机，不能上网 在校园网中使用桥接会获得一个校园网的ip，但是该ip没有登录，所以不能上网。因此在校园网中使用NAT便可以上网，此时的ip为(192.168.42.132),与本机的ip并不在一个网段中(172.25.233.40)service network start/stop/restart 开启关闭重启网络服务","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"JSP---JSTL(import、redirect、url处理、常用函数)","slug":"JSP-JSTL-import、redirect、url处理、常用函数","date":"2017-07-22T08:54:01.000Z","updated":"2017-07-22T09:16:43.713Z","comments":true,"path":"2017/07/22/JSP-JSTL-import、redirect、url处理、常用函数/","link":"","permalink":"http://yoursite.com/2017/07/22/JSP-JSTL-import、redirect、url处理、常用函数/","excerpt":"","text":"import&lt;import url=”” context=”” var=”” scope=”” charEncoding=”” varReader=””&gt;&lt;/c:import&gt;包含另一个 JSP 页 面到本页面来 url 文件的url var 导入的数据保存到var中 scope var的保存位置 charEncoding 编码方式 直接导入外部url 1&lt;c:import url=&quot;http://www.imooc.com&quot;&gt;&lt;/c:import&gt; 导入当前项目下的文件 12&lt;c:import url=&quot;import.txt&quot; charEncoding=&quot;utf-8&quot; var=&quot;txt&quot; scope=&quot;session&quot;&gt;&lt;/c:import&gt;&lt;c:out value=&quot;#$&#123;sessionScope.txt &#125;&quot;&gt;&lt;/c:out&gt; -导入另一个项目中的文件。需要更改context.xml文件。将添加属性 crossContext=&quot;true&quot; 1&lt;c:import url=&quot;/hello.html&quot; context=&quot;/Train_HTML&quot;&gt;&lt;/c:import&gt; redirect页面重定向 url 指定页面的地址， context其他web应用的页面 123456 &lt;c:redirect url=&quot;OutTest.jsp&quot;&gt; &lt;c:param name=&quot;username&quot;&gt;tom&lt;/c:param&gt; &lt;c:param name=&quot;password&quot;&gt;123&lt;/c:param&gt; &lt;/c:redirect&gt;// http://localhost:8080/Test/JSTLTest/import.txt?username=tom&amp;password=123 URL动态生成一个String类型的URL,与c:param一起使用 value url路径 var 将url保存在变量中 12345 &lt;c:url value=&quot;http://localhost:8080/Test/URLTest.jsp&quot; var=&quot;urlstr&quot;&gt; &lt;c:param name=&quot;data&quot; value=&quot;$&#123;data &#125;&quot;&gt;&lt;/c:param&gt; &lt;/c:url&gt; &lt;a href=&quot;$&#123;urlstr &#125;&quot;&gt;url&lt;/a&gt;// http://localhost:8080/Test/URLTest.jsp?data=sss 常用函数使用JSTL函数需要导入JSTL函数标签： 1&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt; 常用函数罗列如下： 函数 作用 length() 返回长度 replace(text, ‘-‘,’.’) 替换一个字符串与另一个字符串的匹配 split(str,”.”) 分割字符串，保存在数组中 startsWith(str1,str2) 是否以指定字符串开始 endWith(str1,str2) 判断str1是否以str2结尾 substring(str,begin,end) 子串 toLowerCase() 小写 toUpperCase() 大写 trim() 去除两边空格 contains(strlong,str) 判断子串 containsIgnreCase(strLong,str) 判断子串，忽略大小写 indexOf(str1,str2) 判断str2出现的index值 escapeXml() 忽略用于XML标记的字符。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"JSP---使用JSTL(out、set、remove、catch捕捉异常、条件判断、流程控制、字符截取)","slug":"JSP-使用JSTL-out、set、remove、catch捕捉异常、条件判断、流程控制、字符截取","date":"2017-07-22T08:53:15.000Z","updated":"2017-07-23T02:47:05.402Z","comments":true,"path":"2017/07/22/JSP-使用JSTL-out、set、remove、catch捕捉异常、条件判断、流程控制、字符截取/","link":"","permalink":"http://yoursite.com/2017/07/22/JSP-使用JSTL-out、set、remove、catch捕捉异常、条件判断、流程控制、字符截取/","excerpt":"","text":"使用JSTL在MyEclipse2014中，使用JSTL只要在文件开始加上一句1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; prefix表示前缀，用于区分其他标签，可以自定义前缀。使用JSTL可以进一步减少Scriptlet的使用。使前端页面更加简洁 输出语句out&lt;c:out value=”value” default=”default” escapeXml=”true/false” &gt;&lt;/c:out&gt; 输出常量： 1&lt;c:out value=&quot;test&quot;&gt;&lt;/c:out&gt; 输出变量 12&lt;% String username = &quot;tom&quot;;session.setAttribute(&quot;username&quot;, username); %&gt;&lt;c:out value=&quot;username: $&#123;username&#125;&quot;&gt;&lt;/c:out&gt; 当没有获取到值时，采用默认值 1&lt;c:out value=&quot;$&#123;username2&#125;&quot; default=&quot;default&quot;&gt;&lt;/c:out&gt; 当出现特殊字符时，是否保留(false-不保留|true-保留) 12&lt;c:out value=&quot;&amp;lt;out&amp;gt;&quot; escapeXml=&quot;false&quot;&gt;&lt;/c:out&gt; // &lt;out&gt;&lt;c:out value=&quot;&amp;ltout&amp;gt&quot; escapeXml=&quot;false&quot;&gt;&lt;/c:out&gt; // &lt;out&gt; 赋值语句set&lt;c:set value=”value” var=”var” scope=”session” [target=”” property=””]&gt;&lt;/c:set&gt;表示把值value储存到var变量中，变量储存的范围是scope指定的范围。如果不指定scope，则scope取默认值page 为变量赋值： 123// 将username变量赋值为zhangsan，并保存到sessionScope中 &lt;c:set value=&quot;zhangsan&quot; var=&quot;username&quot; scope=&quot;session&quot;&gt;&lt;/c:set&gt; &lt;c:out value=&quot;$&#123;sessionScope.username &#125;&quot;&gt;&lt;/c:out&gt; 赋值时value可以不写，将value的内容写在标签之中也可： 123// 将变量address赋值为‘合肥市’ &lt;c:set var=&quot;address&quot; scope=&quot;page&quot;&gt;合肥市&lt;/c:set&gt; &lt;c:out value=&quot;$&#123;pageScope.address &#125;&quot;&gt;&lt;/c:out&gt; 向JavaBean中赋值： 1234567// 声名JavaBean&lt;jsp:useBean id=&quot;user&quot; class=&quot;Bean.JavaBean&quot;&gt;&lt;/jsp:useBean&gt;// 将id为user的JavaBean中name属性赋值为‘zhangsan’ &lt;c:set target=&quot;$&#123;user&#125;&quot; property=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/c:set&gt; &lt;c:out value=&quot;$&#123;pageScope.user.name &#125;&quot;&gt;&lt;/c:out&gt; &lt;c:out value=&quot;$&#123;user.name &#125;&quot;&gt;&lt;/c:out&gt; 和之前一样，value可以包围在标签中 12&lt;c:set target=&quot;$&#123;user &#125;&quot; property=&quot;password&quot; &gt;123&lt;/c:set&gt;&lt;c:out value=&quot;$&#123;user.password &#125;&quot;&gt;&lt;/c:out&gt; PS：以上的例子中，直接使用了${user,name},是因为，JavaBean在翻译时被自动保存到pageScope中，因此使用JavaBean时可以直接用EL获得JavaBean，而不需要调用setAttribute()方法传递参数：123456Bean.JavaBean user = null;user = (Bean.JavaBean) _jspx_page_context.getAttribute(&quot;user&quot;, javax.servlet.jsp.PageContext.PAGE_SCOPE);if (user == null)&#123; user = new Bean.JavaBean(); _jspx_page_context.setAttribute(&quot;user&quot;, user, javax.servlet.jsp.PageContext.PAGE_SCOPE);&#125; 捕获异常语句catchcatch包围的语句出现错误时，会将异常保存在var中，可以使用EL表达式获得err的值1234&lt;c:catch var=&quot;error&quot;&gt; &lt;c:set target=&quot;sss&quot; property=&quot;sss&quot; value=&quot;123&quot;&gt;&lt;/c:set&gt;&lt;/c:catch&gt;&lt;c:out value=&quot;$&#123;error &#125;&quot; &gt;&lt;/c:out&gt; 结果：1javax.servlet.jsp.JspTagException: Invalid property in &amp;lt;set&amp;gt;: &quot;sss&quot; 移除属性remove&lt;c:remove var=”username” scope=”scope”&gt;&lt;/c:remove&gt;从scope范围中移除var变量。其中var时必须的，scope是可选的 123456&lt;c:set var=&quot;username&quot; value=&quot;tim&quot; scope=&quot;application&quot;&gt;&lt;/c:set&gt;&lt;c:out value=&quot;$&#123;username &#125;&quot; &gt;&lt;/c:out&gt;&lt;!-- var属性必选，scope可选 --&gt;&lt;c:remove var=&quot;username&quot; &gt;&lt;/c:remove&gt;&lt;c:out value=&quot;$&#123;username &#125;&quot;&gt;&lt;/c:out&gt; 简单判断语句if&lt;c:if test=”${param.score&gt;=90 }” var=”result” scope=”application”&gt;test表示判断的条件，var表示判断的结果，scope表示保存判断结果的范围。与Java中的if语句不同该语句没有else，如果要实现if else-if 则需要用choose语句。 12345&lt;c:if test=&quot;$&#123;param.score&gt;=90 &#125;&quot; var=&quot;result&quot; scope=&quot;application&quot;&gt; &lt;c:out value=&quot;优秀&quot; &gt;&lt;/c:out&gt;&lt;/c:if&gt;&lt;c:out value=&quot;sss $&#123;applicationScope.result &#125;&quot;&gt;&lt;/c:out&gt; 复杂判断语句 choose、when、otherwise 实现条件判断choose、when、otherwise嵌套使用可以实现if else-if else 条件判断。otherwise类似于Java中的else，可以省略不写。 1234567891011&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;param.score&gt;=90 &amp;&amp; param.score&lt;=100 &#125;&quot;&gt; &lt;c:out value=&quot;优秀&quot;&gt;&lt;/c:out&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.score&gt;=60 &amp;&amp; param.score&lt;90 &#125;&quot;&gt; &lt;c:out value=&quot;良好&quot;&gt;&lt;/c:out&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;c:out value=&quot;输入有误&quot;&gt;&lt;/c:out&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 循环语句 forEach&lt;c:forEach var=”fruit” items=”${fruits }” begin=”0” end=”4” step=”1” varStatus=”fru”&gt;&lt;/c:forEach&gt;属性： items ： 表示变量的集合 var ： 表示每次从集合中取出的值 begin ： 如果指定了items，那么迭代就从items[begin]开始进行迭代；如果没有指定items，那么就从begin开始迭代。它的类型为整数 end ： 如果指定了items，那么就在items[end]结束迭代；如果没有指定items，那么就在end结束迭代。它的类型也为整数 step ： 步长 varStatus ： 通过index、count、first、last 4个状态值，描述begin和end子集中元素的状态 varStaus的4个取值： index ： 当前元素在集合中的下标，起始位0 count ： 当前元素在begin、end子集中的序号，起始位为1 first ： 判断当前元素是不是当前子集的首元素，true/false last ： 判断当前元素是不是当卡子集的末尾元素，true/false PS： 遍历Map时，var中的对象会是entry，需要手动调用getKey() 和 getValue()方法 切割字符串，默认字符串之间用逗号隔开，forEach会以逗号为分隔符，将字符转拆分开，如果需要自定义分隔符，则需要使用forTakens 有以下集合：123456789&lt;% List&lt;String&gt; fruits = new ArrayList&lt;String&gt;(); fruits.add(&quot;apple&quot;); fruits.add(&quot;pear&quot;); fruits.add(&quot;watermelon&quot;); fruits.add(&quot;orange&quot;); request.setAttribute(&quot;fruits&quot;, fruits);%&gt; 全部遍历 12345678910&lt;c:forEach var=&quot;fruit&quot; items=&quot;$&#123;fruits &#125;&quot;&gt; &lt;c:out value=&quot;$&#123;fruit &#125;&quot;&gt;&lt;/c:out&gt; &lt;br /&gt;&lt;/c:forEach&gt;// 结果 apple pear watermelon orange 部分遍历,闭合区间[begin,end] 12345678&lt;c:forEach var=&quot;fruit&quot; items=&quot;$&#123;fruits &#125;&quot; begin=&quot;1&quot; end=&quot;3&quot;&gt; &lt;c:out value=&quot;$&#123;fruit &#125;&quot;&gt;&lt;/c:out&gt; &lt;br /&gt;&lt;/c:forEach&gt;结果： pear watermelon orange 部分遍历，指定步长 1234567&lt;c:forEach var=&quot;fruit&quot; items=&quot;$&#123;fruits &#125;&quot; begin=&quot;0&quot; end=&quot;4&quot; step=&quot;2&quot;&gt; &lt;c:out value=&quot;$&#123;fruit &#125;&quot;&gt;&lt;/c:out&gt; &lt;br /&gt;&lt;/c:forEach&gt;结果： apple watermelon 使用varStatus获得当前元素状态 12345678910111213141516171819202122232425262728293031&lt;c:forEach var=&quot;fruit&quot; items=&quot;$&#123;fruits &#125;&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;1&quot; varStatus=&quot;fru&quot;&gt; &lt;c:out value=&quot;$&#123;fruit &#125;&quot;&gt;&lt;/c:out&gt;&lt;br /&gt; &lt;c:out value=&quot;count:$&#123;fru.count &#125;&quot;&gt;&lt;/c:out&gt;&lt;br /&gt; &lt;c:out value=&quot;index: $&#123;fru.index &#125;&quot;&gt;&lt;/c:out&gt;&lt;br /&gt; &lt;c:out value=&quot;first:$&#123;fru.first &#125;&quot;&gt;&lt;/c:out&gt;&lt;br /&gt; &lt;c:out value=&quot;last:$&#123;fru.last &#125;&quot;&gt;&lt;/c:out&gt;&lt;br /&gt; &lt;c:out value=&quot;-----------&quot;&gt;&lt;/c:out&gt;&lt;br /&gt; &lt;br /&gt;&lt;/c:forEach&gt;结果： pear count:1 index: 1 first:true last:false ----------- watermelon count:2 index: 2 first:false last:false ----------- orange count:3 index: 3 first:false last:true ----------- 切割字符串，默认以逗号为分隔符： 123&lt;c:forEach var=&quot;word&quot; items=&quot;abc,edf,g&quot;&gt; &lt;c:out value=&quot;$&#123;word &#125;&quot;&gt;&lt;/c:out&gt;&lt;/c:forEach&gt; 遍历Map，var中是entry对象： 123456789 &lt;% Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;name&quot;, &quot;tom&quot;); map.put(&quot;password&quot;,&quot;123&quot;); pageContext.setAttribute(&quot;map&quot;, map); %&gt;&lt;c:forEach var=&quot;entry&quot; items=&quot;$&#123;map &#125;&quot;&gt; &lt;c:out value=&quot;$&#123;entry.key &#125;:$&#123;entry.value &#125;&quot;&gt;&lt;/c:out&gt;&lt;br/&gt;&lt;/c:forEach&gt; 字符串截取 fortakens&lt;c:forTokens var=”str” items=”abc-def-ghi-jkl-mn-opq” delims=”-“ begin=”0” end=”4” step=”1” varStatus=”strstate”&gt;&lt;/c:forTokens&gt;与ForEach功能不同，但是用法类似。items表示要操作的字符串，delims（delimiter）表示分隔符，var代表每次取值的变量，begin、end表示开始结束位置，varStatus表示状态，这几个属性用法与ForEach一样。 截取前5的单词：12345678910&lt;c:forTokens items=&quot;abc-def-ghi-jkl-mn-opq&quot; delims=&quot;-&quot; var=&quot;str&quot; begin=&quot;0&quot; end=&quot;4&quot;&gt; &lt;c:out value=&quot;$&#123;str &#125;&quot;&gt;&lt;/c:out&gt;&lt;br/&gt;&lt;/c:forTokens&gt;结果： abc def ghi jkl mn","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"JSP---EL表达式","slug":"JSP-EL表达式","date":"2017-07-20T01:31:30.000Z","updated":"2017-08-05T09:21:25.576Z","comments":true,"path":"2017/07/20/JSP-EL表达式/","link":"","permalink":"http://yoursite.com/2017/07/20/JSP-EL表达式/","excerpt":"","text":"简介之前获得request中的参数需要使用getParameter()获得，使用EL可以更加简单：${param.username}，param表示从request的请求参数中获得name为username的属性值。EL减少了Scriptlet的使用。例如一个求和的例子： 123String a = request.getParameter(&quot;a&quot;);String b = request.getParameter(&quot;b&quot;);out.println(&quot;a+b=&quot;+(Integer.parseInt(a)+Integer.parseInt(b))); 用EL表达式：1$&#123;param.a&#125; + $&#123;param.b&#125; = $&#123;param.a+param.b&#125; EL可以自动完成类型的转换，通过param.a简单的获取request中的参数 使用EL获得属性. [] 都可以用来获得属性 如果使用.，那么，左边可以是JavaBean、Map对象 如果使用[]，那么，左边可以是JavaBean、Map、数组、List对象 访问数组：1234567&lt;% // 数组 String [] str = &#123;&quot;tom&quot;,&quot;jerry&quot;&#125;; session.setAttribute(&quot;str&quot;, str);%&gt; &lt;p&gt;数组 $&#123;str[1]&#125; &lt;/p&gt; &lt;p&gt;数组 $&#123;str[&quot;1&quot;]&#125; &lt;/p&gt; 访问集合List：12345678&lt;% // List List&lt;String&gt; strList = new ArrayList(); strList.add(&quot;a&quot;); strList.add(&quot;b&quot;); session.setAttribute(&quot;strList&quot;, strList);%&gt; &lt;p&gt;List $&#123;strList[0]&#125; &lt;/p&gt; 访问Map：12345678910&lt;% // Map Map&lt;String,String&gt; map = new HashMap(); map.put(&quot;tom&quot;, &quot;a&quot;); map.put(&quot;jerry&quot;, &quot;b&quot;); session.setAttribute(&quot;map&quot;, map); %&gt; &lt;p&gt;Map $&#123;map[&quot;tom&quot;]&#125; &lt;/p&gt; &lt;p&gt;Map $&#123;map.tom&#125; &lt;/p&gt; 对于Map，建议使用[] 因为如果参数名含有特殊字符时，使用.会报错：1&lt;p&gt;Map $&#123;map[&quot;tom jerry&quot;] &#125; &lt;/p&gt; 还可以嵌套使用：1&lt;p&gt;嵌套 $&#123;map[str[0]] &#125;&lt;/p&gt; EL 隐式对象 隐式对象 含义 pageScope PageContext范围 requestScope request范围 sessionScope session范围 applicationScope application范围 pageContext 当前页面 param 请求参数 paramValues 获得请求参数的所有值 Header 数据包的头部信息 HeaderValues 数据包的头部信息的name对应的所有value cookie cookie initParam ServletContext的初始化参数，即&lt;context-param&gt;中的参数 属性范围：pageScope、requestScope、sessionScope、application可以获得setAttribute()方法获得的属性。 12345678&lt;%String test = &quot;test&quot;;pageContext.setAttribute(&quot;test&quot;, test);session.setAttribute(&quot;test&quot;, test);%&gt;&lt;p&gt;$&#123;pageScope.test&#125;&lt;/p&gt;&lt;p&gt;$&#123;sessionScope.test&#125;&lt;/p&gt; 请求参数：param 相当于getParameter() 。paramValues 相当于getParameterValues()，返回数组可以用 []获取 。(Header与HeaderValues与之类似) 1234// http://localhost:8080/Test/EL/ELTest1.jsp?name=tom &lt;p&gt;$&#123;param.name &#125;&lt;/p&gt;//http://localhost:8080/Test/EL/ELTest1.jsp?name=tom&amp;name=jerry &lt;p&gt;$&#123;paramValues.name[1] &#125;&lt;/p&gt; cookie可以获得cookie中的值 initParam可以获得ServletContext的初始化参数参数： 1234&lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;tim&lt;/param-value&gt;&lt;/context-param&gt; 使用initParam获得参数1&lt;p&gt;initParam $&#123;initParam.username &#125;&lt;/p&gt; 关闭EL可以使用page指示元素的isELIgnored属性设置是否使用El &lt;%@ page isELIgnored=&quot;true&quot; %&gt; 还可以使用自定义函数，日后在做总结","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"cutey","slug":"2333","date":"2017-07-19T11:12:31.000Z","updated":"2017-07-23T01:37:53.410Z","comments":true,"path":"2017/07/19/2333/","link":"","permalink":"http://yoursite.com/2017/07/19/2333/","excerpt":"","text":"","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"JSP---隐式对象、pageContext、错误处理","slug":"JSP-隐式对象、pageContext、错误处理","date":"2017-07-18T13:37:20.000Z","updated":"2017-07-19T10:45:48.085Z","comments":true,"path":"2017/07/18/JSP-隐式对象、pageContext、错误处理/","link":"","permalink":"http://yoursite.com/2017/07/18/JSP-隐式对象、pageContext、错误处理/","excerpt":"","text":"简介隐式对象是_jspService()中的局部变量，故只能在&lt;% %&gt; 和 &lt;%= %&gt;中使用 隐式对象 隐式对象 说明 out JspWriter对象，内部关联PrintWriter对象 request 对应HttpServletRequest对象 response 对应HttpServletResponse对象 config 对应ServletConfig application 对应ServletContext session 对应HttpSession pageContext 对应PageContent对象。将所有JSP页面信息封装起来，可以通过pageContext获得所有的隐式对象 exception 对应Throwable对象，代表由其他JSP页面抛出的一场对象，只会出现在JSP错误页面 page 对应转译后的this pageContext使用pageContext可以获取所有隐式对象，也可以访问 page、request、session、application范围的变量。123456request = pageContext.getRequest();response = pageContext.getResponse();config = pageContext.getServletConfig();application = pageContext.getServletContext();session = pageContext.getSession();out = pageContext.getOut(); 常用方法： setAttribute(String name, String value, int scope)：如果没有指定scope，该属性默认在page范围内 getAttribute(String name, int scope) 获得属性值 removeAttribute(String name, int scope) 移除属性 findAttribute()依次从页面、请求、会话、应用程序范围查找有无对应的属性 查找范围(scope) pageContext.APPLICATION_SCOPE ServletContext（application） pageContext.REQUEST_SCOPE request pageContext.SESSION_SCOPE session pageContext.PAGE_SCOPE pageContext 1234567891011&lt;%pageContext.setAttribute(&quot;scope&quot;, &quot;page&quot;);session.setAttribute(&quot;scope&quot;, &quot;session&quot;);application.setAttribute(&quot;scope&quot;, &quot;application&quot;);request.setAttribute(&quot;scope&quot;, &quot;request&quot;);%&gt;page:&lt;%= pageContext.getAttribute(&quot;scope&quot;, pageContext.PAGE_SCOPE) %&gt;&lt;br/&gt;session:&lt;%= pageContext.getAttribute(&quot;scope&quot;, pageContext.SESSION_SCOPE) %&gt;&lt;br/&gt;application:&lt;%= pageContext.getAttribute(&quot;scope&quot;, pageContext.APPLICATION_SCOPE) %&gt;&lt;br/&gt;request:&lt;%= pageContext.getAttribute(&quot;scope&quot;, pageContext.REQUEST_SCOPE) %&gt;&lt;br/&gt; 错误处理错误界面只有iserrorPage为true时才可以使用exception对象 发生错误的页面 hello.jsp12345678&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ page errorPage=&quot;Error.jsp&quot; %&gt;&lt;html&gt; &lt;body&gt; &lt;%=1/0 %&gt; &lt;/body&gt;&lt;/html&gt; 错误页面 error.jsp123456789&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ page isErrorPage=&quot;true&quot; %&gt;&lt;html&gt; &lt;body&gt; &lt;h1&gt;这是一个错误界面&lt;/h1&gt; &lt;%=exception %&gt; &lt;hr/&gt; &lt;/body&gt;&lt;/html&gt; error-page如果希望容器在发现某个错误或者异常时，自动转发至错误页面，则可以使用 &lt;error-page&gt;&lt;/error-page&gt;123456789&lt;error-page&gt; &lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt; &lt;location&gt;/JSPTest/Error.jsp&lt;/location&gt;&lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/JSPTest/Error.jsp&lt;/location&gt;&lt;/error-page&gt;","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"Servlet---请求封装器","slug":"Servlet-请求封装器","date":"2017-07-18T11:17:38.000Z","updated":"2017-07-19T10:39:20.580Z","comments":true,"path":"2017/07/18/Servlet-请求封装器/","link":"","permalink":"http://yoursite.com/2017/07/18/Servlet-请求封装器/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;如果前端传入的字符串中包含特殊字符。例如HTML标签 &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;,传入这种参数会导致后台吧字符串当成了HTML链接。为了避免这种情况的发生，需要过滤用户输入的字符串。&nbsp;&nbsp;&nbsp;&nbsp;从Request中可以用 getParameter()方法获取参数，可以将获得的参数进行处理，但是Request却没有类似“setParameter()”的方法。当然，也可以直接重写getParameter，但是就需要接口中的所有方法都重写，非常麻烦。&nbsp;&nbsp;&nbsp;&nbsp;HttpServletRequestWrapper类使用了HttpServletRequest接口，并实现了所有的方法，使用时只需集成该类，并重写需要的特定方法即可。 WrapperTest继承自HttpServletRequestWrapper，并重写了getParameter，构造函数传入的是真正的Request，可以使用getRequest()获取它，之后可以通过过滤器用WrapperTest替换HttpServletRequest1234567891011121314public class WrapperTest extends HttpServletRequestWrapper &#123; // 传入真正的request public WrapperTest(HttpServletRequest request) &#123; super(request); &#125; // 处理从request中获得的参数 public String getParameter(String name) &#123; String result = this.getRequest().getParameter(name); // 使用StringEscapeUtils过滤特殊字符 return StringEscapeUtils.escapeHtml3(result); &#125;&#125; 用WrapperTest替换HttpServletRequest，doFilter()中将WrapperTest传入，之后的Servlet就会从WrapperTest中获得参数，而不是从HttpServletRequest中获得。1234567891011121314public class WrapperFilter implements Filter &#123; public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; // 创建新的Request HttpServletRequestWrapper requestWrapper = new WrapperTest((HttpServletRequest)arg0); // 用WrapperTest对象替换HttpServletRequest，使getParameter具有过滤的功能 arg2.doFilter(requestWrapper, arg1); &#125; public void init(FilterConfig arg0) throws ServletException &#123;&#125; public void destroy() &#123;&#125;&#125; 直接访问Servlet（http://localhost:8080/Test/hello?html=&lt;a href=&#39;http://www.baidu.com&gt;百度&lt;/a&gt;）12345String html = req.getParameter(&quot;html&quot;);System.out.println(&quot;#&quot;+html);结果：&amp;lt;a href=&apos;http://www.baidu.com&apos;&amp;gt;百度&amp;lt;/a&amp;gt;","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Servlet---过滤器","slug":"Servlet-过滤器","date":"2017-07-18T11:10:38.000Z","updated":"2017-07-19T10:37:13.442Z","comments":true,"path":"2017/07/18/Servlet-过滤器/","link":"","permalink":"http://yoursite.com/2017/07/18/Servlet-过滤器/","excerpt":"要实现过滤器，必须实现Filter接口，并再web.xml或者注解中定义过滤器。过滤器有三个主要方法：","text":"要实现过滤器，必须实现Filter接口，并再web.xml或者注解中定义过滤器。过滤器有三个主要方法： init(FilterConfig config) 获得初始化参数，用法与servlet相同，需要配置初始化参数 doFilter(ServltRequest request,ServletResponse response,FilterChain chain) 执行过滤流程 destory()过滤器关闭时执行 web.xml 配置过滤器与Servlet的配置基本类似，除了url-pattern外，还可以通过servlet指定12345678910111213&lt;filter&gt; &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.FirstFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;tom&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 通过servlet-name指定servlet1234&lt;filter-mapping&gt; &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt; &lt;servlet-name&gt;dispatcher.Dispatch&lt;/servlet-name&gt;&lt;/filter-mapping&gt; web3.0中使用注解配置过滤器123456789@WebFilter( filterName=&quot;WrapperFilter&quot;, urlPatterns=&#123;&quot;/*&quot;&#125;, servletNames=&#123;&#125;, initParams=&#123; @WebInitParam(name=&quot;name&quot;,value=&quot;tom&quot;), @WebInitParam(name=&quot;password&quot;,value=&quot;123&quot;) &#125; ) 当同时有urlPattern和servletNames，则先对比urlPattern 再对比servletNames 多个过滤器一个servlet可以同时有多个过滤器，执行时，按照web.xml先后顺序组装成一条链，执行完毕后，限制性最后进来执行的过滤器，即后进先出，类似于栈。 同时具有两个过滤器的情况：1234567891011121314151617181920212223// FirstFilter public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; // TODO Auto-generated method stub System.out.println(&quot;start-doFilter---FirstFilter&quot;); arg2.doFilter(arg0, arg1); System.out.println(&quot;end-doFilter---FirstFilter&quot;); &#125;// SecondFilter public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub System.out.println(&quot;start---doFilter---SecondFilter&quot;); chain.doFilter(request, response); System.out.println(&quot;end---doFilter---SecondFilter&quot;); &#125;// 结果： start-doFilter---FirstFilter start---doFilter---SecondFilter end---doFilter---SecondFilter end-doFilter---FirstFilter 过滤器类别 request 用户直接访问页面时，调用过滤器 forward 通过RequestDispatcher的forward访问时调用过滤器 include 通过RequestDispatcher的include访问时调用过滤器 error 一场处理机制调用时，调用过滤器 async 异步 当Test1被forward方式访问时，触发FirstFilter过滤器12345&lt;filter-mapping&gt; &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/Test1&lt;/url-pattern&gt; &lt;dispatcher&gt;forward&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 触发方式1234// Servlet RequestDispatcher dispatch = req.getRequestDispatcher(&quot;/Test1&quot;).forward(req, resp);// JSP &lt;jsp:forward page=&quot;index.jsp&quot;&gt;&lt;/js errorerror-page可以在发生特定的错误时，跳转到指定的页面1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; 由error-page跳转的页面需要经过error类型的过滤器,配置dispatcher后，发生错误时，过滤器可以采取相应措施12345&lt;filter-mapping&gt; &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/error.jsp&lt;/url-pattern&gt; &lt;dispatcher&gt;error&lt;/dispatcher&gt;&lt;/filter-mapping&gt;","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"MySQL---储存过程","slug":"MySQL-储存过程","date":"2017-07-11T02:45:28.000Z","updated":"2017-08-26T01:00:26.525Z","comments":true,"path":"2017/07/11/MySQL-储存过程/","link":"","permalink":"http://yoursite.com/2017/07/11/MySQL-储存过程/","excerpt":"创建存储过程CREATE PROCEDURE sp_name ([proc_parameter[,…]])routine_body","text":"创建存储过程CREATE PROCEDURE sp_name ([proc_parameter[,…]])routine_body proc_parameter: [IN|OUT|INOUT] param_name type 参数 IN，表示给参数的值必须在调用存储过程时指定 OUT，表示该参数的额值可以被存储过程改变，并可以返回 INOUT，表示该参数的调用时指定，并且可以被改变和返回 调用存储过程 CALL sp_name([parameter[,…]]) CALL sp_name[()] 无参过程的调用可以不写小括号 1234567891011# 创建无参数的储存过程mysql&gt; CREATE PROCEDURE sp1() SELECT VERSION();# 调用无参数的储存过程可以不加括号mysql&gt; CALL sp1;mysql&gt; CALL sp1();+------------+| VERSION() |+------------+| 5.7.18-log |+------------+ 12345678# 创建IN类型参数mysql&gt; CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED) -&gt; BEGIN -&gt; DELETE FROM user WHERE id = p_id ; -&gt; END -&gt; //mysql&gt; CALL removeUserById(9)// 删除储存过程DROP PROCEDURE [IF EXISTS] sp_name 示例12345678// 删除指定的记录，并返回剩余记录的数量mysql&gt; CREATE PROCEDURE removeUserAndReturnUserNums(IN p_id INT UNSIGNED,OUT userNums INT UNSIGNED) -&gt; BEGIN -&gt; DELETE FROM user WHERE id = p_id; -&gt; SELECT COUNT(id) FROM user INTO userNums; -&gt; END -&gt; //Query OK, 0 rows affected (0.00 sec) ROW_COUNT(); 被增删改更改的行数 12345678910111213141516# 使用ROW_COUNT() 获得被更改的行数mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE removeUserByUserName(IN user_name VARCHAR(20),OUT deleteCount INT,OUT restCount INT) -&gt; BEGIN -&gt; DELETE FROM user WHERE username = user_name; -&gt; SELECT ROW_COUNT() INTO deleteCount; -&gt; SELECT COUNT(id) FROM user INTO restCount; -&gt; END -&gt; //mysql&gt; SELECT @a,@b;+------+------+| @a | @b |+------+------+| 3 | 4 |+------+------+","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL---自定义函数","slug":"MySQL-自定义函数","date":"2017-07-11T02:37:41.000Z","updated":"2017-08-26T00:58:44.353Z","comments":true,"path":"2017/07/11/MySQL-自定义函数/","link":"","permalink":"http://yoursite.com/2017/07/11/MySQL-自定义函数/","excerpt":"用户自定义函数（user-defined function,UDF）。UDF可以没有参数,但UDF必须有且只有一个返回值","text":"用户自定义函数（user-defined function,UDF）。UDF可以没有参数,但UDF必须有且只有一个返回值 创建UDF CREATE FUNCTION function_name(parameter_name type,[parameter_name2 type2,...]) RETURNS {STRING|INTEGER|REAL|DECIMAL} BEGIN body END 删除UDFDROP FUNCTION fun_name 删除自定义函数 DELIMITER “字符串”更改结束标识12345678910mysql&gt; DELIMITER &quot;//&quot;mysql&gt; SHOW TABLES //+----------------+| Tables_in_test |+----------------+| provinces || user || user2 || userinfo |+----------------+ 实例1234// 计算两个数的平均值mysql&gt; CREATE FUNCTION f2_2(num1 SMALLINT,num2 SMALLINT) -&gt; RETURNS FLOAT(10,2) -&gt; RETURN (num1+num2)/2; 1234567mysql&gt; CREATE FUNCTION adduser(username VARCHAR(20)) -&gt; RETURNS VARCHAR(20) -&gt; BEGIN -&gt; INSERT INTO user(username) VALUES(username); -&gt; RETURN LAST_INSERT_ID(); -&gt; END -&gt; // 定义局部变量DECLARE var_name [,var_name…] date_type [DEFAULT VALUE]; 为变量赋值语法(全局变量也是如此): SET parameter_name = value[,parameter_name = value…] SELECT INTO parameter_name 12345678910111213141516# 使用default 指定默认值CREATE FUNCTION add(num INT)RETURNS INTBEGIN DECLARE temp INT DEFAULT 10 ; RETURN temp+num;END# 使用select into 为变量赋值CREATE FUNCTION userNum()RETURNS INTBEGIN DECLARE temp INT DEFAULT 10 ; SELECT COUNT(id) FROM user INTO temp; RETURN temp;END #用户变量(可以理解成全局变量) 声名：SET @param_name = value； 使用：SELECT @allParam; 12345678910111213# 声名A=100mysql&gt; SET @A = 100 ;#声名B= 200mysql&gt; SET @B = 200;#声名C=A+Bmysql&gt; SET @C = @A+@B;#输出Cmysql&gt; SELECT @C ;+------+| @C |+------+| 300 |+------+ 判断语句 IFIF condition THEN statement [ELSEIF condition THEN statement][ELSE statement] END IF 12345678CREATE FUNCTION if_test(age INT)RETURNS VARCHAR(20)BEGINIF age&gt;18 THEN RETURN &quot;成年&quot;;ELSEIF age&gt;10 THEN RETURN &quot;未成年&quot;;ELSE RETURN &quot;小学生&quot;;END IF;END 分支语句 CASECASE case_value WHEN when_value THEN statement [WHEN when_value THEN statement] … [ELSE statement_list] END CASE 另一种方式：CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] … [ELSE statement_list] END CASE 123456789101112131415161718192021# 第一种方式CREATE FUNCTION case_test(age INT)RETURNS VARCHAR(20)BEGINCASE ageWHEN 20 THEN RETURN &quot;20#&quot;;WHEN 30 THEN RETURN &quot;30#&quot;;ELSE RETURN &quot;#&quot;;END CASE;END# 第二种方式CREATE FUNCTION case_test2(age INT)RETURNS VARCHAR(20)BEGINCASE WHEN age=20 THEN RETURN &quot;20#&quot;;WHEN age=30 THEN RETURN &quot;30#&quot;;ELSE RETURN &quot;#&quot;;END CASE;END 循环 LOOP[begin_label:] LOOP statement END LOOP [end_label] ; LEAVEleave用于终止loop循环LEAVE label 123456789101112# 累加CREATE FUNCTION loop_test()RETURNS INT BEGIN DECLARE count int DEFAULT 10; adds: LOOP SET count = count+1; IF count &gt; 100 THEN LEAVE adds; END IF; END LOOP adds ; RETURN count;END 关于循环还有许多语句，以后用到再做总结","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL---常见函数","slug":"MySQL-常见函数","date":"2017-07-11T02:36:43.000Z","updated":"2017-08-26T01:00:38.060Z","comments":true,"path":"2017/07/11/MySQL-常见函数/","link":"","permalink":"http://yoursite.com/2017/07/11/MySQL-常见函数/","excerpt":"字符函数 函数名 作用 CONCAT() 字符连接 CANCAT_WS(“分隔符”,”value”,”value”,..) 用指定分隔符进行字符连接 FORMAT() 数字格式化 LOWER() 转换成小写 UPPER() 转换成大写 LEFT() 从左侧开始截取 RIGHT() 从右侧开始截取","text":"字符函数 函数名 作用 CONCAT() 字符连接 CANCAT_WS(“分隔符”,”value”,”value”,..) 用指定分隔符进行字符连接 FORMAT() 数字格式化 LOWER() 转换成小写 UPPER() 转换成大写 LEFT() 从左侧开始截取 RIGHT() 从右侧开始截取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 使用CONCAT拼接字符串mysql&gt; SELECT CONCAT(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;);+---------------------+| CONCAT(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) |+---------------------+| ABC |+---------------------+// CONCAT_WS用指定分隔符拼接字符串mysql&gt; SELECT CONCAT_WS(&quot;-&quot;,&quot;A&quot;,&quot;B&quot;,&apos;C&apos;);+----------------------------+| CONCAT_WS(&quot;-&quot;,&quot;A&quot;,&quot;B&quot;,&apos;C&apos;) |+----------------------------+| A-B-C |+----------------------------+mysql&gt; SELECT CONCAT_WS(&quot;-&quot;,id,username) FROM user ;+----------------------------+| CONCAT_WS(&quot;-&quot;,id,username) |+----------------------------+| 1-TOM || 2-JERRY || 3-ALICE |+----------------------------+// 格式化数字函数mysql&gt; SELECT FORMAT(100.111,2);+-------------------+| FORMAT(100.111,2) |+-------------------+| 100.11 |+-------------------+// 小写mysql&gt; SELECT LOWER(&quot;MYSQL&quot;);+----------------+| LOWER(&quot;MYSQL&quot;) |+----------------+| mysql |+----------------+// 大写mysql&gt; SELECT UPPER(&quot;mysql&quot;);+----------------+| UPPER(&quot;mysql&quot;) |+----------------+| MYSQL |+----------------+// 从左侧截取mysql&gt; SELECT LEFT(&quot;MYSQL&quot;,2);+-----------------+| LEFT(&quot;MYSQL&quot;,2) |+-----------------+| MY |+-----------------+// 从右侧截取mysql&gt; SELECT RIGHT(&quot;MYSQL&quot;,2);+------------------+| RIGHT(&quot;MYSQL&quot;,2) |+------------------+| QL |+------------------+ 函数名 作用 LENGTH() 获取字符串长度 LTRIM() 删除签到空格 RTRIM() 删除后续空格 TRIM() 删除和替换前导和后续空格(完整格式：TRIM([{BOTH / LEADING /TRAILING} [remstr] FROM] str)) SUBSTRING() 字符串截取 [NOT] LIKE 字符串匹配(%任意多个字符，_单个字符) REPLACE() 字符串替换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 获得字符串长度mysql&gt; SELECT LENGTH (&quot;MY SQL&quot;);+-------------------+| LENGTH (&quot;MY SQL&quot;) |+-------------------+| 6 |+-------------------+// 清除左边的空格mysql&gt; SELECT LTRIM(&quot; MYSQL &quot;);+-----------------------+| LTRIM(&quot; MYSQL &quot;) |+-----------------------+| MYSQL |+-----------------------+// 计算清除过后的长度mysql&gt; SELECT LENGTH(LTRIM(&quot; MY SQL &quot;));+-----------------------------+| LENGTH(LTRIM(&quot; MY SQL &quot;)) |+-----------------------------+| 7 |+-----------------------------+// 清除右侧的空格mysql&gt; SELECT LENGTH(RTRIM(&quot; MY SQL &quot;));+-----------------------------+| LENGTH(RTRIM(&quot; MY SQL &quot;)) |+-----------------------------+| 9 |+-----------------------------+// 清除左侧和右侧的空格mysql&gt; SELECT LENGTH(TRIM(&quot; MY SQL &quot;));+----------------------------+| LENGTH(TRIM(&quot; MY SQL &quot;)) |+----------------------------+| 6 |+----------------------------+// trim还可以用来替换指定字符mysql&gt; SELECT TRIM(BOTH &quot;?&quot; FROM &quot;?MY?SQL?&quot;);+--------------------------------+| TRIM(BOTH &quot;?&quot; FROM &quot;?MY?SQL?&quot;) |+--------------------------------+| MY?SQL |+--------------------------------+// 求字串，序号从1开始mysql&gt; SELECT SUBSTRING(&quot;MYSQL&quot;,1,2);+------------------------+| SUBSTRING(&quot;MYSQL&quot;,1,2) |+------------------------+| MY |+------------------------+mysql&gt; SELECT SUBSTRING(&quot;MYSQL&quot;,-3);+-----------------------+| SUBSTRING(&quot;MYSQL&quot;,-3) |+-----------------------+| SQL |+-----------------------+// 模糊查找，% 表示任意多个字符mysql&gt; SELECT * FROM user WHERE username LIKE &quot;%O%&quot;；+----+----------+------+| id | username | pid |+----+----------+------+| 1 | TOM | 1 |+----+----------+------+// \\表示转义字符mysql&gt; SELECT * FROM user WHERE username LIKE &quot;%\\%%&quot;;+----+-----------+------+| id | username | pid |+----+-----------+------+| 4 | TOM%JERRY | 1 |+----+-----------+------+// 使用escape自定义转移字符mysql&gt; SELECT * FROM user WHERE username LIKE &quot;%:%%&quot; ESCAPE &quot;:&quot;;+----+-----------+------+| id | username | pid |+----+-----------+------+| 4 | TOM%JERRY | 1 |+----+-----------+------+ 数值运算符函数 函数名 作用 DIV 整数除法 MOD 取余数 CEIL() 进一取整 FLOOR() 舍一取证 POWER(a,b) 幂运算(a的b次方) ROUND(num[,length]) 四舍五入，指定位数的四舍五入 TRUNCATE() 数字截取（不进行四舍五入） [NOT]BETWEEN…AND… [不]在范围内 [NOT]IN() [不]在列出值范围内 IS [NOT] NULL 判断是否为空 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 进一mysql&gt; SELECT CEIL(3.01);+------------+| CEIL(3.01) |+------------+| 4 |+------------+// 舍一mysql&gt; SELECT FLOOR(3.99);+-------------+| FLOOR(3.99) |+-------------+| 3 |+-------------+// 指定位数的四舍五入mysql&gt; SELECT ROUND(10.1234,3);+------------------+| ROUND(10.1234,3) |+------------------+| 10.123 |+------------------+// 数字的截取mysql&gt; SELECT TRUNCATE(1.23456,2);+---------------------+| TRUNCATE(1.23456,2) |+---------------------+| 1.23 |+---------------------+// between .. and...mysql&gt; SELECT 10 BETWEEN 1 AND 100 ;+----------------------+| 10 BETWEEN 1 AND 100 |+----------------------+| 1 |+----------------------+mysql&gt; SELECT 10 IN(10,20,30);+-----------------+| 10 IN(10,20,30) |+-----------------+| 1 |+-----------------+1 row in set (0.04 sec) 日期和时间函数 函数名 作用 NOW() 当前日期和时间(2017-07-10 11:16:20) CURDATE() 当前日期(2017-07-10) SURTIME() 当前时间(11:16:38 ) DATE_ADD(date,INTERVAL expr type) 日期变化(YEAR/MONTH/WEEK/DAY/HOUR/MINUTE/SECOND) DATEDIFF() 日期差值 DATE_FORMAT(date,format) 日期格式化（%Y=年 %m=月 %d=日 %H=时 %i=分 %s=秒） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 当前时间mysql&gt; SELECT NOW();+---------------------+| NOW() |+---------------------+| 2017-07-10 11:16:20 |+---------------------+// 当前日期mysql&gt; SELECT CURDATE();+------------+| CURDATE() |+------------+| 2017-07-10 |+------------+// 当前时间mysql&gt; SELECT CURTIME();+-----------+| CURTIME() |+-----------+| 11:16:38 |+-----------+// 更改时间mysql&gt; SELECT DATE_ADD(&quot;2017-07-10&quot;,INTERVAL 1 YEAR);+----------------------------------------+| DATE_ADD(&quot;2017-07-10&quot;,INTERVAL 1 YEAR) |+----------------------------------------+| 2018-07-10 |+----------------------------------------+// 计算时间差mysql&gt; SELECT DATEDIFF(&quot;2017-7-10&quot;,&quot;2017-6-10&quot;);+-----------------------------------+| DATEDIFF(&quot;2017-7-10&quot;,&quot;2017-6-10&quot;) |+-----------------------------------+| 30 |+-----------------------------------+// 更改时间格式mysql&gt; SELECT DATE_FORMAT(NOW(),&quot;%Y年 %m月%d日%H时%i分%s秒&quot;);+------------------------------------------------+| DATE_FORMAT(NOW(),&quot;%Y年 %m月%d日%H时%i分%s秒&quot;) |+------------------------------------------------+| 2017年 07月10日11时28分16秒 |+------------------------------------------------+ 信息函数 函数名 作用 CONNECTION_ID() 连接ID DATABASE() 返回当前数据库 LAST_INSERT_ID() 最后插入记录的数据表的ID字段 USER() 当前用户 VERSION() 当前版本信息 12345678910111213141516171819202122232425262728293031323334mysql&gt; SELECT CONNECTION_ID();+-----------------+| CONNECTION_ID() |+-----------------+| 5 |+-----------------+mysql&gt; SELECT DATABASE();+------------+| DATABASE() |+------------+| test |+------------+mysql&gt; SELECT LAST_INSERT_ID();+------------------+| LAST_INSERT_ID() |+------------------+| 5 |+------------------+mysql&gt; SELECT USER();+----------------+| USER() |+----------------+| root@localhost |+----------------+mysql&gt; SELECT VERSION();+------------+| VERSION() |+------------+| 5.7.18-log |+------------+ 聚合函数 函数名 作用 AVG() 平均值 COUNT() 计数 MAX() 求最大值 MIN() 最小值 SUM() 求总和 123456789101112131415161718192021222324252627282930313233343536373839mysql&gt; SELECT MAX(goods_price) AS price FROM tdb_goods;+-----------+| price |+-----------+| 28888.000 |+-----------+1 row in set (0.00 sec)mysql&gt; SELECT MIN(goods_price) AS price FROM tdb_goods;+--------+| price |+--------+| 99.000 |+--------+1 row in set (0.00 sec)mysql&gt; SELECT AVG(goods_price) AS price FROM tdb_goods;+--------------+| price |+--------------+| 5845.1000000 |+--------------+1 row in set (0.00 sec)mysql&gt; SELECT SUM(goods_price) AS price FROM tdb_goods;+------------+| price |+------------+| 116902.000 |+------------+1 row in set (0.00 sec)mysql&gt; SELECT COUNT(goods_id) AS COUNT FROM tdb_goods;+-------+| COUNT |+-------+| 20 |+-------+1 row in set (0.00 sec) 加密函数 函数名 作用 MD5() 信息摘要算法 PASSWORD() 密码算法 12345678910111213mysql&gt; SELECT MD5(&quot;MYSQL &quot;);+----------------------------------+| MD5(&quot;MYSQL &quot;) |+----------------------------------+| 31d72f67ea8d0f7ee426456e83327af2 |+----------------------------------+mysql&gt; SELECT PASSWORD(&quot;MYSQL &quot;);+-------------------------------------------+| PASSWORD(&quot;MYSQL &quot;) |+-------------------------------------------+| *50E5F8E9E5335C3578BF217737DB2DCDEDCB8B98 |+-------------------------------------------+","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"NTR1czU1bTk=","slug":"独白","date":"2017-07-09T14:03:42.000Z","updated":"2017-08-26T00:58:29.357Z","comments":true,"path":"2017/07/09/独白/","link":"","permalink":"http://yoursite.com/2017/07/09/独白/","excerpt":"","text":"NWFXOTVMbUY1cktoNkxlZjVMcTY2SyswNkwrSDZZS2o1THFiNWI2QTVMcUw0NENDNUx1SzVwbWE1WktNNUxpQTVMMk41YVNuNUwyczZJR0s1YVNwNzd5TTVweUo1TGlBNTRLNTU0SzU1b1NmNktlbTQ0Q0M1NDZ3NVp5bzVhUzA2SVNSNXB5SjU0SzU1TG14NDRDQzQ0Q0M1cHlKNTRLNTVMbXg0NENDNDRDQ0NncmxwYjNtc1lua3VJM21qNURsdlpQbHViVGxpNGZqZ0lMbWlKSG5qckRsbktqbm1vVGxyYWJrdWFEbWdJSGx1cWJ2dkl6bHQ3TG51NC9tcjVUa3VZdmxpWTNtbjZYa3VvYmx2b2pscEpyamdJTG5xYmJsaGJibGpwL2xtNkR2dkl6bWlKSG1zcUhtbklub3A0VGxpSkx2dkl6bHNMSG5ycGZtbklua3VvYm9wNFRsaUpMbWlKSGt1Wi9sdm9qcG1yN21pYWZvb1l6amdJTGt1Wi9vcnJqbW1LL29oNnJtanFmbGlwdmt1STNscEovbGtLZmpnSUlLNWFTbjVMcU03N3lNNW9pUjU1cUU1YTJtNUxtZzZZZU41YitENUxpQTU1dTA1YTZlNVp5bzVvcUE1cHl2NUxpSzZaMmk3N3lNNklxeDVMcUc1YjZJNWFTYTVwZTI2WmUwNWEybTVMbWc1b3FBNXB5djc3eU02Sm05NTRTMjVhMm01NXFFNUxtZjVMaU41b0NPNUxtSTVxQzM3N3lNNWErODZJZTA1TGlUNUxpYTZLKys2WU85NXBpdjVMK2Q1b3lCNVp5bzVMaU41b3lDNTZlUjU1cUU1ckMwNWJtejVMaUs3N3lNNWFTbjVMaUE1cGUyNkwrWTVvT3o2TCtINW91LzVhV1c1YTJtNlllUjc3eU01NDZ3NVp5bzU1eUw1cDJsNVlpdzVZT1A1TGlxNTZ5UjZLK2Q0NENDNWEybTVMbWc1b3FBNXB5djc3eU01b2lSNWJDeDVMaUE1cTJsNUxpQTVxMmw2TFd3NVpDUjVMcUc1NkNCNVlhYzU1cUU2SXFDNWFXUDc3eU01TDJHNXBpdjVvaVI1Ym0yNUxpTjVvT3o2TCtaNXFDMzc3eU01b2lSNkwrWTVvT3o1bzZsNktlbTVwdTA1YVNhNUx5WTU2ZUE1NXFFNUxxNjQ0Q0M1b2lSNkwrWTVvT3o1bytRNVkySDZJZXE1YmV4NDRDQzVvaVI2TCtZNW9PejZJQ0Q1NkNVNDRDQzQ0Q0NDdWl2dE9XSXNPaUFnK2VnbE8rOGpPaS9tZVM4dk9TNWp1YXlvZWFjaWVTN2dPUzVpT21BaWVhTHFlZWFoT1M5bWVXY3NPKzhqT2lBZysrOGpPaUFnK1dRcCsrOGpPUzRqZWV1b2VlN2srYWVuT2FBanVTNWlPYWd0Kys4ak9pdmxlaXZsZVdRcCtPQWd1UzRqZWVFdHVXa3ArV3RwdVM0Z09lQ3VlYXpvdWErbk9tRHZlYXlvZWFjaWUrOGpPYWVyK2VIcGVhWG9PV1JzK09BZ2dya3ZZYm1pSkhtbklEbWk0WGx2NFBubW9UdnZJem1tSy9taUpIb2c3M2t1STNvZzczbG5acm1qSUh2dkl6bm5JdmxpTERscEtma3Zhemt1NnpwZzczbG5LamxyYWJrdWFEdnZJem9nSXptaUpIbm1vVG1nSUhsdXFibGpiVG1nTHZtbUsvbWo1RGt1STNrdUlybW5hWHZ2SXptaUpIbWc3UG1pYjdrdUlEa3VLcm9nNzNsdWJib2dxbmxyYWJrdWFEbm1vVGt1cnJqZ0lMbGo2L2t1NlhscGIzbGc0L2x2b2pwbXI3bWliN2pnSUxtaUpIa3VJRGt1S3JrdXJybm1vVG1nN1BtczVYbWdMdm1tSy9sdm9qbHJybm1tSlBvb3F2bGthamxtN1RubW9Ua3VycmxrSXpsakpidnZJem1pSkhubW9Ubm02N21vSWZscGIzbGc0L290b3JtbmFYb3Rvcm92NXpqZ0lMamdJTGpnSUlLNXB5QTZMK1I2SUNCNXBpdjVvT3o2TFczNWFXNTc3eU01cGUyNlplMDViZXk1N3VQNkwrSDVZNjc1THFHNllLajVMbUk1TG1GNzd5TTVZK3Y1cGl2NkwrWTVwaXY1YjZJNlpxKzViMjc1YnFWNllHWDViK1k3N3lNNXErUDViMlQ2SWVxNWJleDZaZXk1TGlMNXAybDc3eU01YkN4NWI2STVhNjU1cGlUNW9PejVZaXc1YVc1NDRDQzVZK3Y2SU85NXBpdjViMlQ1cGUyNWE2ZTVaeW81cGl2NkwrcjVMaU41YjZYNWJleTc3eU01YSs4NkllMDVvaVI1TGlBNTV1MDVwUys1TGlONUxpTDQ0Q0M1WVcyNWE2ZTZLZUo1YjZYNkllcTViZXg2TCtZNXBpdjVhU3E1YVNwNTV5ZjQ0Q0M2TCtaNUxxYjVMaWM2S1cvNTV5ZjU1cUU1cktoNWIrRjZLYUI1NVdaNW9HTDQ0Q0M1clM3NVp5bzVadWU1YitHNUxpdDU1cUU1THE2NVkrcTZJTzk1cTJpNXEybDVMaU41WW1ONDRDQ0Nncm1uSURvdjVIb2lySGt1b2Jsdm9qbHBKcm1sN2JwbDdUa3VvYm9wNlBsam9ibGo3THZ2SXptbUk3bW5KM2pnSUhtc1lubW5KM2pnSUhscm92bW5KM2pnSUhwbW92bGxKRGpnSUxrdUkzbW1LL210N0hsaGFYa3VvYm9wNlB2dkl6bGo2cm1tSy9rdW9ib3A2UGpnSUxrdW9ib3A2UGt1SURrdXB2bGpvYmxqN0xsa0k3bWlZM21oSi9vcDRubGlMRHZ2SXprdUszbGpZN2t1SXJrdUl2a3VwVGxqWVBsdWJUbm1vVG1sb2ZtbUk3bm5KL25tb1RtbUsvbHZvamxnTHpsdnBmb2g2cm9zYXJqZ0lMbGpZN2xwSS9tc0pIbWw0L2xuS2psajZUa3U2UG5tb1RudTQvbXRZN21sb2ZsakpibnJZbmx2b2pscEpybWxybnBuYUxwZzczbW1LL3Bvb2JsaFlqa3VvN29wYi9tbHJubm1vVGpnSUxsajZybW1LL21sN2JrdTZQbW03VG1tNy9qZ0lMbGhiVG9vYkRrdXFUbW03L2pnSUxtdUlYbW5KM25tb1RvcG9ibmdhM21pSkhrdTZ6a3ZwM25oTGJvcnJEbHY0YmxzS1RtbHJEamdJTGxoYkhrdXFmbGhacm5tb1RsdUtibW5hWG5tb1RudVlIb2phUG5vYTdscnA3bHZvamxnTHpsdnBmb2g2cm9zYXJqZ0lMa3ZZYm1tSy9sbktqa3VLM2xqWTdrdXBUbGpZUGx1YlRubW9UbGpvYmxqN0xrdUlydnZJem92NW5ucDQzbnVZSG9qYVBubW9UbWw3Ymt1NlBsdWJia3VJM21tSy9uckt6a3VJRG1yS0hqZ0lMbHU3cmxtNzNsaUozbW5KL25tb1RudVlIb2phUGx1YmJrdUkzb2c3M2t1NlBvb2FqbGlMYmx1cWJubW9Ua3ZKam90b3JtZ0tmamdJTGxqNnJvZzczb29ham5wTHJsdlpQa3VJdmpnSUxscG9MbW5wdzFNRERsdWJUbGtJN2xoYkhrdXFmbGhacm92NWpvZzczbHNibm5xNHZrdW83a3VKYm5sWXpvZ0l6a3VJM2xnSkxqZ0lMcGdxUG1pSkhsc0xIb3JxVGt1THJvdjVubW1LL2xpTGJsdXFibnU1bm1pSkhrdTZ6bHVLYm1uYVhubW9UbnBvL3BuN1BqZ0lMb2dJemt1SlR2dkl6bWlKSG5qckRsbktqb3Rvcm1uYVhvdG9ybGxwem1yS0xrdUlEa3VwdmxqNlRrdTZQbm1vVG1sb2ZscmFia3ZaemxrNEhqZ0lMbm5KL25tb1RtbUsvbHZvam5zcjduZ3J6dnZJem5uNjNubjYzbm1vVGxoNkRrdUtybHJaZmxzTEhvZzczbHNJYm1pWURtbklubm1vVG1nNFhtaEovbG00cm1pNnpsaGJia3VLM2pnSUxsZ0x6bHZwZm9oNnJvc2FydnZJSGt1STNvdjRmbm1vVG1pSkhubW9Ub3I2M21sb2ZtbUsvbG5Lamx2b2psdDY3dnZJem9wb0htbUsvbWlKSG1sNm5uZ3JubWhJL29yNGJsaUxEb3Y1bmt1SURuZ3JudnZJemxqNi9vZzczbHNMSGt1STNrdkpybW5Jbmt1NHJscEtuamdJTGpnSUxqZ0lMamdJSUtDZ3JrdTRybW1acmxrb3pscEtma3Zhem9nWXJrdW9ibHZvamt1WVh2dkl6bWlKSGx2b2prdmFubW5JM2xwS2ZrdmF6bWxhTGt1bzdvdjczbXNZTG5tb1Ruc3I3bnBaN3Z2SXpvaDZybHQ3SGxscHptcktMbm1vVGxzTEhsaTRmbWxhTG5tb1RsanJ2b3Y3M21zWUx2dkl6bGdMemx2cGZtaUpIbHJhYmt1YURsbFlyamdJTGxqNmJscEpidnZJem1uSW5uZ3JubHNJL2xzSS9ubW9UbHBMSG9rTDNqZ0lMbG02RGt1THJqZ0lMamdJTGpnSUxqZ0lMamdJTGpnSUxqZ0lMamdJTGpnSUxqZ0lMamdJSUtDdWFjZ09XUWp1T0FndWlBZytlZ2xPKzhnUW9LNVlXbzU0bUg1cFdqNW9tdjc3eU02SWVxNW9pUjU0dXM1NW05NDRDQ0Nnbz0=","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"MySQL---子查询、表的连接","slug":"MySQL-子查询、表的连接","date":"2017-07-08T03:32:37.000Z","updated":"2017-08-26T01:10:08.023Z","comments":true,"path":"2017/07/08/MySQL-子查询、表的连接/","link":"","permalink":"http://yoursite.com/2017/07/08/MySQL-子查询、表的连接/","excerpt":"子查询常用的比较运算符： =、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt; 修饰运算符","text":"子查询常用的比较运算符： =、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt; 修饰运算符 运算符 关键字 关键字 关键字 &nbsp; ANY SOME ALL &gt;、&gt;= 最小值 最小值 最大值 &lt;、&lt;= 最大值 最大值 最小值 = 任意值 任意值 &nbsp; &lt;&gt;、!= &nbsp; &nbsp; 任意值 1234// 查找所有价格大于平均值的行mysql&gt; SELECT goods_id,goods_name,goods_price FROM tdb_goods -&gt; WHERE goods_price &gt; (SELECT ROUND(AVG(goods_price)) FROM tdb_goods) -&gt; ORDER BY goods_price; 运算符=ANY 和 =SOME 相当于 IN123456789=ANY =SOME --INmysql&gt; SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price = ANY (SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;);+----------+---------------------------------+-------------+| goods_id | goods_name | goods_price |+----------+---------------------------------+-------------+| 5 | X240(20ALA0EYCD) 12.5英寸超极本 | 4999.000 || 6 | U330P 13.3英寸超极本 | 4299.000 || 7 | SVP13226SCB 13.3英寸触控超极本 | 7999.000 |+----------+---------------------------------+-------------+ &gt; ANY 表示大于最小值12345678910111213141516// &gt; ANY mysql&gt; SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; ANY (SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;);+----------+----------------------------------+-------------+| goods_id | goods_name | goods_price |+----------+----------------------------------+-------------+| 2 | Y400N 14.0英寸笔记本电脑 | 4899.000 || 3 | G150TH 15.6英寸游戏本 | 8499.000 || 5 | X240(20ALA0EYCD) 12.5英寸超极本 | 4999.000 || 7 | SVP13226SCB 13.3英寸触控超极本 | 7999.000 || 13 | iMac ME086CH/A 21.5英寸一体电脑 | 9188.000 || 16 | PowerEdge T110 II服务器 | 5388.000 || 17 | Mac Pro MD878CH/A 专业级台式电脑 | 28888.000 || 18 | HMZ-T3W 头戴显示设备 | 6999.000 || 20 | X3250 M4机架式服务器 2583i14 | 6888.000 || 21 | HMZ-T3W 头戴显示设备 | 6999.000 |+----------+----------------------------------+-------------+ &gt; ALL表示大于最大值123456789// &gt; ALL mysql&gt; SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; ALL (SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;);+----------+----------------------------------+-------------+| goods_id | goods_name | goods_price |+----------+----------------------------------+-------------+| 3 | G150TH 15.6英寸游戏本 | 8499.000 || 13 | iMac ME086CH/A 21.5英寸一体电脑 | 9188.000 || 17 | Mac Pro MD878CH/A 专业级台式电脑 | 28888.000 |+----------+----------------------------------+-------------+ IN 和NOT INNOT IN等效于！=ALL 或 &lt;&gt;ALL1234567891011121314151617181920212223242526// NOT IN 与 ！= ALL等效 ，以下查询不是超极本的电脑，两次查询的结果相同mysql&gt; SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price NOT IN (SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;);mysql&gt; SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price != ALL (SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;);+----------+------------------------------------------------------------------------+-------------+| goods_id | goods_name | goods_price |+----------+------------------------------------------------------------------------+-------------+| 1 | R510VC 15.6英寸笔记本 | 3399.000 || 2 | Y400N 14.0英寸笔记本电脑 | 4899.000 || 3 | G150TH 15.6英寸游戏本 | 8499.000 || 4 | X550CC 15.6英寸笔记本 | 2799.000 || 8 | iPad mini MD531CH/A 7.9英寸平板电脑 | 1998.000 || 9 | iPad Air MD788CH/A 9.7英寸平板电脑 （16G WiFi版） | 3388.000 || 10 | iPad mini ME279CH/A 配备 Retina 显示屏 7.9英寸平板电脑 （16G WiFi版） | 2788.000 || 11 | IdeaCentre C340 20英寸一体电脑 | 3499.000 || 12 | Vostro 3800-R1206 台式电脑 | 2899.000 || 13 | iMac ME086CH/A 21.5英寸一体电脑 | 9188.000 || 14 | AT7-7414LP 台式电脑 （i5-3450四核 4G 500G 2G独显 DVD 键鼠 Linux ） | 3699.000 || 15 | Z220SFF F4F06PA工作站 | 4288.000 || 16 | PowerEdge T110 II服务器 | 5388.000 || 17 | Mac Pro MD878CH/A 专业级台式电脑 | 28888.000 || 18 | HMZ-T3W 头戴显示设备 | 6999.000 || 19 | 商务双肩背包 | 99.000 || 20 | X3250 M4机架式服务器 2583i14 | 6888.000 || 21 | HMZ-T3W 头戴显示设备 | 6999.000 || 22 | 商务双肩背包 | 99.000 |+----------+------------------------------------------------------------------------+-------------+ EXISTS如果子查询返回任何行，EXISTS将返回TRUE ，否则返回FALSE1select * from t1 where exists (select * from t1 where id = 2); INSERT INTO tbl_name [(col_name,…)] SELECT …使用查询插入数据表 创建分类表，用以上语句更新分类表1mysql&gt; INSERT INTO tdb_goods_cate (cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate; 多表更新UPDATE tbl_name1 [LEFT|RIGHT]JOIN tbl_name2 ON condition SET name=value… WHERE condition.. 1234// 按照分类表，将商品表中的数据更新mysql&gt; UPDATE tdb_goods INNER JOIN tdb_goods_cate ON tdb_goods.goods_cate=tdb_goods_cate.cate_name SET tdb_goods.goods_cate = tdb_goods_cate.id; 创建表的同时插入数据CREATE TABLE [IF NOT EXISTS] tbl_name [(create_defition,…)] select_statement… 123456// 创建表的同时插入表信息mysql&gt; CREATE TABLE tdb_goods_brand( -&gt; id INT(5) UNSIGNED PRIMARY KEY AUTO_INCREMENT, -&gt; brand_name VARCHAR(40) -&gt; ) -&gt; SELECT brand_name FROM tdb_goods GROUP BY brand_name; 连接类型 INNER JOIN ： 内链接。 显示左表和右表都存在的记录（显示交集） LEFT [OUTER] JOIN ： 左外连接 ，显示左表的所有记录和右表中满足条件的记录 RIGHT [OUUTER] JOIN ： 右外连接，显示右表的所有记录和左表中满足条件的记录 在MySQL中，JOIN,CROSS JOIN 和INNER JOIN 是等价的 用ON 关键字类设定连接条件，也可以使用WHERE来代替。通常使用ON关键字类设定连接条件。使用WHERE关键字今昔你个结果集记录的过滤 多表连接mysql&gt; SELECT goods_id,goods_name,cate_name,brand_name,goods_price,is_show ,is_saleoff -&gt; FROM tdb_goods g -&gt; JOIN tdb_goods_cate c on c.id = g.goods_cate_id -&gt; JOIN tdb_goods_brand b on b.id = g.brand_id;123456789101112131415161718192021222324252627282930313233343536373839// 多表查询mysql&gt; SELECT goods_id,goods_name,cate_name,brand_name,goods_price,is_show ,is_saleoff FROM tdb_goods INNER JOIN tdb_goods_cate ON tdb_goods.goods_cate_id = tdb_goods_cate.id INNER JOIN tdb_goods_brand ON tdb_goods.brand_id = tdb_goods_brand.id;// 使用AS未每个表重命名mysql&gt; SELECT goods_id,goods_name,cate_name,brand_name,goods_price,is_show ,is_saleoff -&gt; FROM tdb_goods g -&gt; JOIN tdb_goods_cate c on c.id = g.goods_cate_id -&gt; JOIN tdb_goods_brand b on b.id = g.brand_id;// 结果相同+----------+------------------------------------------------------------------------+---------------+------------+-------------+---------+------------+| goods_id | goods_name | cate_name | brand_name | goods_price | is_show | is_saleoff |+----------+------------------------------------------------------------------------+---------------+------------+-------------+---------+------------+| 1 | R510VC 15.6英寸笔记本 | 笔记本 | 华硕 | 3399.000 | 1 | 0 || 2 | Y400N 14.0英寸笔记本电脑 | 笔记本 | 联想 | 4899.000 | 1 | 0 || 3 | G150TH 15.6英寸游戏本 | 游戏本 | 雷神 | 8499.000 | 1 | 0 || 4 | X550CC 15.6英寸笔记本 | 笔记本 | 华硕 | 2799.000 | 1 | 0 || 5 | X240(20ALA0EYCD) 12.5英寸超极本 | 超级本 | 联想 | 4999.000 | 1 | 0 || 6 | U330P 13.3英寸超极本 | 超级本 | 联想 | 4299.000 | 1 | 0 || 7 | SVP13226SCB 13.3英寸触控超极本 | 超级本 | 索尼 | 7999.000 | 1 | 0 || 8 | iPad mini MD531CH/A 7.9英寸平板电脑 | 平板电脑 | 苹果 | 1998.000 | 1 | 0 || 9 | iPad Air MD788CH/A 9.7英寸平板电脑 （16G WiFi版） | 平板电脑 | 苹果 | 3388.000 | 1 | 0 || 10 | iPad mini ME279CH/A 配备 Retina 显示屏 7.9英寸平板电脑 （16G WiFi版） | 平板电脑 | 苹果 | 2788.000 | 1 | 0 || 11 | IdeaCentre C340 20英寸一体电脑 | 台式机 | 联想 | 3499.000 | 1 | 0 || 12 | Vostro 3800-R1206 台式电脑 | 台式机 | 戴尔 | 2899.000 | 1 | 0 || 13 | iMac ME086CH/A 21.5英寸一体电脑 | 台式机 | 苹果 | 9188.000 | 1 | 0 || 14 | AT7-7414LP 台式电脑 （i5-3450四核 4G 500G 2G独显 DVD 键鼠 Linux ） | 台式机 | 宏碁 | 3699.000 | 1 | 0 || 15 | Z220SFF F4F06PA工作站 | 服务器/工作站 | 惠普 | 4288.000 | 1 | 0 || 16 | PowerEdge T110 II服务器 | 服务器/工作站 | 戴尔 | 5388.000 | 1 | 0 || 17 | Mac Pro MD878CH/A 专业级台式电脑 | 服务器/工作站 | 苹果 | 28888.000 | 1 | 0 || 18 | HMZ-T3W 头戴显示设备 | 笔记本配件 | 索尼 | 6999.000 | 1 | 0 || 19 | 商务双肩背包 | 笔记本配件 | 索尼 | 99.000 | 1 | 0 || 20 | X3250 M4机架式服务器 2583i14 | 服务器/工作站 | IBM | 6888.000 | 1 | 0 || 21 | HMZ-T3W 头戴显示设备 | 笔记本配件 | 索尼 | 6999.000 | 1 | 0 || 22 | 商务双肩背包 | 笔记本配件 | 索尼 | 99.000 | 1 | 0 |+----------+------------------------------------------------------------------------+---------------+------------+-------------+---------+------------+ 无限分组：1234567891011121314151617181920212223// 使用左连接查询每个子类的父类mysql&gt; SELECT s.type_id AS son_id, s.type_name AS son_name,p.type_name AS parent_name -&gt; FROM tdb_goods_types AS s LEFT JOIN tdb_goods_types AS p -&gt; ON s.parent_id = p.type_id;+--------+------------+-------------+| son_id | son_name | parent_name |+--------+------------+-------------+| 1 | 家用电器 | NULL || 2 | 电脑、办公 | NULL || 3 | 大家电 | 家用电器 || 4 | 生活电器 | 家用电器 || 5 | 平板电视 | 大家电 || 6 | 空调 | 大家电 || 7 | 电风扇 | 生活电器 || 8 | 饮水机 | 生活电器 || 9 | 电脑整机 | 电脑、办公 || 10 | 电脑配件 | 电脑、办公 || 11 | 笔记本 | 电脑整机 || 12 | 超级本 | 电脑整机 || 13 | 游戏本 | 电脑整机 || 14 | CPU | 电脑配件 || 15 | 主机 | 电脑配件 |+--------+------------+-------------+ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556使用左查询查询所有父类的子类mysql&gt; SELECT p.type_id parent_id, p.type_name parent_name, s.type_name son_name -&gt; FROM tdb_goods_types AS p LEFT JOIN tdb_goods_types AS s -&gt; ON p.type_id = s.parent_id -&gt; ORDER BY parent_id;+-----------+-------------+----------+| parent_id | parent_name | son_name |+-----------+-------------+----------+| 1 | 家用电器 | 大家电 || 1 | 家用电器 | 生活电器 || 2 | 电脑、办公 | 电脑整机 || 2 | 电脑、办公 | 电脑配件 || 3 | 大家电 | 平板电视 || 3 | 大家电 | 空调 || 4 | 生活电器 | 电风扇 || 4 | 生活电器 | 饮水机 || 5 | 平板电视 | NULL || 6 | 空调 | NULL || 7 | 电风扇 | NULL || 8 | 饮水机 | NULL || 9 | 电脑整机 | 笔记本 || 9 | 电脑整机 | 游戏本 || 9 | 电脑整机 | 超级本 || 10 | 电脑配件 | 主机 || 10 | 电脑配件 | CPU || 11 | 笔记本 | NULL || 12 | 超级本 | NULL || 13 | 游戏本 | NULL || 14 | CPU | NULL || 15 | 主机 | NULL |+-----------+-------------+----------+// 查看父类的子类个数mysql&gt; SELECT p.type_id AS parent_id, p.type_name AS parent_name, count(p.parent_id) AS son_count -&gt; FROM tdb_goods_types AS p LEFT JOIN tdb_goods_types AS s -&gt; ON p.type_id = s.parent_id -&gt; GROUP BY parent_name ORDER BY parent_id;+-----------+-------------+-----------+| parent_id | parent_name | son_count |+-----------+-------------+-----------+| 1 | 家用电器 | 2 || 2 | 电脑、办公 | 2 || 3 | 大家电 | 2 || 4 | 生活电器 | 2 || 5 | 平板电视 | 1 || 6 | 空调 | 1 || 7 | 电风扇 | 1 || 8 | 饮水机 | 1 || 9 | 电脑整机 | 3 || 10 | 电脑配件 | 2 || 11 | 笔记本 | 1 || 12 | 超级本 | 1 || 13 | 游戏本 | 1 || 14 | CPU | 1 || 15 | 主机 | 1 |+-----------+-------------+-----------+ 多表删除DELETE tbl_name1,tbl_name2.. FROM table_references WHERE condidtions 同时删除多个表的记录1DELETE t1,t2 FROM t1,t2 WHERE t1.name = t2.name; 使用多表删除删除表中的重复数据123456789101112131415161718192021222324252627// 先用group by删选出名称相同的数量大于2的分组，筛选出的分组既是需要删除的记录SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;= 2+----------+-----------------------+| goods_id | goods_name |+----------+-----------------------+| 18 | HMZ-T3W 头戴显示设备 || 19 | 商务双肩背包 |+----------+-----------------------+// 将上表与原表内连接，mysql&gt; SELECT * FROM tdb_goods AS t1 -&gt; INNER JOIN (SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;= 2) AS t2 -&gt; ON t1.goods_name = t2.goods_name ;+----------+-----------------------+---------------+----------+-------------+---------+------------+----------+-----------------------+| goods_id | goods_name | goods_cate_id | brand_id | goods_price | is_show | is_saleoff | goods_id | goods_name |+----------+-----------------------+---------------+----------+-------------+---------+------------+----------+-----------------------+| 18 | HMZ-T3W 头戴显示设备 | 37 | 6 | 6999.000 | 1 | 0 | 18 | HMZ-T3W 头戴显示设备 || 19 | 商务双肩背包 | 37 | 6 | 99.000 | 1 | 0 | 19 | 商务双肩背包 || 21 | HMZ-T3W 头戴显示设备 | 37 | 6 | 6999.000 | 1 | 0 | 18 | HMZ-T3W 头戴显示设备 || 22 | 商务双肩背包 | 37 | 6 | 99.000 | 1 | 0 | 19 | 商务双肩背包 |+----------+-----------------------+---------------+----------+-------------+---------+------------+----------+-----------------------+// 最后删除重复的记录DELETE t1 FROM tdb_goods AS t1 INNER JOIN (SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;= 2) AS t2 ON t1.goods_name = t2.goods_name WHERE t1.goods_id &gt; t2.goods_id;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL---操作数据表基本操作（增删改查）","slug":"MySQL-操作数据表基本操作（增删改查）","date":"2017-07-04T13:39:30.000Z","updated":"2017-08-26T01:10:42.752Z","comments":true,"path":"2017/07/04/MySQL-操作数据表基本操作（增删改查）/","link":"","permalink":"http://yoursite.com/2017/07/04/MySQL-操作数据表基本操作（增删改查）/","excerpt":"插入记录INSERT [INTO] tbl_name [{col_name,…}] {VALUES|VALUE} (values…),(values…)","text":"插入记录INSERT [INTO] tbl_name [{col_name,…}] {VALUES|VALUE} (values…),(values…) 不加列名表示需要插入全部数据 对于自增主键，可以用NULL 和 DEFAULT 使之自己增加 12345mysql&gt; INSERT INTO users VALUES(NULL,&apos;TOM&apos;,&apos;123&apos;,20,1);Query OK, 1 row affected (0.08 sec)mysql&gt; INSERT INTO users VALUES(DEFAULT,&apos;TOM&apos;,&apos;123&apos;,20,1);Query OK, 1 row affected (0.08 sec) 可以写数字运算、函数 12345mysql&gt; INSERT INTO users VALUES(DEFAULT,&apos;TOM&apos;,&apos;123&apos;,10*2-1,1);Query OK, 1 row affected (0.08 sec)// 使用自带的md5()计算md5mysql&gt; INSERT INTO users VALUES(DEFAULT,&apos;TOM&apos;,md5(&apos;123&apos;),10*2-1,1); 有默认值的列，使用DEFAULT表示使用默认值 12mysql&gt; INSERT INTO users VALUES(DEFAULT,&apos;TOM&apos;,&apos;123&apos;,DEFAULT,1);Query OK, 1 row affected (0.08 sec) 插入多条记录 123mysql&gt; INSERT INTO users VALUES(DEFAULT,&apos;TOM&apos;,&apos;123&apos;,DEFAULT,1),(NULL,&apos;JERRY&apos;,&apos;456&apos;,DEFAULT,0);Query OK, 2 rows affected (0.08 sec)Records: 2 Duplicates: 0 Warnings: 0 INSERT [INTO] tbl_name SET col_name=value，…此方法可以使用子查询1INSERT INTO users SET username=&apos;TIM&apos; , password=&apos;789&apos; ,sex=1; INSERT [INTO] tbl_name [(col_name,…)] SELECT …经查询结果插入到指定数据表中12将查询到的数据的前5条插入到test表中。mysql&gt; INSERT INTO test (id,subject) SELECT studentNo, subjectNo FROM result LIMIT 5; 更新记录UPDATE table_name SET col_name1=value1 [,col_name2=value2…] [WHERE condition] 12345678// 更改username为TOM的行mysql&gt; UPDATE userinfo SET username=&apos;AAA&apos; WHERE username=&apos;TOM&apos;;// 在更改信息时使用表达式mysql&gt; UPDATE userinfo SET id = id+10;// 使用 % 运算符判断奇偶mysql&gt; UPDATE userinfo SET email=&apos;ABC&apos; WHERE id%2=0; 删除记录DELETE FROM tbl_name [WHERE condition]12// 删除一条记录mysql&gt; DELETE FROM username WHERE username=&apos;AAA&apos;; 查找记录SELECT value1 [,value2…][ from table_name [WHERE condition] [GROUP BY {col_name|position} [ASC|DESC],…] [HAVING where_condition] [ORDER BY {col_name | expr |position}[ASC|DESC],…] [LIMIT {[offset,]row_count |row_count OFFSET offset}]] 每个表达式表示一列，至少有一个 多个列之间用逗号分隔 星号表示所有列，tbl_name.* 可以表示表的所有列 查询表达式可以使用[AS] alias_name 为其服务赋予别名。AS 可以省略不写 别名用于GROUP BY ORDER BY和HAVING子句 1234567891011121314151617181920// 多个表达式之间用逗号隔开mysql&gt; SELECT id,username FROM userinfo;// table_name.colname 表示特定表中的列mysql&gt; SELECT userinfo.id ,userinfo.username,userinfo.email FROM userinfo ;// table_name.* 表示特定表中的所有行，单表查询时，table_name.* 与 * 效果相同mysql&gt; SELECT userinfo.* FROM userinfo ;// 用 AS 给变量取别名mysql&gt; SELECT id AS userid FROM userinfo ;+--------+| userid |+--------+| 12 || 13 |+--------+// AS 可以省略mysql&gt; SELECT id userid FROM userinfo ; 分组GROUP BY {col_name|position} [ASC|DESC],…用GROUP BY分组后，结果的每一列从1开始递增编号。分组时可以用数字代替列名12345678// 按性别分组，student为各组的第一位的信息。mysql&gt; SELECT studentName, count(studentNo) AS number FROM student GROUP BY sex;+-------------+--------+| studentName | number |+-------------+--------+| 张萍 | 7 || newName | 6 |+-------------+--------+ 筛选分组(HAVING)HAVING condition在分组完成后，筛选满足条件的组。 1234567891011121314151617// 按照gradeId分组mysql&gt; SELECT studentName,count(studentNo) AS number FROM student GROUP BY gradeId ;+-------------+--------+| studentName | number |+-------------+--------+| newName | 9 || 王宝宝 | 2 || 陈志强 | 2 |+-------------+--------+// 从分组中筛选number大于3的分组mysql&gt; SELECT studentName,count(studentNo) AS number FROM student GROUP BY gradeId HAVING number&gt;=3;+-------------+--------+| studentName | number |+-------------+--------+| newName | 9 |+-------------+--------+ 用数字代替列名,GROUP BY 2 结果中的第二个参数 GROUP BY examDate12345678910111213141516// 2 表示第二个参数，即examDatemysql&gt; SELECT studentNo,examDate,count(studentNo) AS count FROM result GROUP BY examDate HAVING count&gt;2;+-----------+---------------------+-------+| studentNo | examDate | count |+-----------+---------------------+-------+| 10000 | 2016-02-17 00:00:00 | 8 |+-----------+---------------------+-------+// 效果与下列相同mysql&gt; SELECT studentNo,examDate,count(studentNo) AS count FROM result GROUP BY 2 HAVING count&gt;2;+-----------+---------------------+-------+| studentNo | examDate | count |+-----------+---------------------+-------+| 10000 | 2016-02-17 00:00:00 | 8 |+-----------+---------------------+-------+1 row in set (0.00 sec) 排序(ORDER)ORDER BY col_name [ASC|DESC]将查询结构按照升序（ASC）或者降序（DESC）排列 12345678910111213141516171819// 降序排列查询到的结果mysql&gt; SELECT studentNo ,studentName FROM student ORDER BY studentNo DESC;+-----------+-------------+| studentNo | studentName |+-----------+-------------+| 30012 | 李露露 || 30011 | 陈志强 || 20010 | 何小华 || 20000 | 王宝宝 || 10008 | 何睛睛 || 10007 | 秦洋 || 10006 | 肖梅 || 10005 | 张秋丽 || 10004 | 韩秋洁 || 10003 | 张萍 || 10002 | 李斯文 || 10001 | 李文才 || 10000 | newName |+-----------+-------------+ 限制查询返回的数量(LIMIT)LIMIT length (start,length) 返回的数据，序号从0开始。 length 表示返回前length条记录，（start，length）表示返回从序号为start开始的length条数据 12345678910111213141516171819// 选择前三条数据mysql&gt; SELECT studentNo, studentName FROM student LIMIT 3;+-----------+-------------+| studentNo | studentName |+-----------+-------------+| 10000 | newName || 10001 | 李文才 || 10002 | 李斯文 |+-----------+-------------+// 选择从序号为2开始的3条数据mysql&gt; SELECT studentNo, studentName FROM student LIMIT 2,3;+-----------+-------------+| studentNo | studentName |+-----------+-------------+| 10002 | 李斯文 || 10003 | 张萍 || 10004 | 韩秋洁 |+-----------+-------------+","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL---外键、添加删除约束、ON DELETE参照、添加|删除|修改数据表列定义","slug":"MySQL-外键、添加删除约束、ON-DELETE参照、添加-删除-修改数据表列定义","date":"2017-07-03T12:06:03.000Z","updated":"2017-08-26T01:10:31.960Z","comments":true,"path":"2017/07/03/MySQL-外键、添加删除约束、ON-DELETE参照、添加-删除-修改数据表列定义/","link":"","permalink":"http://yoursite.com/2017/07/03/MySQL-外键、添加删除约束、ON-DELETE参照、添加-删除-修改数据表列定义/","excerpt":"外键(FOREIGN KEY)外键约束需要满足一些基本要求：","text":"外键(FOREIGN KEY)外键约束需要满足一些基本要求： 父表和子表必须是相同的引擎，而且禁止使用临时表 数据表的存储引擎只能是InnoDB 外键列和参照列必须具有相似的数据烈性。其中数字的长度或是否有符号为必须相同。而字符串的长度可以不同。 外键列和参照列必须创建索引。如果外键列不存在索引的话，MaSQL将自动创建索引。 显示索引，test表由于同时有主键和外键，所以有两个索引123456789101112131415161718192021222324252627282930mysql&gt; SHOW INDEX FROM user \\G;*************************** 1. row *************************** Table: user Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment:*************************** 2. row *************************** Table: user Non_unique: 1 Key_name: pid Seq_in_index: 1 Column_name: pid Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: YES Index_type: BTREE Comment:Index_comment:2 rows in set (0.00 sec) ON DELETE 参照操作 CASCADE 从父表删除或更新，自动删除或更新字表中匹配的行 SET NULL 从父表删除或更新行，并设置字表中的外键列为NULL。如果使用该选项必须保障字表列没有指定NOT NULL RESTRICT 拒绝对父表的删除或更新曹祖 NO ACTION 标准的SQL关键字，在MySQL中与RESTRICT相同 123456mysql&gt; CREATE TABLE user2 ( -&gt; id SMALLINT UNSIGNED PRIMARY KEY , -&gt; name VARCHAR(20) NOT NULL , -&gt; pid SMALLINT UNSIGNED, -&gt; FOREIGN KEY (pid) REFERENCES provinces (id) ON DELETE CASCADE -&gt; ); 表级约束与列级约束 对一个数据列建立的约束，成为列级约束 对多个数据列建立的约束，成为标记约束。 劣迹约束既可以在列定义时声名，也可以在列定义后声名 表级约束只能在列定义后声名 常见的DEFAULT 和 NOT NULL是列级约束 修改表约束添加主键约束ALTER TABLE tbl_name ADD [CONSTRAINT [constraint_name]] PRIMARY KEY [index_type] (index_col_name,…)1ALTER TABLE test ADD CONSTRAINT pk_test PRIMARY KEY (id); 添加唯一约束ALTER TABLE tbl_name ADD [CONSTRAINT [constraint_col_name]] UNIQUE [INDEX|KEY] [index_name][index_type](index_col_name,…)1ALTER TABLE test ADD CONSTRAINT unique_test UNIQUE KEY(name) ; 添加外键约束ALTER TABLE tbl_name ADD [CONSTRAINT [constraint_name]] FOREIGN KEY [index_name](index_col_name,…) REFERENCES table_name(col_name)1mysql&gt; ALTER TABLE test0 ADD CONSTRAINT fk_test0 FOREIGN KEY (data) REFERENCES test(id); 添加、删除默认约束ALTER TABLE tbl_name ALTER [COLUMN] col_name {SET DEFAULT value|DROP DEFAULT}1234// 添加默认约束mysql&gt; ALTER TABLE test ALTER COLUMN name SET DEFAULT &apos;TOM&apos;;// 删除默认约束mysql&gt; ALTER TABLE test ALTER COLUMN name DROP DEFAULT; 删除主键约束ALTER TABLE tbl_name DROP PRIMARY KEY 删除主键时，如果主键有AUTO_INCREMENT约束，就不可以删除该主键约束，必须要先删除AUTO_INCREMENT，才可以删除主键约束。因为数据库将具有AUTO_INCREMENT约束的列看成主键 删除唯一约束ALTER TABLE tbl_name DROP {INDEX|KEY} index_name1234567891011// 先查看唯一约束的名字mysql&gt; SHOW CREATE TABLE test ;| test | CREATE TABLE `test` ( `id` int(50) NOT NULL, `name` varchar(10), PRIMARY KEY (`id`), UNIQUE KEY `unique_test` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=gbk |// 根据唯一约束的名字删除对应的约束mysql&gt; ALTER TABLE test DROP INDEX unique_test; 删除外键约束ALTER TABLE tbl_name DROP FOREIGN KEY fk_name1mysql&gt; ALTER TABLE test0 DROP FOREIGN KEY fk_test0; 查看索引SHOW INDEX FROM tbl_name 12345678mysql&gt; SHOW INDEX FROM test0 ;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| test0 | 0 | PRIMARY | 1 | id | A | 0 | NULL | NULL | | BTREE | | || test0 | 1 | fk_test0 | 1 | data | A | 0 | NULL | NULL | YES | BTREE | | |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+2 rows in set (0.00 sec) \\G 将查询结果按列输出1234567891011mysql&gt; CREATE TABLE provinces( -&gt; id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, -&gt; pname VARCHAR(20) NOT NULL -&gt; );mysql&gt; CREATE TABLE user ( -&gt; id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, -&gt; username VARCHAR(20) NOT NULL , -&gt; pid SMALLINT UNSIGNED, -&gt; FOREIGN KEY (pid) REFERENCES provinces (id) -&gt; ); 查看表信息SHOW CREATE TABLE tbl_name1234567mysql&gt; show create table test0 ;| test0 | CREATE TABLE `test0` ( `id` int(50) NOT NULL, `data` int(50) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_test0` (`data`)) ENGINE=InnoDB DEFAULT CHARSET=gbk | 修改数据表添加、删除列添加列ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [(FIRST) | (AFTER col_name)] 12345678// 插入一条记录ALTER TABLE tb4 ADD COLUMN age INT(10) UNSIGNED DEFAULT 10 ;// 在最前面插入一条记录ALTER TABLE tb4 ADD COLUMN truename VARCHAR(20) NOT NULL FIRST;// 在sex列后面插入一条记录mysql&gt; ALTER TABLE tb4 ADD COLUMN password VARCHAR(20) AFTER sex ; 添加多列ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition (,ADD [column] col_name2 column_definetion…)12// 添加school、和grade列mysql&gt; ALTER TABLE test ADD COLUMN school VARCHAR(20),ADD COLUMN grade FLOAT; 删除列ALTER TABLE tbl_name DROP [COLUMN] col_name12// 删除grade列mysql&gt; ALTER TABLE test DROP COLUMN grade ; 同时使用多个操作ALTER TABLE tbl_name DROP(|ADD) [COLUMN] col_name,DROP(|ADD) [COLUMN] col_name2,…12// 删除grade列 ，添加school列mysql&gt; ALTER TABLE test ADD COLUMN grade FLOAT ,DROP COLUMN school ; 修改数据表列定义 ALTER TABLE tbl_name MODIFY [COLUMN] col_name column_definition [FIRST|ALTER col_name] 在不改变列名的情况下修改列定义 123456789mysql&gt; ALTER TABLE test MODIFY name VARCHAR(20) DEFAULT &apos;JERRY&apos;;mysql&gt; DESCRIBE test;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(10) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | | JERRY | || sex | varchar(5) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+ 新的参数中如果没有包含原来的约束，那么原来的约束会被删除123456789mysql&gt; ALTER TABLE test MODIFY name VARCHAR(30) ;mysql&gt; DESCRIBE test;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(10) | NO | PRI | NULL | auto_increment || name | varchar(30) | YES | | NULL | || sex | varchar(5) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+ ALTER TABLE tbl_name CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST|AFTER col_name] 可以修改列名，和列定义 123456789mysql&gt; ALTER TABLE test CHANGE name new_name VARCHAR(20) DEFAULT &apos;TOM&apos; FIRST ;mysql&gt; DESCRIBE test;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| new_name | varchar(20) | YES | | TOM | || id | int(20) | NO | PRI | NULL | || sex | varchar(5) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+ 修改数据表名称 ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name 修改单个表名称 RENAME TABLE tbl_name TO new_tbl_name [,tbl_name2 TO new_tbl_name2…] 修改多个表名称 12345// 修改单个表名称mysql&gt; ALTER TABLE test RENAME TO db_test ;// 修改多个表名称mysql&gt; RENAME TABLE db_test TO test ,tb4 TO tb5 ;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL入门---数据库登陆与退出、数据库基本操作、开启数据库服务","slug":"MySQL入门-数据库登陆与退出、数据库基本操作、开启数据库服务","date":"2017-07-03T10:08:45.000Z","updated":"2017-12-10T12:01:46.971Z","comments":true,"path":"2017/07/03/MySQL入门-数据库登陆与退出、数据库基本操作、开启数据库服务/","link":"","permalink":"http://yoursite.com/2017/07/03/MySQL入门-数据库登陆与退出、数据库基本操作、开启数据库服务/","excerpt":"开启和关闭服务 net start mysql 启动服务 net stop mysql 停止服务","text":"开启和关闭服务 net start mysql 启动服务 net stop mysql 停止服务 执行此命令前，需要安装服务： mysqld -install 服务的名称往往不是mysql，而是mysql加上版本号，例如mysql57 登陆登陆使用mysql命令，该命令有以下参数： 参数 作用 -D 打开指定数据库 –delimiter=name 指定分隔符 -h(–host=name) 服务器名称(如果是默认的localhost，可以不写该选项) -p(小写)(–password[=password]) 输入密码 -P(大写)(–port) 端口号（如果是默认3306端口可以不写该选项） -u(–user=name) 用户名 -V(大写)（–version） 获得版本 退出三个命令作用相同： exit quit \\q 修改MySQL提示符登陆时指定可以在登陆时用–prompt指定提示符1C:\\Users\\twilight&gt;mysql -uroot -p123456 --prompt \\u@\\h-\\d 登陆后指定用 prompt 命令常用的参数： \\D 完整的日期 \\d 当前数据库 \\h 服务器名称 \\u 当前用户 因为当前没有选择数据库，所以\\d 显示none12345678mysql&gt;prompt \\u@\\h \\droot@localhost (none)root@localhost (none)use studentDatabase changedroot@localhost studentroot@localhost student prompt \\u@\\h-\\d \\D：PROMPT set to &apos;prompt \\u@\\h-\\d \\D：&apos;prompt root@localhost-student Fri Jun 30 10:42:56 2017： 常用命令 select version();显示当前服务器版本号 select now(); 显示当前日期时间 select user(); 显示当前用户 语句规范 关键字与函数名称全部大写 数据库名、表名称、字段名称全部小写 sql语句必须以分号结尾 基本操作创建数据库CREATE {DATABASE | SHEMAS} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_set_name 直接创建12mysql&gt; CREATE DATABASE test;Query OK, 1 row affected (0.00 sec) 创建时指定编码方式：12mysql&gt; CREATE DATABASE test2 CHARACTER SET GBK;Query OK, 1 row affected (0.00 sec) 使用IF NOT EXISTS判断数据库是否已存在：12mysql&gt; CREATE DATABASE IF NOT EXISTS test;Query OK, 1 row affected, 1 warning (0.00 sec) 备份和还原数据库备份数据库 mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名 在CMD下执行以下命令，会将数据库导出到指定的文件中 还原数据库 方法一： 先进入数据库：mysql -uroot -p 再创建空数据库：create database databasename 用source命令导入数据：source 路径+文件名 方法二： 先创建空数据库。 在cmd窗口中直接导入数据： mysql -uroot -p 数据库名 &lt; D:/桌面/market.sql 显示数据库SHOW {DATABASES | SCHEMAS} [LIKE ‘pattern’ | WHERE expr]123456789101112131415mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sakila || student || sys || test || test2 || world |+--------------------+9 rows in set (0.00 sec) 显示WARNINGSSHOW WARNINGS产生WARNINGS时查看警告的具体信息：1234567mysql&gt; SHOW WARNINGS;+-------+------+-----------------------------------------------+| Level | Code | Message |+-------+------+-----------------------------------------------+| Note | 1007 | Can&apos;t create database &apos;test&apos;; database exists |+-------+------+-----------------------------------------------+1 row in set (0.00 sec) 显示创建数据库的指令（查看数据库信息）SHOW CREATE DATABASE NAEM 用该命令可以查看数据库的信息，比如，该数据库的编码方式是gbk1234567mysql&gt; SHOW CREATE DATABASE test2;+----------+---------------------------------------------------------------+| Database | Create Database |+----------+---------------------------------------------------------------+| test2 | CREATE DATABASE `test2` /*!40100 DEFAULT CHARACTER SET gbk */ |+----------+---------------------------------------------------------------+1 row in set (0.00 sec) 修改数据库ALTER {DATABASE | SCHEMA}[db_name] [DEFAULT] CHARACTER SET [=] charset_name 使用alter修改数据库的默认编码方式：12mysql&gt; ALTER DATABASE test2 CHARACTER SET UTF8;Query OK, 1 row affected (0.00 sec) 查看修改后的编码,已经变成了utf-8：1234567mysql&gt; SHOW CREATE DATABASE test2;+----------+----------------------------------------------------------------+| Database | Create Database |+----------+----------------------------------------------------------------+| test2 | CREATE DATABASE `test2` /*!40100 DEFAULT CHARACTER SET utf8 */ |+----------+----------------------------------------------------------------+1 row in set (0.00 sec) 删除数据库DROP {DATABASE | SCHEMA} [IF EXISTS] db_name 1234567891011121314151617mysql&gt; DROP DATABASE test2;Query OK, 0 rows affected (0.01 sec)mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sakila || student || sys || test || world |+--------------------+8 rows in set (0.00 sec)","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Java反射---方法的反射、深入了解泛型","slug":"Java反射-方法的反射、深入了解泛型","date":"2017-06-28T07:43:42.000Z","updated":"2017-06-28T07:45:16.106Z","comments":true,"path":"2017/06/28/Java反射-方法的反射、深入了解泛型/","link":"","permalink":"http://yoursite.com/2017/06/28/Java反射-方法的反射、深入了解泛型/","excerpt":"方法的反射invoke(对象，参数列表)1、获得类类型Class data = a.getClass();","text":"方法的反射invoke(对象，参数列表)1、获得类类型Class data = a.getClass();2、获得方法 getMethod(“方法名”,可变参数(Class[])) 获得自身和继承的public方法 getDeclaredMethod(“方法名”,可变参数(Class[])) 获得自身的所有方法，不包括继承的方法 12Method print = data.getMethod(&quot;print&quot;, new Class[]&#123;int.class,int.class&#125;);Method print2 = data.getDeclaredMethod(&quot;print&quot;, new Class[]&#123;String.class,String.class&#125;); 3、执行方法invoke(对象obj，参数列表) 使用对象obj调用方法12print.invoke(a, 10, 20);print2.invoke(a, new String[]&#123;&quot;hello&quot;,&quot;world&quot;&#125;); 如果没有参数，可以不写：12Method print3 = data.getMethod(&quot;print&quot;);print3.invoke(a); 通过反射了解泛型的本质所谓泛型，是在编译阶段判断变量类型是否满足泛型要求。例如ArrayList&lt;Stirng&gt; 在编译时如果add一个int类型的变量肯定会出错，但是，在编译完成后，不同类型的泛型实际上是一样的。如下：1234567ArrayList list1 = new ArrayList();ArrayList&lt;String&gt; list2 = new ArrayList&lt;String&gt;();Class c1 = list1.getClass();Class c2 = list2.getClass();System.out.println(c1 == c2); // true 说明不同类型的泛型在编译后是一样的，泛型只是帮助判断变量类型的一种机制。String类型的泛型，只能加入String类型的变量，所以集合中保存的变量原本都是String类型。而Object类型的泛型可以加入任意类型的变量，所有变量都会被转换为Object类型后保存，所以在去变量时，需要手动的将Object类型强制转换为指定的类型。 反射机制是在编译之后完成的。所以可以利用反绕过泛型的编译:12345Method add = c2.getMethod(&quot;add&quot;, Object.class);add.invoke(list2, 100);System.out.println(list2.size()); // 1System.out.println(list2); // [100] 上面的例子在String类型的泛型集合中加入了整形变量，说明泛型的类型检查是在运行之前进行的。编译过后不会有泛型的类型检查，所以不会报错。另外我在编写的过程中还发现一个细节：1Method add = c2.getMethod(&quot;add&quot;, String.class); 上面这行代码会报错，c2是ArrayList&lt;String&gt;的类类型。一个String类型的泛型集合却无法获得String类型的add方法。原因是在编译过后所有类型会被擦除。在ArrayList的源码中用一个Object类型的数组来储存数据。编译过变量会被保存在Object数组中，所以add方法中的类型也会被转化为Object1transient Object[] elementData; // non-private to simplify nested class access 个人理解，欢迎指正 参考资料：反射","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java反射---Class对象，获得类的方法、成员变量和构造函数信息","slug":"Java反射-Class对象，获得类的方法、成员变量和构造函数信息","date":"2017-06-27T07:39:36.000Z","updated":"2017-06-28T06:11:59.817Z","comments":true,"path":"2017/06/27/Java反射-Class对象，获得类的方法、成员变量和构造函数信息/","link":"","permalink":"http://yoursite.com/2017/06/27/Java反射-Class对象，获得类的方法、成员变量和构造函数信息/","excerpt":"Class类任何一个类都是Class类的实例，而我们常见的对象，是用普通的类实例化出来的，也就是Class类的实例的实例。一个普通的类Foo的Class实例有三种表示方式：","text":"Class类任何一个类都是Class类的实例，而我们常见的对象，是用普通的类实例化出来的，也就是Class类的实例的实例。一个普通的类Foo的Class实例有三种表示方式： 1、知道类名获取Foo的Class实例Class c1 = Foo.class; 2、通过Foo对象获得Foo的Class实例Class c2 = foo.getClass(); 3、通过forName()获得实例Class c3 = Class.forName(&quot;test.reflect.Foo&quot;); 这三者是相等的：12System.out.println(c1 == c2&amp;&amp;c2 == c3);// True 可以用Class的实例创建Foo的实例：1Foo foo2 = (Foo)c1.newInstance(); 动态加载类1、静态加载类。编译时加载类，在编译时刻就需要加载所有的可能的使用到的类。所有的类都会加载，不管有没有被使用2、动态加载类。运行时加载类 使用Class.forName()动态加载类1234567891011public static void main(String [] args)&#123; try&#123; Class c = Class.forName(args[0]); // OfficeUtil 是接口 OfficeUtil obj = (OfficeUtil)c.newInstance(); obj.print(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125; 使用了OfficeUtil接口的Word类12345class Word implements OfficeUtil&#123; public void print()&#123; System.out.println(&quot;Word&quot;); &#125;&#125; 使用了OfficeUtil接口的Excel类12345class Excel implements OfficeUtil&#123; public void print()&#123; System.out.println(&quot;Excel&quot;); &#125;&#125; OfficeUtil接口123interface OfficeUtil&#123; public void print();&#125; 获得类类型的信息通过Class类的对象获得某个类的信息 getName() 返回类类型的名称 getSimpleName() 返回类类型的名称的简写 获得类名：12345678910Class c1 = int.class;Class c2 = String.class;Class c3 = void.class;Class c4 = double.class;Class c5 = Double.class;System.out.println(c1.getName());System.out.println(c2.getName());System.out.println(c3.getName());System.out.println(c4.getName());System.out.println(c5.getName()); 结果：12345intjava.lang.Stringvoiddoublejava.lang.Double getSimpleName()和getName():12java.lang.String // getName()String // getSimpleName() Method对象方法也是对象，一个成员方法就是一个Method对象实例。method实例有以下常用方法： getReturnType() 获得返回值，返回的是 Class&lt;?&gt; getParameterTypes 获得参数列表类型的类类型集合 返回的是Class&lt;?&gt;[] getName 获得方法名，返回 String getmethods() 返回继承的方法和自己定义的public方法（Class对象的方法） getDeclaredMethods(); 返回所有方法，但是不包括继承的方法（Class对象的方法） 1234567891011121314151617181920212223242526public static void printClassMethodMessage(Object obj)&#123; // 获得对象的类类型 Class data = obj.getClass(); // 获得类类型的名称 System.out.println(&quot;类名（getName）:&quot;+data.getName()); /** * Method类，一个成员方法就是一个Method对象实例。方法也是对象 * getDeclaredMethods(); 返回所有方法，但是不包括继承的方法 * getmethods() 返回继承的方法和自己定义的public方法 */ Method [] methods = data.getMethods(); for(Method temp : methods)&#123; // 获得返回值类型 Class returnType = temp.getReturnType(); System.out.print(returnType.getSimpleName()+&quot; &quot;); // 获得方法名 System.out.print(temp.getName()+&quot;(&quot;); // 获得参数数组 Class [] params = temp.getParameterTypes(); for(Class param : params)&#123; System.out.print(param.getSimpleName()+&quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125;&#125; 测试类：123public static void main(String[] args) &#123; ClassUtil.printClassMethodMessage(&quot;bbb&quot;);&#125; 结果是：1234567891011121314151617181920类名（getName）:java.lang.Stringboolean equals(Object,)String toString()int hashCode()int compareTo(String,)int compareTo(Object,)int indexOf(String,int,)int indexOf(String,)int indexOf(int,int,)int indexOf(int,)String valueOf(int,)String valueOf(long,)String valueOf(float,)String valueOf(boolean,)String valueOf(char[],)String valueOf(char[],int,int,)String valueOf(Object,)String valueOf(char,)String valueOf(double,)... 获得成员变量的信息Field对象表示成员变量。每一个变量都是一个Field对象 getFields() 获得public变量。返回Field[] getDeclaredFields() 获得所有变量，但不包括继承的变量 。返回Field[] getType获得 变量的类型。返回Class&lt;?&gt; getName() 变量名。返回 String 获得所有的成员变量123456789public static void printClassFieldMessage(Object obj)&#123; Class data = obj.getClass(); // 获得所有成员变量 Field [] fields = data.getDeclaredFields(); for(Field field:fields)&#123; System.out.println(field.getType().getName() +&quot; &quot;); System.out.println(field.getName()); &#125;&#125; 结果是：12345678910[C valueint hashlong serialVersionUID[Ljava.io.ObjectStreamField; serialPersistentFieldsjava.util.Comparator CASE_INSENSITIVE_ORDER 获得构造方法Constructor类的实例化对象，表示构造函数 获得构造函数：123456789101112131415public static void printClassConFieldMessage(Object obj)&#123; Class data = obj.getClass(); // 获得所有的构造函数 Constructor[] cons = data.getConstructors(); for(Constructor con:cons)&#123; // 获得函数名 System.out.print(con.getName()+&quot;(&quot;); // 获得参数列表 Class [] params = con.getParameterTypes(); for(Class param : params)&#123; System.out.print(param.getName()+&quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125;&#125; 结果：123456789101112131415java.lang.String([B,int,int,)java.lang.String([B,java.nio.charset.Charset,)java.lang.String([B,java.lang.String,)java.lang.String([B,int,int,java.nio.charset.Charset,)java.lang.String([B,int,int,java.lang.String,)java.lang.String(java.lang.StringBuilder,)java.lang.String(java.lang.StringBuffer,)java.lang.String([B,)java.lang.String([I,int,int,)java.lang.String()java.lang.String([C,)java.lang.String(java.lang.String,)java.lang.String([C,int,int,)java.lang.String([B,int,)java.lang.String([B,int,int,int,)","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Servlet-监听器获得当前在线人数","slug":"Servlet-监听器获得当前在线人数","date":"2017-06-26T13:28:18.000Z","updated":"2017-06-26T13:33:52.709Z","comments":true,"path":"2017/06/26/Servlet-监听器获得当前在线人数/","link":"","permalink":"http://yoursite.com/2017/06/26/Servlet-监听器获得当前在线人数/","excerpt":"案例一使用监听器获得当前在线的人数。用变量count表示当前在线人数。在HttpSessionListener每次调用sessionCreated方法时更新count，并保存在ServletContext中。之后需要使用时从ServletContext中获取即可。","text":"案例一使用监听器获得当前在线的人数。用变量count表示当前在线人数。在HttpSessionListener每次调用sessionCreated方法时更新count，并保存在ServletContext中。之后需要使用时从ServletContext中获取即可。12345678910111213141516@WebListenerpublic class MySessionListener implements HttpSessionListener &#123; private int count = 0 ; @Override public void sessionCreated(HttpSessionEvent se) &#123; count++; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); &#125; @Override public void sessionDestroyed(HttpSessionEvent se) &#123; count--; se.getSession().getServletContext().setAttribute(&quot;count&quot;, count); &#125;&#125; 案例二下面这个例子，除了获得在线的人数，还可以需要获得一些其他信息 ServletRequestListener监听器，对于每一次请求，获得请求的相关信息，并保存在ArrayList中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package listener;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import javax.servlet.annotation.WebListener;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import util.SessionUtil;import entity.User;@WebListenerpublic class MyServletRequestListener implements ServletRequestListener &#123; ArrayList&lt;User&gt; userList = null ; @Override public void requestDestroyed(ServletRequestEvent arg0) &#123; &#125; @Override public void requestInitialized(ServletRequestEvent arg0) &#123; HttpServletRequest request = (HttpServletRequest)arg0.getServletRequest(); HttpSession session = request.getSession(); userList = (ArrayList&lt;User&gt;)arg0.getServletContext().getAttribute(&quot;userList&quot;); if(userList == null)&#123; userList = new ArrayList(); &#125; String sessionId = session.getId(); String Ip = request.getLocalAddr(); String time = new SimpleDateFormat(&quot;yy-MM-dd hh:mm:ss&quot;).format(new Date()); User user = new User(); user.setFirstTime(time); user.setIp(Ip); user.setSessionID(sessionId); if(SessionUtil.getSessionByID(userList, sessionId)==null)&#123; userList.add(user); &#125; arg0.getServletContext().setAttribute(&quot;userList&quot;, userList); &#125;&#125; HttpSessionListener监听器，更新count的值，并在用户退出时删除ArrayList中的用户数据123456789101112131415161718192021222324252627282930313233343536package listener;import java.util.ArrayList;import javax.servlet.annotation.WebListener;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;import util.SessionUtil;import entity.User;@WebListenerpublic class MyHttpSessionListener implements HttpSessionListener &#123; private int count = 0 ; @Override public void sessionCreated(HttpSessionEvent arg0) &#123; count++; arg0.getSession().getServletContext().setAttribute(&quot;count&quot;, count); &#125; @Override public void sessionDestroyed(HttpSessionEvent arg0) &#123; count--; arg0.getSession().getServletContext().setAttribute(&quot;count&quot;, count); String id = arg0.getSession().getId(); ArrayList&lt;User&gt; userList = (ArrayList&lt;User&gt;)arg0.getSession().getServletContext().getAttribute(&quot;userList&quot;); if(SessionUtil.getSessionByID(userList, id) != null)&#123; User user = SessionUtil.getSessionByID(userList,id); userList.remove(user); &#125; &#125;&#125; 效果如下：","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Servlet-监听器（ServletContext、Request、Session）","slug":"Servlet-监听器（ServletContext、Request、Session）","date":"2017-06-26T10:35:49.000Z","updated":"2017-06-26T13:31:10.009Z","comments":true,"path":"2017/06/26/Servlet-监听器（ServletContext、Request、Session）/","link":"","permalink":"http://yoursite.com/2017/06/26/Servlet-监听器（ServletContext、Request、Session）/","excerpt":"ServletContextListenerServletContext对象创建和销毁时触发的监听器该对象有两个方法,分别是contextInitialized() 和contextDestroyed() 对应着ServletContext对象的创建与销毁。一个ServletContext可以有多个listener","text":"ServletContextListenerServletContext对象创建和销毁时触发的监听器该对象有两个方法,分别是contextInitialized() 和contextDestroyed() 对应着ServletContext对象的创建与销毁。一个ServletContext可以有多个listener ServletContext一个web应用对应着一个ServletContext，ServletContext的根目录为当前web应用的webRoot目录 12345678910111213public class FirstListener implements ServletContextListener &#123; public void contextDestroyed(ServletContextEvent arg0) &#123; System.out.println(&quot;###contextDestroy&quot;); &#125; public void contextInitialized(ServletContextEvent arg0) &#123; ServletContext context = arg0.getServletContext(); for(Object temp : context.getResourcePaths(&quot;/&quot;))&#123; System.out.println(temp); &#125; &#125;&#125; 结果是：123/index.jsp/WEB-INF//META-INF/ 配置监听器在web.xml中添加一下内容：123&lt;listener&gt; &lt;listener-class&gt;com.twilight.listener.FirstListener&lt;/listener-class&gt;&lt;/listener&gt; HttpSessionListener在浏览器中访问http://localhost:8080/FirstFilter 时会创建session，tomcat会输出sessionCreated，一段时间后session会自动失效，然后tomcat会输出sessionDestroyed一个Session对应多个listener 1234567public void sessionCreated(HttpSessionEvent arg0) &#123; System.out.println(&quot;sessionCreated&quot;);&#125;public void sessionDestroyed(HttpSessionEvent arg0) &#123; System.out.println(&quot;sessionDestroyed&quot;);&#125; 控制失效时间在web.xml 中配置session-timeout 以分钟为单位。当时间是0或复数时表示永久存在。123&lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt;&lt;/session-config&gt; 配置监听器在web.xml中添加一下内容：123&lt;listener&gt; &lt;listener-class&gt;com.twilight.listener.MyHttpSessionListener&lt;/listener-class&gt;&lt;/listener&gt; 作用 统计在线人数 记录访问日志 ServletRequestListener表示用户请求的监听两个方法：requestInitialized() 和requestDestroyed()1234567public void requestDestroyed(ServletRequestEvent arg0) &#123; System.out.println(&quot;requestDestroyed&quot;);&#125;public void requestInitialized(ServletRequestEvent arg0) &#123; System.out.println(&quot;requestInitialized&quot;);&#125; 结果是：123requestInitializedsessionCreatedrequestDestroyed 配置监听器在web.xml中添加一下内容：123&lt;listener&gt; &lt;listener-class&gt;com.twilight.listener.MyServletRequestListener&lt;/listener-class&gt;&lt;/listener&gt; 作用 读取参数 记录访问历史 对象中增加和删除属性的事件监听器三个事件都有对应的属性监听器： ServletContext — ServletContextAttributeListener HttpSession — HttpSessionAttributeListener ServletRequest — ServletRequestAttributeListener 每个属性监听器都有三个方法： attributeAdded () 监听属性的增加 attributeRemoved() 监听属性的移除 attributeReplaced() 监听属性的替换 ServletRequestAttributeListener 代码如下，其他监听器代码类似：123456789101112131415public class MyServletRequestAttributeListener implements ServletRequestAttributeListener &#123; public void attributeAdded(ServletRequestAttributeEvent arg0) &#123; System.out.println(&quot;ServletRequestAttributeListener_attributeAdded_&quot;+arg0.getName()); &#125; public void attributeRemoved(ServletRequestAttributeEvent arg0) &#123; System.out.println(&quot;ServletRequestAttributeListener_attributeRemoved_&quot;+arg0.getName()); &#125; public void attributeReplaced(ServletRequestAttributeEvent arg0) &#123; System.out.println(&quot;ServletRequestAttributeListener_attributeReplaced_&quot;+arg0.getName()); &#125;&#125; addAttribute.jsp模拟增加属性123request.setAttribute(&quot;ServletRequest&quot;, &quot;ServletRequestValue&quot;);session.setAttribute(&quot;Session&quot;, &quot;SessionValue&quot;);session.getServletContext().setAttribute(&quot;ServletContext&quot;, &quot;ServletContextValue&quot;); removeAttribute.jsp 模拟移除属性123request.removeAttribute(&quot;ServletRequest&quot;);session.removeAttribute(&quot;Session&quot;);session.getServletContext().removeAttribute(&quot;ServletContext&quot;); 第一次访问addAttribute.jsp:123456requestInitializedServletRequestAttributeListener_attributeReplaced_org.apache.catalina.ASYNC_SUPPORTEDServletRequestAttributeListener_attributeAdded_ServletRequestHttpSessionAttributeListener_attributeAdded_SessionServletContextAttributeListener_attributeAdded_ServletContextrequestDestroyed 重复访问,发现只有Request是add，因为之前的Request已经失效，此时的Request是新创建的对象：123456requestInitializedServletRequestAttributeListener_attributeReplaced_org.apache.catalina.ASYNC_SUPPORTEDServletRequestAttributeListener_attributeAdded_ServletRequestHttpSessionAttributeListener_attributeReplaced_SessionServletContextAttributeListener_attributeReplaced_ServletContextrequestDestroyed 访问removeAttribute.jsp,此时之前的Request对象已经被销毁，所以不会看到request被remove12345requestInitializedServletRequestAttributeListener_attributeReplaced_org.apache.catalina.ASYNC_SUPPORTEDHttpSessionAttributeListener_attributeRemoved_SessionServletContextAttributeListener_attributeRemoved_ServletContextrequestDestroyed HttpSession 中对象状态（绑定、解除） 绑定 ：将对象保存到session中 解除 ：从session中移除对象 HttpSessionBindingListener该类类似一个javabean保存一些需要的信息，它有两个必须的方法： valueBound() 绑定 valueUnbound() 解绑定 1234567891011121314151617181920212223242526272829303132333435package com.twilight.entity;import javax.servlet.http.HttpSessionBindingEvent;import javax.servlet.http.HttpSessionBindingListener;public class User implements HttpSessionBindingListener &#123; private String userName ; private String password ; public void valueBound(HttpSessionBindingEvent arg0) &#123; System.out.println(&quot;HttpSessionBindingListener_valueBound_&quot;+arg0.getName()); &#125; public void valueUnbound(HttpSessionBindingEvent arg0) &#123; System.out.println(&quot;HttpSessionBindingListener_valueUnbound+&quot;+arg0.getName()); &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 该类不需要注册，可以直接使用，因为他可以认为只是一个继承了HttpSessionBindingListener接口的Javabean，使用方法：1session.setAttribute(&quot;userObj&quot;, new User()); 1session.removeAttribute(&quot;userObj&quot;); 结果是：123456789// 绑定requestInitializedHttpSessionBindingListener_valueBound_userObjrequestDestroyed// 解绑定requestInitializedHttpSessionBindingListener_valueUnbound+userObjrequestDestroyed 钝化和活化 钝化 将session序列化到磁盘 活化 将序列化的对象反序列化到内存中 什么时候钝化 当tomcat服务器关闭或重启时，会将当前的session对象钝化 当web应用被重新加载时（reload）钝化 当tomcat服务器重启开启时，重新加载文件道内存并删除本地文件 HttpSessionActivationListener实现钝化和话的接口，具体方法有两个： sessionWillPassivate 钝化 sessionDidActivate 活化 由于钝化需要将对象序列化，所以还需要实现Serializable接口。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.twilight.entity;import java.io.Serializable;import javax.servlet.http.HttpSessionActivationListener;import javax.servlet.http.HttpSessionBindingEvent;import javax.servlet.http.HttpSessionBindingListener;import javax.servlet.http.HttpSessionEvent;public class User implements HttpSessionBindingListener ,HttpSessionActivationListener ,Serializable &#123; private String userName ; private String password ; public void valueBound(HttpSessionBindingEvent arg0) &#123; System.out.println(&quot;HttpSessionBindingListener_valueBound_&quot;+arg0.getName()); &#125; public void valueUnbound(HttpSessionBindingEvent arg0) &#123; System.out.println(&quot;HttpSessionBindingListener_valueUnbound+&quot;+arg0.getName()); &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void sessionDidActivate(HttpSessionEvent se) &#123; System.out.println(&quot;HttpSessionActivationListener_sessionDidActivate_&quot;+se.getSource()); &#125; public void sessionWillPassivate(HttpSessionEvent se) &#123; System.out.println(&quot;HttpSessionActivationListener_sessionWillPassivate_&quot;+se.getSource()); &#125;&#125; 结果：12345// 钝化HttpSessionActivationListener_sessionWillPassivate_org.apache.catalina.session.StandardSessionFacade@720a366b// 活化HttpSessionActivationListener_sessionDidActivate_org.apache.catalina.session.StandardSessionFacade@798aa3f4 钝化后的文件保存在 Tomcat\\work\\Catalina\\localhost\\项目名\\SESSIONS.ser文件中，服务器启动后文件被反序列化，然后被删除 参考资料：http://www.imooc.com/learn/271","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"jQuery动画---自定义动画animate()","slug":"jQuery动画-自定义动画animate","date":"2017-06-20T11:42:28.000Z","updated":"2017-08-26T01:15:48.771Z","comments":true,"path":"2017/06/20/jQuery动画-自定义动画animate/","link":"","permalink":"http://yoursite.com/2017/06/20/jQuery动画-自定义动画animate/","excerpt":"同步动画animate(参数对象,time,回调函数) 同时改变多个样式。12345678$(&quot;:button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123; &apos;width&apos;:&quot;300px&quot;, &apos;height&apos;:&quot;300px&quot;, &apos;opacity&apos;:0.5, &apos;font-size&apos;:&apos;50px&apos; &#125;);&#125;);","text":"同步动画animate(参数对象,time,回调函数) 同时改变多个样式。12345678$(&quot;:button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123; &apos;width&apos;:&quot;300px&quot;, &apos;height&apos;:&quot;300px&quot;, &apos;opacity&apos;:0.5, &apos;font-size&apos;:&apos;50px&apos; &#125;);&#125;); 添加速度和回调函数12345678910$(&quot;:button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123; &apos;width&apos;:&quot;300px&quot;, &apos;height&apos;:&quot;300px&quot;, &apos;opacity&apos;:0.5, &apos;font-size&apos;:&apos;50px&apos; &#125;,200,function()&#123; alert(&quot;动画完成&quot;); &#125;);&#125;); 移动动画。需要将div的样式设置成position:absolte,然后在改变left和top的值即可：123456$(&quot;:button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123; left:&apos;100px&apos;, top:&apos;100px&apos; &#125;);&#125;); 位置的自增自减。位置的改变可以自增自减（+=，-=）123456$(&quot;:button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123; left:&apos;+=100px&apos;, top:&apos;-=100px&apos; &#125;);&#125;); 运动模式有两种速度 swing 缓动（先快后慢） linear 匀速 123456$(&quot;.a&quot;).animate(&#123; left:&quot;500px&quot;&#125;,2000,&apos;swing&apos;);$(&quot;.b&quot;).animate(&#123; left:&quot;500px&quot;&#125;,2000,&apos;linear&apos;); 列队动画回调函数嵌套调用回调函数，可以实现队列动画，但是比较繁琐123456789$(&quot;:input&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123;width:&quot;300px&quot;&#125;,function()&#123; $(&quot;div&quot;).animate(&#123;height:&quot;300px&quot;&#125;,function()&#123; $(&quot;div&quot;).animate(&#123;height:&quot;300px&quot;&#125;,function()&#123; $(&quot;div&quot;).animate(&#123;fontSize:&quot;50px&quot;&#125;); &#125;) &#125;); &#125;); &#125;); 连缀或顺序排列链式调用jQuery支持链式调用。因此可以链式的改变多个样式12345$(&quot;:input&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123;width:&quot;300px&quot;&#125;) .animate(&#123;height:&quot;300px&quot;&#125;) .animate(&#123;fontSize:&quot;50px&quot;&#125;);&#125;); 顺序排列将动画分解，并列的依次调用12345$(&quot;:input&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123;width:&quot;300px&quot;&#125;); $(&quot;div&quot;).animate(&#123;height:&quot;300px&quot;&#125;); $(&quot;div&quot;).animate(&#123;fontSize:&quot;50px&quot;&#125;);&#125;); PS以上方法对于单个元素的样式可以实现列队动画。但是如果同时控制几个元素时，不同的元素同时开始执行。但是执行时是按照队列依次执行自身的动画，如果需要不同的元素之间队列执行，就必须嵌套回调函数12345678$(&quot;:input&quot;).click(function()&#123; $(&quot;.a&quot;).animate(&#123;width:&quot;300px&quot;&#125;); $(&quot;.a&quot;).animate(&#123;height:&quot;300px&quot;&#125;); $(&quot;.a&quot;).animate(&#123;fontSize:&quot;50px&quot;&#125;); $(&quot;.b&quot;).animate(&#123;width:&quot;300px&quot;&#125;); $(&quot;.b&quot;).animate(&#123;height:&quot;300px&quot;&#125;); $(&quot;.b&quot;).animate(&#123;fontSize:&quot;50px&quot;&#125;);&#125;); queue()如果在一连串的动画后调用改变样式的函数。那么会先改变css样式，后执行动画。 123$(&quot;:input&quot;).click(function()&#123; $(&quot;.a&quot;).animate(&#123;width:&quot;300px&quot;&#125;).animate(&#123;height:&quot;300px&quot;&#125;).css(&quot;background-color&quot;,&quot;skyblue&quot; );&#125;); 解决的方法是使用queue函数，该函数会让动画先执行：12345$(&quot;:input&quot;).click(function()&#123; $(&quot;.a&quot;).animate(&#123;width:&quot;300px&quot;&#125;).animate(&#123;height:&quot;300px&quot;&#125;).queue(function()&#123; $(&quot;.a&quot;).css(&quot;background-color&quot;,&quot;skyblue&quot; ); &#125;);&#125;); 但是，这是如果在queue后再接着调用其他动画时会失效，解决方法是在queue函数的末尾调用next(),同时在queue的匿名函数入口传入nextqueue(function(next){… next()}); 1234567$(&quot;:input&quot;).click(function()&#123; $(&quot;.a&quot;).animate(&#123;width:&quot;300px&quot;&#125;); $(&quot;.a&quot;).animate(&#123;height:&quot;300px&quot;&#125;).queue(function(next)&#123; $(&quot;.a&quot;).css(&quot;background-color&quot;,&quot;skyblue&quot;); next(); &#125;).animate(&#123;width:&quot;800px&quot;&#125;);&#125;); 较老的版本使用dequeue函数达到同样的效果：1234567$(&quot;:input&quot;).click(function()&#123; $(&quot;.a&quot;).animate(&#123;width:&quot;300px&quot;&#125;); $(&quot;.a&quot;).animate(&#123;height:&quot;300px&quot;&#125;).queue(function(next)&#123; $(&quot;.a&quot;).css(&quot;background-color&quot;,&quot;skyblue&quot;); $(this).dequeue(); &#125;).animate(&#123;width:&quot;800px&quot;&#125;);&#125;); queue还可以得到当前动画的长度 clearQueue()清理之后没有开始的动画，并且，clearQueue() 方法移除任何排队的函数。12345678910111213$(&quot;:input&quot;).click(function()&#123; $(&quot;.a&quot;).animate(&#123;width:&quot;300px&quot;&#125;,2000); $(&quot;.a&quot;).animate(&#123;height:&quot;300px&quot;&#125;,2000); $(&quot;.a&quot;).animate(&#123;fontSize:&quot;50px&quot;&#125;,2000); $(&quot;.a&quot;).queue(function(next)&#123; $(&quot;.a&quot;).css(&quot;background-color&quot;,&quot;skyblue&quot;); $(this).dequeue(); &#125;).animate(&#123;width:&quot;800px&quot;&#125;);&#125;);$(&quot;:input:eq(1)&quot;).click(function()&#123; $(&quot;.a&quot;).clearQueue();&#125;); stop()stop(clearQueue,gotoEnd) clearQueue 停止，并清空后面未执行完的动画。默认为 false (true/false) gotoEnd 停止后，当前动画执行完毕的位置，默认为 false （true/false) 默认地，如果有列队动画，stop停止第一个列队动画，而继续执行后面的动画。1234567891011121314$(&quot;:button:eq(0)&quot;).click(function()&#123; $(&quot;.a&quot;).animate(&#123; left:&quot;500px&quot; &#125;,1000); $(&quot;.a&quot;).animate(&#123; top:&quot;500px&quot; &#125;,1000); $(&quot;.a&quot;).animate(&#123; width:&quot;500px&quot; &#125;,1000);&#125;);$(&quot;:button:eq(1)&quot;).click(function()&#123; $(&quot;.a&quot;).stop(true,true);&#125;); delay()事件延迟一定的时间delay(time) 123456789101112$(&quot;:button:eq(0)&quot;).click(function()&#123; $(&quot;.a&quot;).animate(&#123; left:&quot;500px&quot; &#125;); $(&quot;.a&quot;).animate(&#123; top:&quot;500px&quot; &#125;); $(&quot;.a&quot;).delay(1000); $(&quot;.a&quot;).animate(&#123; width:&quot;500px&quot; &#125;);&#125;); animated之前说过的一个过滤器，可以选择正在执行动画的元素 一个永不停止的动画：123$(&quot;.a&quot;).slideToggle(function()&#123; $(&quot;.a&quot;).slideToggle(arguments.callee);&#125;); 使用过滤器：123$(&quot;:button&quot;).click(function()&#123; $(&quot;:animated&quot;).css(&quot;backgroundColor&quot;,&quot;blue&quot;);&#125;); 动画的全局属性全局的动画属性： $.fx.interval 动画执行的帧数 (num) $.fx.off 关闭动画（true/false） 12$.fx.interval = 100; 设置帧数为100 ，动画变得卡顿$.fx.off = true; 取消所有动画","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery动画---显示、卷动、淡入淡出","slug":"jQuery动画-显示、卷动、淡入淡出","date":"2017-06-16T08:25:22.000Z","updated":"2017-08-26T01:16:02.263Z","comments":true,"path":"2017/06/16/jQuery动画-显示、卷动、淡入淡出/","link":"","permalink":"http://yoursite.com/2017/06/16/jQuery动画-显示、卷动、淡入淡出/","excerpt":"显示和隐藏show()/hide() 显示和隐藏 动画显示可以加时间参数，标志显示或者隐藏的快慢，单位为毫秒。还有三个预设的速度：slow、normal 和 fast，分别对应 600 毫秒、400 毫秒和 200 毫秒。如果传递的时间不符合格式要求或者为空字符串，那个将采用normal123456$(&quot;:button:eq(0)&quot;).click(function()&#123; $(&quot;div:eq(0)&quot;).show(500);&#125;);$(&quot;:button:eq(1)&quot;).click(function()&#123; $(&quot;div:eq(0)&quot;).hide(500);&#125;);","text":"显示和隐藏show()/hide() 显示和隐藏 动画显示可以加时间参数，标志显示或者隐藏的快慢，单位为毫秒。还有三个预设的速度：slow、normal 和 fast，分别对应 600 毫秒、400 毫秒和 200 毫秒。如果传递的时间不符合格式要求或者为空字符串，那个将采用normal123456$(&quot;:button:eq(0)&quot;).click(function()&#123; $(&quot;div:eq(0)&quot;).show(500);&#125;);$(&quot;:button:eq(1)&quot;).click(function()&#123; $(&quot;div:eq(0)&quot;).hide(500);&#125;); 回调函数动画执行完毕后，紧接着执行回调函数。这里如果不写time则依然有速度，速度为normalshow(time,fun)123$(&quot;div:eq(0)&quot;).show(500,function()&#123; alert(&quot;显示完成&quot;);&#125;); 队列动画在一个动画执行完后，调用另一个动画，由此实现队列动画。采用递归自动遍历所有需要操作的元素。 12345678910$(&quot;:button:eq(0)&quot;).click(function()&#123; $(&quot;div&quot;).first().show(100,function test()&#123; $(this).next().show(100,test); &#125;);&#125;);$(&quot;:button&quot;).last().click(function()&#123; $(&quot;div&quot;).last().hide(100,function test1()&#123; $(&quot;div:visible&quot;).last().hide(100,test1); &#125;);&#125;); 也可以使用arguments.callee表示匿名函数的引用arguments.callee的用法参考 js函数 12345678910$(&quot;:button:eq(0)&quot;).click(function()&#123; $(&quot;div&quot;).first().show(100,function ()&#123; $(this).next().show(100, arguments.callee); &#125;);&#125;);$(&quot;:button&quot;).last().click(function()&#123; $(&quot;div&quot;).last().hide(100,function ()&#123; $(&quot;div:visible&quot;).last().hide(100, arguments.callee); &#125;);&#125;); toggle()在show和hide之间自动切换123$(&quot;:button:eq(2)&quot;).click(function()&#123; $(&quot;div&quot;).toggle(200);&#125;); 卷动用法与show/hide类似，具体方法如下： slideUp() 向上卷起 slideDown() 向下展开 slideToggle() 自动切换 123456789$(&quot;:button:eq(0)&quot;).click(function()&#123; $(&quot;div&quot;).slideUp(&apos;slow&apos;);&#125;);$(&quot;:button:eq(1)&quot;).click(function()&#123; $(&quot;div&quot;).slideDown(&apos;slow&apos;);&#125;);$(&quot;:button:eq(2)&quot;).click(function()&#123; $(&quot;div&quot;).slideToggle(&apos;slow&apos;);&#125;); 淡入淡出与show类似，具体方法如下： fadeIn() 淡入 fadeOut() 淡出 fadeToggle() 自动切换 fadeTo() 指定透明度(0-1) 123456789101112$(&quot;:button:eq(0)&quot;).click(function()&#123; $(&quot;div&quot;).fadeIn(&apos;slow&apos;);&#125;);$(&quot;:button:eq(1)&quot;).click(function()&#123; $(&quot;div&quot;).fadeOut(&apos;slow&apos;);&#125;);$(&quot;:button:eq(2)&quot;).click(function()&#123; $(&quot;div&quot;).fadeToggle(&apos;slow&apos;);&#125;);$(&quot;:button:eq(2)&quot;).click(function()&#123; $(&quot;div&quot;).fadeTo(&apos;slow&apos;,0.5);&#125;);","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery高级事件---on、off、one和事件委托","slug":"jQuery高级事件-on、off、one和事件委托","date":"2017-06-16T06:54:08.000Z","updated":"2017-08-26T01:15:38.443Z","comments":true,"path":"2017/06/16/jQuery高级事件-on、off、one和事件委托/","link":"","permalink":"http://yoursite.com/2017/06/16/jQuery高级事件-on、off、one和事件委托/","excerpt":"on、off、one jQuery1.7 以后推出了.on()和.off()方法，替代之前的方法。on/off整合了bind、unbind、事件委托等方法","text":"on、off、one jQuery1.7 以后推出了.on()和.off()方法，替代之前的方法。on/off整合了bind、unbind、事件委托等方法 on替代bind方法on可以替代bind方法，使用方法和bind一致12345678910111213141516171819202122232425262728293031// 绑定单个事件 $(&quot;:button&quot;).on(&quot;click&quot;,function()&#123; alert(&quot;on&quot;); &#125;);// 传递数据 $(&quot;:button&quot;).on(&quot;click&quot;,&#123;name:&quot;tom&quot;&#125;,function(e)&#123; alert(e.data.name); &#125;);// 绑定多个事件 $(&quot;:button&quot;).on(&quot;mouseover mouseout&quot;,function(e)&#123; alert(&quot;移入移出&quot;); &#125;);// 使用对象绑定多个事件 $(&quot;:button&quot;).on(&#123; mouseover:function()&#123; alert(&quot;移入&quot;); &#125;, mouseout:function()&#123; alert(&quot;移出&quot;); &#125; &#125;);// 阻止冒泡和默认行为 $(&quot;:submit&quot;).on(&quot;click&quot;,function(e)&#123; e.preventDefault(); e.stopPropagation(); alert(&quot;取消默认行为和冒泡&quot;); &#125;); off替代unbind方法off可以替代unbind方法，使用方法不变1234567function test()&#123; alert(&quot;test&quot;);&#125;$(&quot;:button&quot;).on(&quot;click.on&quot;,test); //根据函数解除绑定$(&quot;:button&quot;).off(&quot;click&quot;); // 根据事件解除绑定$(&quot;:button&quot;).off(&quot;click.on&quot;); // 根据命名空间解除绑定 事件委托实际上是给祖先绑定一个事件。子元素通过冒泡将事传递到祖先元素，祖先元素再判断点击的是不是button，如果是，就执行相同的事件。因此，当有很多个相同的按钮需要绑定相同的事件时，可以用事件委托将事件委托给祖先节点，有祖先节点判断子节点是否执行某事件。如果不适用事假委托，那个每一个节点都需要绑定一个事件。使用方法是：祖先节点.on(“事件”,”子元素”,”绑定的函数”); on的第二个参数需要写成所有相同元素通用的写法，不能写成:button:eq(0)这样的选择不具有通用性，祖先节点在判断的时候会无法达到预期的效果。12345678 $(&quot;div:eq(0)&quot;).on(&quot;click&quot;,&quot;:button&quot;,function()&#123; $(this).clone(true).appendTo(&quot;div:eq(0)&quot;); &#125;);// 换成document也可： $(document).on(&quot;click&quot;,&quot;:button&quot;,function()&#123; $(this).clone(true).appendTo(&quot;div:eq(0)&quot;); &#125;); 取消委托off函数还可以取消委托,取消委托必须由祖先节点调用调用方法是：祖先节点.off(“事件”,”子元素”); 1$(&quot;div:eq(0)&quot;).off(&apos;click&apos;, &apos;.button&apos;); one()绑定元素执行完毕后自动移除事件，可以方法仅触发一次的事件。123$(&quot;:button&quot;).one(&quot;click&quot;,function()&#123; alert(&quot;one&quot;);&#125;); 用到的方法clone()生成被选元素的副本，包含子节点、文本和属性。$(selector).clone(includeEvents) includeEvents 规定是否复制元素的所有事件处理。true/false,默认是false appendTo()在被选元素的结尾（仍然在内部）插入指定内容。123$(&quot;button&quot;).click(function()&#123; $(&quot;&lt;b&gt;sss&lt;/b&gt;&quot;).appendTo(&quot;p&quot;);&#125;);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery高级事件---模拟操作和命名空间","slug":"jQuery高级事件-模拟事件和命名空间","date":"2017-06-16T03:31:45.000Z","updated":"2017-08-26T01:16:21.008Z","comments":true,"path":"2017/06/16/jQuery高级事件-模拟事件和命名空间/","link":"","permalink":"http://yoursite.com/2017/06/16/jQuery高级事件-模拟事件和命名空间/","excerpt":"模拟操作trigger()浏览器自行触发事件.例如：当网页加载完毕后浏览器自行点击一个按钮触发一个事件，而不是用户去点击。 1234$(&quot;input&quot;).click(function()&#123; alert(&quot;自行点击事件&quot;);&#125;);$(&quot;input&quot;).trigger(&quot;click&quot;); 也可以简写为：123$(&quot;input&quot;).click(function()&#123; alert(&quot;自行点击事件&quot;);&#125;).trigger(&quot;click&quot;);","text":"模拟操作trigger()浏览器自行触发事件.例如：当网页加载完毕后浏览器自行点击一个按钮触发一个事件，而不是用户去点击。 1234$(&quot;input&quot;).click(function()&#123; alert(&quot;自行点击事件&quot;);&#125;);$(&quot;input&quot;).trigger(&quot;click&quot;); 也可以简写为：123$(&quot;input&quot;).click(function()&#123; alert(&quot;自行点击事件&quot;);&#125;).trigger(&quot;click&quot;); 传递数据给事件执行传递参数，这个参数类似与 event.data的额外数据，可以是数字、字符串、数组、对象。当传递一条数据时可以省略中括号，多条必须加上中括号，中括号不表示数组，只是一个标识 传递一条参数：1234$(&quot;input&quot;).click(function()&#123; alert(&quot;自行点击事件&quot;);&#125;);$(&quot;input&quot;).trigger(&quot;click&quot;); 传递一条参数的简写：123$(&quot;input&quot;).click(function(e,data1)&#123; alert(data1);&#125;).trigger(&quot;click&quot;,&quot;sss&quot;); 传递多条参数：123$(&quot;input&quot;).click(function(e,data1,data2,data3)&#123; alert(data1+data2+data3);&#125;).trigger(&quot;click&quot;,[&quot;sss&quot;,1,2]); 传递数组：123$(&quot;input&quot;).click(function(e,data1,data2,data3)&#123; alert(data1+data2+data3[0]);&#125;).trigger(&quot;click&quot;,[&quot;sss&quot;,1,[1,2,3]]); 传递对象：123$(&quot;input&quot;).click(function(e,data1,data2,data3)&#123; alert(data1+data2+data3.user);&#125;).trigger(&quot;click&quot;,[&quot;sss&quot;,1,&#123;user:&apos;tom&apos;&#125;]); bind也可同时传递数据，但是bind需要从event中获得：123$(&quot;input&quot;).bind(&quot;click&quot;,&#123;user:&quot;tom&quot;&#125;,function(e,data1,data2,data3)&#123; alert(e.data.user+data1+data2+data3.user);&#125;).trigger(&quot;click&quot;,[&quot;sss&quot;,1,&#123;user:&apos;tom&apos;&#125;]); 自定义事件可以通过自定义的事件触发相关函数，所谓自定义事件其实就是执行被.bind()绑定的函数123$(&quot;input&quot;).bind(&quot;myEvent&quot;,function()&#123; alert(&quot;这是一个自定义事件&quot;);&#125;).trigger(&quot;myEvent&quot;); 简写方案trigger()方法提供了简写方案，只要想让某个事件执行模拟用户行为，直接再调用一个空的同名事件即可,例如：trigger(&quot;click&quot;) ---&gt; click()。几乎所有事件都有简写方式：123456blur focusin mousedown resizechange focusout mousenter scrollclick keydown mouseleave selectdblclick keypress mousemove submiterror keyup mouseout unloadfocus load mouseover triggerHandler()1.触发事件，但不会执行默认行为trigger执行表单提交时会触发默认事件，自动跳转123 $(&quot;form&quot;).submit().triggle(&quot;submit&quot;);// 等效的用法： $(&quot;form&quot;).triggle(&quot;submit&quot;); triggerHandler()提交表单但是不会自动跳转1$(&quot;form&quot;).triggleHandler(&quot;submit&quot;); 2.triggerHandler()只会触发第一个元素的事件，而trigger会触发所有满足条件的元素的事件。123$(&quot;:button&quot;).click(function()&#123; // 只会执行第一个按钮的事件 alert(&quot;###&quot;);&#125;).triggerHandler(&quot;click&quot;); 3.trigger返回jQuery对象，triggerHandler()返回事件的返回值。所以triggerHandler不能用链式使用123456var reuslt = $(&quot;:button&quot;).click(function()&#123; alert(&quot;###&quot;); return 123; // 如果没有return则triggerHandler返回undefined&#125;).triggerHandler(&quot;click&quot;);alert(reuslt); // 123 4.trigger会冒泡，triggerHandler不会冒泡123456$(&quot;div&quot;).click(function()&#123; alert(&quot;div&quot;);&#125;);$(&quot;:button:eq(0)&quot;).click(function()&#123; alert(&quot;aaa&quot;);&#125;).triggerHandler(&quot;click&quot;); 命名空间click.abc常常使用给事件绑定匿名函数。但是匿名函数不方便移除。因此使用命名空间可以给每一个匿名函数一个对应的命名，方便控制 只会删除click.abc对应的函数：123$(&quot;:button:eq(0)&quot;).bind(&quot;click.abc&quot;,function()&#123;alert(&quot;abc&quot;)&#125;);$(&quot;:button:eq(0)&quot;).bind(&quot;click.xyz&quot;,function()&#123;alert(&quot;xyz&quot;)&#125;);$(&quot;:button:eq(0)&quot;).unbind(&quot;click.abc&quot;); 删除所有abc对应的函数：123$(&quot;:button:eq(0)&quot;).bind(&quot;click.abc&quot;,function()&#123;alert(&quot;abc&quot;)&#125;);$(&quot;:button:eq(0)&quot;).bind(&quot;mouseenter.abc&quot;,function()&#123;alert(&quot;abc&quot;)&#125;);$(&quot;:button:eq(0)&quot;).unbind(&quot;.abc&quot;); trigger 和 triggerHandler也可以使用命名空间：12$(&quot;:button:eq(0)&quot;).bind(&quot;click.abc&quot;,function()&#123;alert(&quot;abc&quot;)&#125;);$(&quot;:button:eq(0)&quot;).triggerHandler(&quot;click.abc&quot;);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery事件---阻止冒泡和默认行为","slug":"jQuery事件-阻止冒泡和默认行为","date":"2017-06-15T09:00:40.000Z","updated":"2017-06-15T09:02:23.810Z","comments":true,"path":"2017/06/15/jQuery事件-阻止冒泡和默认行为/","link":"","permalink":"http://yoursite.com/2017/06/15/jQuery事件-阻止冒泡和默认行为/","excerpt":"冒泡如果在页面中重叠了多个元素，并且重叠的这些元素都绑定了同一个事件，那么就会出现冒泡问题。例如：12345&lt;body&gt; &lt;div style=&quot;width:300px;height:300px;background-color:skyblue;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;button&quot;/&gt; &lt;/div&gt;&lt;/body&gt; 如果document、div、input三个元素绑定了同一个事件，就会产生冒泡：123456789$(document).click(function()&#123; alert(&quot;document&quot;);&#125;);$(&quot;div&quot;).click(function()&#123; alert(&quot;div&quot;);&#125;);$(&quot;:button&quot;).click(function()&#123; alert(&quot;button&quot;);&#125;); 当点击button时，会先弹出button、然后是div、然后是document","text":"冒泡如果在页面中重叠了多个元素，并且重叠的这些元素都绑定了同一个事件，那么就会出现冒泡问题。例如：12345&lt;body&gt; &lt;div style=&quot;width:300px;height:300px;background-color:skyblue;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;button&quot;/&gt; &lt;/div&gt;&lt;/body&gt; 如果document、div、input三个元素绑定了同一个事件，就会产生冒泡：123456789$(document).click(function()&#123; alert(&quot;document&quot;);&#125;);$(&quot;div&quot;).click(function()&#123; alert(&quot;div&quot;);&#125;);$(&quot;:button&quot;).click(function()&#123; alert(&quot;button&quot;);&#125;); 当点击button时，会先弹出button、然后是div、然后是document 阻止冒泡event.stopPropagation() ： 所有上层的冒泡行为都将被取消1234567891011$(document).click(function()&#123; alert(&quot;document&quot;);&#125;);$(&quot;div&quot;).click(function(e)&#123; e.stopPropagation(); alert(&quot;div&quot;);&#125;);$(&quot;:button&quot;).click(function(e)&#123; e.stopPropagation(); alert(&quot;button&quot;);&#125;); 阻止默认行为默认行为，常见的是点击超链接时的跳转，表单的提交，鼠标右击的系统菜单等等。preventDefault()：阻止默认行为 阻止超链接的跳转：123$(&quot;a&quot;).click(function(e)&#123; e.preventDefault();&#125;); 阻止表单的提交：123$(&quot;form:eq(0)&quot;).submit(function(e)&#123; e.preventDefault();&#125;); 阻止鼠标右键(contextmenu表示鼠标右键事件)：123$( document ).contextmenu(function(e) &#123; e.preventDefault();&#125;); PS： contextmenu表示鼠标右键事件，用法与一般事件相同：12345$(document).bind(&quot;contextmenu&quot;,function()&#123;alert(&quot;鼠标右键&quot;)&#125;);// 等效于：$(document).contextmenu(function(e) &#123; alert(&quot;鼠标右键&quot;);&#125;); 阻止冒泡并阻止默认行为同时使用preventDefault()和stopPropagation()函数1234$(&quot;a&quot;).click(function(e)&#123; e.preventDefault(); e.stopPropagation();&#125;); 或者，直接使用return false123$(&quot;a&quot;).click(function(e)&#123; return false;&#125;); 其他函数目前已经用过的函数有两个： preventDefault() 取消某个元素的默认行为 stopPropagation() 取消事件冒泡 另外还有几个相关的函数： isDefaultPrevented() ： 判断是否调用了 preventDefault()方法 isPropagationStopped() ： 判断是否调用了 stopPropagation()方法 stopImmediatePropagation() ： 取消事件冒泡，并取消该事件的后续事件处理函数 isImmediatePropagationStopped() ： 判断是否调用了 stopImmediatePropagation()方法 stopImmediatePropagation()取消冒泡，并阻止后续事件。例如：12345678910$(&quot;:submit&quot;).click(function(e)&#123; e.stopImmediatePropagation(); //e.stopPropagation(); alert(&quot;1&quot;);&#125;);$(&quot;:submit&quot;).click(function()&#123; alert(&quot;2&quot;);&#125;); 如果使用stopPropagation()那么会取消冒泡，但是仍然后弹出两次。如果使用stopImmediatePropatation()那么不但会取消冒泡，还会取消后续绑定的事件。","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery事件对象---常见属性","slug":"jQuery事件对象-常见属性","date":"2017-06-15T09:00:06.000Z","updated":"2017-06-15T09:07:00.235Z","comments":true,"path":"2017/06/15/jQuery事件对象-常见属性/","link":"","permalink":"http://yoursite.com/2017/06/15/jQuery事件对象-常见属性/","excerpt":"event对象常见属性 属性 含义 type 获取这个事件的事件类型的字符串，例如：click target 获取与事件绑定的 DOM 元素 data 获取事件调用时的额外数据 relatedTarget 获取移入移出目标前所在的元素 currentTarget 获取冒泡前触发的 DOM 元素，等同与 this pageX/pageY 获取相对于页面原点的水平/垂直坐标 screenX/screenY 获取显示器屏幕位置的水平/垂直坐标(非 jQuery 封装) clientX/clientY 获取相对于页面可见部分的水平/垂直坐标(非 jQuery 封装) result 获取上一个相同事件的返回值 timeStamp 获取事件触发的时间戳（字符串） which 获取鼠标的左中右键(1,2,3)，或获取键盘按键 altKey/shiftKey/ctrlKey/metaKey 判断在点击的同时是否按下了 alt、shift、ctrl键","text":"event对象常见属性 属性 含义 type 获取这个事件的事件类型的字符串，例如：click target 获取与事件绑定的 DOM 元素 data 获取事件调用时的额外数据 relatedTarget 获取移入移出目标前所在的元素 currentTarget 获取冒泡前触发的 DOM 元素，等同与 this pageX/pageY 获取相对于页面原点的水平/垂直坐标 screenX/screenY 获取显示器屏幕位置的水平/垂直坐标(非 jQuery 封装) clientX/clientY 获取相对于页面可见部分的水平/垂直坐标(非 jQuery 封装) result 获取上一个相同事件的返回值 timeStamp 获取事件触发的时间戳（字符串） which 获取鼠标的左中右键(1,2,3)，或获取键盘按键 altKey/shiftKey/ctrlKey/metaKey 判断在点击的同时是否按下了 alt、shift、ctrl键 Target target 获得触发元素的DOM（点击的元素） currentTarget得到的是监听元素的DOM（绑定的元素） 对于样式：12345678910111213&lt;div style=&quot;width:300px;height:300px;background-color:skyblue;&quot;&gt; &lt;span style=&quot;width:100px;height:100px;background-color:yellow;display:block&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; $(&quot;div:eq(0)&quot;).bind(&quot;mouseover&quot;,function(event)&#123; // alert(event); // [object Object] // alert(event.type); // click // alert(event.target); // 点击的元素 [object HTMLSpanElement]/[object HTMLDivElement] // alert(event.currentTarget); // 总是div [object HTMLDivElement] alert(event.relatedTarget); &#125;);&lt;/script&gt; 用鼠标进入事件模拟三种target的效果： target: currentTarget: relatedTarget: data通过 event.data 获取额外数据，可以是数字、字符串、数组、对象 123$(&quot;:button:eq(1)&quot;).bind(&quot;click&quot;,&quot;sss&quot;,function(e)&#123; alert(e.data);&#125;); pageY、screenY、clienty pageY 是对于页面顶端的距离，包括未显示的部分，所以常用于滚动条，随着滚动条改变 screenY 是对于屏幕顶端的距离，不随滚动条改变 clienty 是相对于页面可见部分顶端的距离，不随滚动条改变 which判断鼠标点击,不过实验的时候好像只有左键有效 (/= _ =)/~┴┴123$(&quot;:text&quot;).click(function(e)&#123; alert(e.which);&#125;); 判断键盘按下的值123$(&quot;:text&quot;).keydown(function(e)&#123; alert(e.which);&#125;);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery事件---常见事件的绑定与解除","slug":"jQuery事件-常见事件的绑定与解除","date":"2017-06-15T04:43:41.000Z","updated":"2017-06-15T04:50:19.611Z","comments":true,"path":"2017/06/15/jQuery事件-常见事件的绑定与解除/","link":"","permalink":"http://yoursite.com/2017/06/15/jQuery事件-常见事件的绑定与解除/","excerpt":"绑定事件常见事件有：click dbclick mousedown mouseup mousemove mouseover mouseout change select submit keydown keypress keyup blur focus load resize scroll error… jquery 用 bind() 为元素绑定事件bind(type,[data],function) type 表示事件类型，是事件名称的字符串 data 是可选的作为event.data 属性传递一个额外的数据 fn 表示绑定到指定元素的处理函数","text":"绑定事件常见事件有：click dbclick mousedown mouseup mousemove mouseover mouseout change select submit keydown keypress keyup blur focus load resize scroll error… jquery 用 bind() 为元素绑定事件bind(type,[data],function) type 表示事件类型，是事件名称的字符串 data 是可选的作为event.data 属性传递一个额外的数据 fn 表示绑定到指定元素的处理函数 123$(function()&#123; $(&quot;input&quot;).bind(&quot;click&quot;,test);&#125;); 将元素与指定函数绑定1234567$(function()&#123; $(&quot;input&quot;).bind(&quot;click&quot;,test);&#125;);function test()&#123; alert(&quot;#&quot;);&#125; 可以一次绑定多个事件 bind(‘evevt1 event2 ‘，function()) 绑定多个事件 同时绑定鼠标移入和移出事件1234567$(function()&#123; $(&quot;input&quot;).bind(&quot;mouseover mouseout&quot;,function()&#123; $(&quot;div&quot;).html(function(index,value)&#123; return (value+index); &#125;); &#125;);&#125;); 通过键值对双引号可加可不加bind({ event1:function(){}, event2:function(){}}) 12345678910$(function()&#123; $(&quot;input&quot;).bind(&#123; mouseover:function()&#123; alert(&quot;移入&quot;); &#125;, mouseout:function()&#123; alert(&quot;移出&quot;); &#125; &#125;);&#125;); 删除事件 unbind() 删除当前元素所有的事件 unlind(‘事件’) 删除指定事件 unbind(‘事件’,fn) 删除事件绑定的特定函数 12345678910111213$(function()&#123; $(&quot;input&quot;).bind(&#123; mouseover:function()&#123; alert(&quot;移入&quot;); &#125;, mouseout:function()&#123; alert(&quot;移出&quot;); &#125; &#125;); $(&quot;input&quot;).unbind(&quot;mouseover&quot;); // 移除mouseover事件 $(&quot;input&quot;).unbind(); // 移除改元素的所有事件&#125;); 移出元素上绑定的指定函数1234$(function()&#123; $(&quot;input&quot;).bind(&quot;mouseover&quot;,test); $(&quot;input&quot;).unbind(&quot;mouseover&quot;,test);&#125;); 简化的事件函数 click(fn) 鼠标click(单击)事件 dblclick(fn) 鼠标dblclick(双击)事件 mousedown(fn) 鼠标mousedown(点击后)事件 mouseup(fn) 鼠标mouseup(点击弹起)事件 mouseover(fn) 鼠标mouseover(鼠标移入)事件 mouseout(fn) 鼠标mouseout(鼠标移出)事件 mousemove(fn) 鼠标mousemove(鼠标移动)事件 mouseenter(fn) 鼠标mouseenter(鼠标穿过)事件 mouseleave(fn) 鼠标mouseleave(鼠标穿出)事件 keydown(fn) 键盘keydown(键盘按下)事件 keyup(fn) 键盘keyup(键盘按下弹起)事件 keypress(fn) 键盘keypress(键盘按下)事件 unload(fn) 文档 当卸载本页面时绑定一个要执行的函数 resize(fn) 文档resize(文档改变大小)事件 scroll(fn) 文档scroll(滚动条拖动)事件 focus(fn) 表单 focus(焦点激活)事件 blur(fn) 表单blur(焦点丢失)事件 focusin(fn) 表单 触发每一个匹配元素的 focusin(焦点激活)事件 focusout(fn) 表单 触发每一个匹配元素的 focusout(焦点丢失)事件 select(fn) 表单select(文本选定)事件 change(fn) 表单change(值改变)事件 submit(fn) 表单submit(表单提交)事件 1234// 单击事件 $(&quot;input&quot;).click(function()&#123; alert(&quot;#&quot;); &#125;); 123456// 双击事件 function dbtest()&#123; alert(&quot;双击&quot;); &#125; $(&quot;input&quot;).dblclick(dbtest); 1234567// 鼠标按下弹起事件 $(&quot;input&quot;).mousedown(function()&#123; alert(&quot;down&quot;); &#125;); $(&quot;input&quot;).mouseup(function()&#123; alert(&quot;up&quot;) &#125;); 1234// 浏览器窗口改变大小时触发 $(window).resize(function()&#123; alert(&quot;resize&quot;); &#125;); 1234// 滚动条事件 $(document).scroll(function()&#123; alert(&quot;scroll&quot;); &#125;); 1234// b表单文本被选中事件 $(&quot;textarea&quot;).select(function()&#123; alert(&quot;文本被选中&quot;); &#125;); 1234// 表单文本被更改事件 $(&quot;textarea&quot;).change(function()&#123; alert(&quot;文本被更改&quot;); &#125;); 鼠标进入/移出事件 mouseover/mouseout 鼠标移入移出（穿过子元素会触发） mouseenter/mouseleave 鼠标穿入/穿出(穿过子元素不会触发) 给大div绑定鼠标移入和移出事件，当鼠标进入绿色div时，会输出两个0.因为移入绿色div时同时发生了移出大div和移入小div，会触发两次事件。1234567891011$(&quot;div&quot;).eq(0).mouseover(function()&#123; $(&quot;.p&quot;).eq(0).html(function (index,value)&#123; return value + index ; &#125;);&#125;);$(&quot;div&quot;).eq(0).mouseout(function()&#123; $(&quot;.p&quot;).eq(0).html(function (index,value)&#123; return value + index ; &#125;);&#125;); 键盘事件keydown/keyup 和 heypress keydown/keyup 返回键码keyCode keypress 返回字符编码 charCode如果类型错误会返回0 12$(window).keyup(function()&#123;alert(event.keyCode);&#125;);$(window).keypress(function()&#123;alert(event.charCode);&#125;); 获得焦点事件 focus() / flur() 光标激活和丢失（当前元素，不包含子元素） focusin() / focusout() 光标激活和丢失（包含子元素） PS: 1. 只用于表单2. 点击控件时才会转移焦点12345$(&quot;.div&quot;).focusin(function()&#123; $(&quot;.p&quot;).html(function(index,value)&#123; return value+&quot;1&quot;; &#125;);&#125;); 复合事件 ready(function) 当DOM加载完毕时触发 hover（fn1,fn2） 移入和移出时在fn1 和fn2 之间切换（mouseenter和mouseleaver的结合） toggle(fn1,fn2,fn3)已弃用。在多个样式之间切换 hover()移入和移出时改变颜色：12345$(&quot;div&quot;).hover(function()&#123; $(this).css(&quot;background-color&quot;,&quot;red&quot;);&#125;,function()&#123; $(this).css(&quot;background-color&quot;,&quot;blue&quot;);&#125;); toggle()自己完成toggle() ，每次点击切换一个样式123456789101112131415var count = 0 ; $(&quot;.div&quot;).click(function()&#123; if(count == 0 )&#123; $(this).css(&quot;background-color&quot;,&quot;red&quot;); count ++ ; &#125; else if (count == 1 )&#123; $(this).css(&quot;background-color&quot;,&quot;green&quot;); count ++ ; &#125; else if (count == 2)&#123; $(this).css(&quot;background-color&quot;,&quot;yellow&quot;); count=0 ; &#125;&#125;); PS : div默认是不能选中的，使用鼠标点击无法获得焦点，如果需要获得焦点可以加上tabindex=”1”属性123&lt;div class=&quot;div&quot; style=&quot;width:200px;height:200px; background-color:yellow;&quot; tabindex=&quot;1&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input&quot;/&gt;&lt;/div&gt;","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"查找和关闭占用特定端口的进程","slug":"查找和关闭占用特定端口的进程","date":"2017-06-15T04:22:17.000Z","updated":"2017-06-15T04:23:18.329Z","comments":true,"path":"2017/06/15/查找和关闭占用特定端口的进程/","link":"","permalink":"http://yoursite.com/2017/06/15/查找和关闭占用特定端口的进程/","excerpt":"","text":"今天写博客时发现hexo s 无效，于是怀疑4000端口被其他软件占用了。在网上查了一下。可以在cmd中使用netstat -ano查看正在使用的端口： 但是结果很多，如果一个一个找的话很麻烦，于是可以用netstat -ano | finderstr 4000 查看占用400端口使用情况： 可以看到此时有一个程序占用了4000端口，改程序的PID为9892，然后用tasklist | findstr 9892查看该程序的详细信息： 结果显示是node.exe占用了4000端口，其实node.exe就是hexo的服务器，之前的进程我已经关掉了。那么接下来需要关掉这个进程的话需要打开任务管理器，在PID一栏找到对应的进程然后关闭就可以了。有的进程需要管理员权限才能关闭。此时需要用管理员权限打开任务管理器。在开始菜单中输入taskmgr，然后右键管理员身份打开，然后在关闭对应的服务就可以了","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"}]},{"title":"2017-06-03","slug":"2017-06-03","date":"2017-06-03T09:18:42.000Z","updated":"2017-06-03T14:22:06.477Z","comments":true,"path":"2017/06/03/2017-06-03/","link":"","permalink":"http://yoursite.com/2017/06/03/2017-06-03/","excerpt":"","text":"无人为孤岛，一书一世界","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"jQuery入门---对象、创建节点","slug":"jQuery入门","date":"2017-04-24T07:47:40.000Z","updated":"2017-08-26T01:17:11.177Z","comments":true,"path":"2017/04/24/jQuery入门/","link":"","permalink":"http://yoursite.com/2017/04/24/jQuery入门/","excerpt":"导入jQuery使用jQuery只需加上一行代码：&lt;script src=&quot;JS/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt;jQuery中用\\$选择元素，\\$ 代表jQuery对象，二者是相等的1alert($ == jQuery); // true","text":"导入jQuery使用jQuery只需加上一行代码：&lt;script src=&quot;JS/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt;jQuery中用\\$选择元素，\\$ 代表jQuery对象，二者是相等的1alert($ == jQuery); // true 加载完成后自动执行在js中常见window.onload=function(){...}表示在页面加载完成后执行，jQuery也有类似的方式。具体有三种方式： $(document).ready(function(){}) $(function(){})&nbsp;&nbsp;&nbsp;(1的简写) jQuery(function(){})&nbsp;&nbsp;&nbsp;(jQuery等同于\\$) 与js中的onload不同，jQuery不会等待所有元素都加载完成后再执行。执行速度比onload快。 window.onload只能加载一次，jQuery可加载多次 jQuery对象与dom对象的转换获取jQuery对象 var $t1 = $(‘#t1’); jQuery转换成dom $t1[0] $t1.get(0) dom对象转换为jQueryvar $t1 = $(t1); jQuery创建新节点1.使用标签名+对象$(“&lt;标签名&gt;”,保存属性的对象);1var jqobj = $(&quot;&lt;div&gt;&quot;,&#123;&apos;id&apos;:&apos;test&apos;,&apos;class&apos;:&apos;test&apos;&#125;); 2.直接使用字符串，字符串中包含所需的所有信息1var jqobj = $(&quot;&lt;div class=&apos;test&apos; id=&apos;test&apos;&gt;jQuery对象&lt;/div&gt;&quot;); 需要追加到父节点后才能生效：123var jqobj = $(&quot;&lt;div&gt;&quot;,&#123;&apos;id&apos;:&apos;test&apos;,&apos;class&apos;:&apos;test&apos;&#125;);jqobj.html(&quot;jQuery对象&quot;);$(&quot;body&quot;).append(jqobj); 对象辨析导入jQuery后，现在总共有3种对象，不总结一下很容易弄混。具体如下： jQuery对象 DOM对象 js对象 jQuery对象是jQuery封装的对象：1alert(jQuery); // function (a,b)&#123;return new n.fn.init(a,b)&#125; 通过jQuery的get获得DOM对象：12alert($(&quot;body&quot;)[0]); // [object HTMLBodyElement]alert(document.getElementsByTagName(&quot;body&quot;)[0]); // [object HTMLBodyElement] 原生的js对象：12345var obj = &#123; &quot;data&quot;:1, &quot;name&quot;:&quot;tom&quot; &#125;; alert(obj); // [object Object]","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"ServletContext","slug":"Servlet-ServletCotntext","date":"2017-04-17T10:48:23.000Z","updated":"2017-07-15T08:26:55.947Z","comments":true,"path":"2017/04/17/Servlet-ServletCotntext/","link":"","permalink":"http://yoursite.com/2017/04/17/Servlet-ServletCotntext/","excerpt":"简介WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。可以通过ServletConfig.getServletContext方法获得ServletContext对象。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。","text":"简介WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。可以通过ServletConfig.getServletContext方法获得ServletContext对象。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。 getRequestDispatcher()参考这篇博客http://twilight.net.cn/2017/04/09/Servlet-%E4%BD%BF%E7%94%A8RequestDispathcher%E8%B0%83%E6%B4%BE%E8%AF%B7%E6%B1%82/ getResourcePaths(“url”)url 必须以/开头123for(String temp : getServletContext().getResourcePaths(&quot;/&quot;))&#123; output.println(temp);&#125; 效果如下123456789101112131415/JSP-useBean//FormTest.html/AutoLogin.jsp/Hello.jsp/Cookie//Main.html/CheckNum//META-INF//index.jsp/test.html/WEB-INF//includes//JSP-Include//AutoLogin.html/error.jsp 获取webRoot下的所有图片123456789101112protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter output = resp.getWriter(); ServletContext context = getServletContext(); // &apos;/&apos; 表示 WebRoot for(String temp : context.getResourcePaths(&quot;/img&quot;))&#123; temp = temp.substring(temp.indexOf(&quot;/&quot;)+1); output.println(&quot;&lt;img src=&apos;&quot;+temp+&quot;&apos; width=200 height=200&gt;&lt;/img&gt;&quot;); &#125;&#125; getResourceAsStream(“url”)获取文件流，返回类型是InputStream，URL必须以”/“开头 向页面中发送图片12345678910111213141516protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = req.getServletContext(); // 获取输入流 InputStream input = context.getResourceAsStream(&quot;/img/P70114-101325.jpg&quot;); // 获取输出流 OutputStream output = resp.getOutputStream(); byte [] data = new byte [1024]; int len = 0 ; while(-1 != (len = input.read(data)))&#123; output.write(data,0,len); &#125; output.close(); input.close();&#125; 这是从服务器端向客户端发送文件，如果需要接受客户端发来的文件，具体操作方式请参考Servlet 上传文件","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Servlet ServletConfig","slug":"Servlet-ServletConfig","date":"2017-04-15T09:18:29.000Z","updated":"2017-04-15T09:21:30.234Z","comments":true,"path":"2017/04/15/Servlet-ServletConfig/","link":"","permalink":"http://yoursite.com/2017/04/15/Servlet-ServletConfig/","excerpt":"ServletConfig获取初始化参数 getServletName(“name”) 根据名称返回值 getServletNames() 返回所有name，返回类型是Enumeration 在init()中有两种方式获取参数 web.xml中的参数如下：","text":"ServletConfig获取初始化参数 getServletName(“name”) 根据名称返回值 getServletNames() 返回所有name，返回类型是Enumeration 在init()中有两种方式获取参数 web.xml中的参数如下：123456789101112&lt;servlet&gt;&lt;servlet-name&gt;ServletConfigTest&lt;/servlet-name&gt;&lt;servlet-class&gt;servletConfig.ServletConfigTest&lt;/servlet-class&gt;&lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;tom&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt;&lt;/init-param&gt;&lt;/servlet&gt; 1：直接调用getInitParameter();1234public void init() throws ServletException &#123; userName = getInitParameter(&quot;name&quot;); password = getInitParameter(&quot;password&quot;);&#125; 2: 先用getInitParameterConfig()获取ServletConfig对象，再用ServletConfig对象获取参数12345public void init() throws ServletException &#123; ServletConfig config = getServletConfig(); userName = config.getInitParameter(&quot;name&quot;); password = config.getInitParameter(&quot;password&quot;);&#125; 也可以使用@WebServlet设置初始化参数：1234567@WebServlet( urlPatterns=&quot;/ServletConfigTest&quot;, initParams=&#123; @WebInitParam(name=&quot;name&quot;,value=&quot;Jerry&quot;), @WebInitParam(name=&quot;password&quot;,value=&quot;456&quot;) &#125; ) 如果同时设置了@WebServlet和web.xml那么web.xml中的参数会覆盖掉@WebServlet。必须有相同的name12345678@WebServlet( name=&quot;ServletConfigTest&quot;, // name与web.xml 中相同，被web.xml覆盖 urlPatterns=&quot;/ServletConfigTest&quot;, initParams=&#123; @WebInitParam(name=&quot;name&quot;,value=&quot;Jerry&quot;), @WebInitParam(name=&quot;password&quot;,value=&quot;456&quot;) &#125; ) PS:HttpServlet 继承了genericServlet，而genericServlet同时集成了Servlet, ServletConfig。genericServlet是通用的Servlet，对于http请求要使用httpSetvlet","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"JSP jsp:useBean介绍","slug":"JSP-jsp-useBean介绍","date":"2017-04-15T06:30:24.000Z","updated":"2017-07-19T12:51:23.959Z","comments":true,"path":"2017/04/15/JSP-jsp-useBean介绍/","link":"","permalink":"http://yoursite.com/2017/04/15/JSP-jsp-useBean介绍/","excerpt":"创建JavaBean实例：&lt;jsp:useBean id=”name” class=”” scope=”page/session/request/application”/&gt; id为类的另一个名字，class指定具体的类，scope表示范围，在scope的范围内查找是否有指定的属性存在","text":"创建JavaBean实例：&lt;jsp:useBean id=”name” class=”” scope=”page/session/request/application”/&gt; id为类的另一个名字，class指定具体的类，scope表示范围，在scope的范围内查找是否有指定的属性存在 JavaBean需要满足以下条件： 必须实现java.io.Serializable 接口 没有公开(public)的类变量 具有无参数的构造函数 具有公开的set和get方法 赋值 指定参数和值&lt;jsp:setProperty name=&quot;user&quot; property=&quot;password&quot; value=&quot;123&quot; /&gt; 将指定参数的值赋值给JavaBean的属性&lt;jsp:setProperty name=&quot;user&quot; param=&quot;pwd&quot; property=&quot;password&quot; /&gt; 通过自省机制自动匹配&lt;jsp:setProperty name=&quot;user&quot; property=&quot;*&quot; /&gt; 使用jsp:useBean的目的是减少Script的使用一个典型的javabean: JavaBean.java1234567891011121314151617181920212223242526272829303132333435package Bean;import java.io.Serializable;public class JavaBean implements Serializable &#123; private String name ; private String password; public JavaBean(String name, String password) &#123; super(); this.name = name; this.password = password; &#125; public JavaBean() &#123; super(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public boolean isValid()&#123; if(name.equals(&quot;tom&quot;) &amp;&amp; password.equals(&quot;123&quot;))&#123; return true; &#125; return false; &#125;&#125; 使用jsp:Bean标签1234567891011&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;jsp:useBean id=&quot;user&quot; class=&quot;Bean.JavaBean&quot; scope=&quot;page&quot; /&gt;&lt;jsp:setProperty name=&quot;user&quot; property=&quot;*&quot; /&gt;&lt;html&gt; &lt;body&gt; &lt;font color=&apos;red&apos;&gt; &lt;jsp:getProperty property=&quot;name&quot; name=&quot;user&quot;/&gt; &lt;/font&gt; &lt;/body&gt;&lt;/html&gt; web容器翻译后的Java代码123456Bean.JavaBean user = null;user = (Bean.JavaBean) _jspx_page_context.getAttribute(&quot;user&quot;, javax.servlet.jsp.PageContext.PAGE_SCOPE);if (user == null)&#123; user = new Bean.JavaBean(); _jspx_page_context.setAttribute(&quot;user&quot;, user, javax.servlet.jsp.PageContext.PAGE_SCOPE);&#125; 采用传统方式的做法：123456789101112131415161718&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,Bean.JavaBean&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt; &lt;body&gt; &lt;% JavaBean user = (JavaBean)request.getAttribute(&quot;user&quot;); if(user == null)&#123; user = new JavaBean(); &#125; user.setName(request.getParameter(&quot;name&quot;)); user.setPassword(request.getParameter(&quot;pwd&quot;)); if(user.isValid())&#123; out.println(&quot;登录成功&quot;); &#125;else&#123; out.println(&quot;登录失败&quot;); &#125; %&gt; &lt;/body&gt;&lt;/html","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"JSP入门---常见标签元素的使用","slug":"JSP入门-常见标签元素的使用","date":"2017-04-10T07:47:40.000Z","updated":"2017-08-27T00:30:44.638Z","comments":true,"path":"2017/04/10/JSP入门-常见标签元素的使用/","link":"","permalink":"http://yoursite.com/2017/04/10/JSP入门-常见标签元素的使用/","excerpt":"Scriptlet元素&lt;% %&gt; 用于运行Java代码 123&lt;% out.println(&quot;hello&quot;);%&gt;","text":"Scriptlet元素&lt;% %&gt; 用于运行Java代码 123&lt;% out.println(&quot;hello&quot;);%&gt; 声明（Decalaration）元素&lt;%! %&gt;可以声名函数和变量，作为Servlet的方法和成员。声明的变量会被翻译到_jspService()方法的外面（类成员，方法） &lt;% %&gt; 也可以声明变量,声明的变量是_jspService()一部分，是一个局部变量 由于对象只创建一次，当不断访问以下代码时，data的值会递增，但是data2的值始终为11234567&lt;%! int data = 1; %&gt; // 成员变量&lt;%int data2 = 1; // 方法中的局部变量out.println(data++); out.println(data2++);%&gt; 表达式元素&lt;%= %&gt; 字符串变量，或者可以转换成字符串的表达式 “=” 号的前面不能有空格 表达式后不加分号 &lt;%=date %&gt;翻译时会被转换为out.println(date); 传入参数Bgcolor，会显示指定颜色的文字12345&lt;% String color = request.getParameter(&quot;Bgcolor&quot;);%&gt;&lt;font color=&lt;%=color %&gt; size=5 &gt;&lt;%=color %&gt;&lt;/font&gt; PS:当输出的&lt;%或%&gt;时，&lt;% 用 &amp;lt;% 表示，%&gt;用%&amp;gt; 或者 %\\&gt;表示 注释元素JSP注释: &lt;%– –%&gt;java注释: &lt;%// %&gt;java注释: &lt;%/ /%&gt; 指示(Directive)元素&lt;%@ Directive属性=”属性值”%&gt;常见的指示类型有page、include、taglib page属性常见属性值如下: import=”java.util.*” 相当于Java中的import contentType=”Text/html;charset=utf-8” 指定contentType pageEncoding=”UTF-8” 指定转义时的编码 language=”java” 默认是Java errorPage=”error.jsp” 指定发生错误时的跳转页面 iserrorPage=”true/false” 错误页面 可以使用多条指令语句单独设置每个属性，也可以使用同一条指令语句设置该指令的多个属性 &lt;%@ page contentType=“text/html;charset=utf-8” %&gt;&lt;%@ page import=“java.io.” %&gt;&lt;%@ page contentType=”text/html;charset=utf-8” import=”java.io.“ %&gt; &lt;%@ page import=”java.util.Date, java.io.*” %&gt; 等同于 &lt;%@ page import=“java.util.Date” %&gt; &lt;%@ page import=“java.io.*” %&gt; &lt;%@ page contentType=“text/html;charset=UTF-8” %&gt; 会被翻译为： response.setContentType(“text/html;charset=UTF-8”) 在使用errorPage时，不是所有的错误都能转发。只有抛出异常的错误才能被转发 错误页面必须要指定isErrorPage=”true” 错误转发案例发生错误的页面 hello.jsp123456789&lt;%@ page errorPage=&quot;error.jsp&quot; %&gt; &lt;% String color = request.getParameter(&quot;Bgcolor&quot;); %&gt; &lt;font color=&lt;%=color %&gt; size=5 &gt;&lt;%=color %&gt;&lt;/font&gt; &lt;%Date today = new Date(); %&gt; &lt;font color=&lt;%=color %&gt;&gt;今天是&lt;%=today %&gt;&lt;/font&gt; &lt;%--抛出异常--%&gt; &lt;%=1/0 %&gt; 错误页面 error.jsp1&lt;%@ page isErrorPage=&quot;true&quot;%&gt; include&lt;%@include file=”URL” %&gt;在翻译时将其他jsp文件包括到当前文件中。翻译后只会生成一个Servlet。 不能向URL中用GET方法传递参数，例如： &lt;%@ include file=”includes/Include_Header.jsp?Bgcolor=red” %&gt; 错误 案例将页面分成3部分，使用include将头部和尾部包括进来 IncludeTest.jsp1234&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ include file=&quot;includes/Include_Header.jsp&quot; %&gt; &lt;p&gt;这是页面主体&lt;/p&gt;&lt;%@ include file=&quot;includes/Include_Footer.jsp&quot; %&gt; Include_Header.jsp12345678910111213141516171819202122232425&lt;%@ page pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;My JSP &apos;IncludeTest.jsp&apos; starting page&lt;/title&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt; &lt;!-- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是页面的Header部分&lt;/p&gt; Include_Footer.jsp1234&lt;%@ page pageEncoding=&quot;UTF-8&quot;%&gt;&lt;p&gt;这是页面的Footer部分&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 显示结果为：123这是页面的Header部分这是页面主体这是页面的Footer部分","categories":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"Servlet 使用RequestDispathcher调派请求","slug":"Servlet-使用RequestDispathcher调派请求","date":"2017-04-09T13:54:35.000Z","updated":"2017-04-10T11:57:55.961Z","comments":true,"path":"2017/04/09/Servlet-使用RequestDispathcher调派请求/","link":"","permalink":"http://yoursite.com/2017/04/09/Servlet-使用RequestDispathcher调派请求/","excerpt":"RequestDispathcher使用HttpServletRequest的getRequestDispatcher(“Servlet-URL”) 获得对象 RequestDispatcher dispatch = req.getRequestDispatcher(“/Test1”); include()将另一个servlet包括进进目前的操作流程中。","text":"RequestDispathcher使用HttpServletRequest的getRequestDispatcher(“Servlet-URL”) 获得对象 RequestDispatcher dispatch = req.getRequestDispatcher(“/Test1”); include()将另一个servlet包括进进目前的操作流程中。以下代码会输出DispatchTest1 Done 1234567891011/Dispatch protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter output = resp.getWriter(); output.println(&quot;Dispatch&lt;br/&gt;&quot;); RequestDispatcher dispatch = req.getRequestDispatcher(&quot;/Test1&quot;); dispatch.include(req, resp);; output.println(&quot;Done&lt;br/&gt;&quot;); &#125; 123456/Test1 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter output = resp.getWriter(); output.println(&quot;Test1&lt;br/&gt;&quot;); &#125; forward()将请求转发给另一个servlet，只是服务器端的转发，对于客户端并无任何影响 PS:调用forWard()之前不能有任何相应确认，如果设置了相应但还未确认(例如println()后还没有flush())，则所有相应会被忽略.如果已经有相应确认，会报出java.lang.IllegalStateException异常 以下代码会转向Test1，而忽略之forward之前的println输出123456PrintWriter output = resp.getWriter();output.println(&quot;Dispatch&lt;br/&gt;&quot;);RequestDispatcher dispatch = req.getRequestDispatcher(&quot;/Test1&quot;);dispatch.forward(req, resp);;output.println(&quot;Done&lt;br/&gt;&quot;); 以下代码会直接报错，因为已经有相应确认1234567PrintWriter output = resp.getWriter();output.println(&quot;Dispatch&lt;br/&gt;&quot;);output.flush(); RequestDispatcher dispatch = req.getRequestDispatcher(&quot;/Test1&quot;);dispatch.forward(req, resp);;output.println(&quot;Done&lt;br/&gt;&quot;); 请求范围属性当调派请求的过程中有需要共享的属性，可以使用HttpServletRequest的方法 setAttribute() 指定名称与对象 getAttribute() 指定名称获取对象 getAttributeNames() 获取所有属性名称 removeAttribute() 移除属性 以下代码的Test1通过getAttribute(“name”)获取到name的集合，需要通过强制转换后才能使用。123456789101112131415/Dispatch protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter output = resp.getWriter(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;Tom&quot;); list.add(&quot;jerry&quot;); req.setAttribute(&quot;name&quot;, list); // 传入字符串和对象 RequestDispatcher dispatch = req.getRequestDispatcher(&quot;/Test1&quot;); dispatch.forward(req, resp); output.println(&quot;Done&lt;br/&gt;&quot;); &#125; 123456789/Test1 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter output = resp.getWriter(); output.println(&quot;Test1&lt;br/&gt;&quot;); List name = (List)req.getAttribute(&quot;name&quot;); output.println(name.get(1)+&quot;&lt;/br/&gt;&quot;); &#125; sendRedirect()要求浏览器重新请求一个URL，客户端的地址栏会改变12345protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String url = req.getParameter(&quot;url&quot;); resp.sendRedirect(url);&#125; 在跳转之前不可以有相应被确认,否则会产生java.lang.IllegalStateException 异常12345678protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter output = resp.getWriter(); output.println(&quot;2333&quot;); output.flush(); String url = req.getParameter(&quot;url&quot;); resp.sendRedirect(url);&#125; 跳转时可以附带参数,方式类比于GET方式的URL123String name = req.getParameter(&quot;name&quot;);PrintWriter output = resp.getWriter();resp.sendRedirect(&quot;http://localhost:8080/Test/Redirect_Para?name=&quot;+name); PS: 只能用转向方式来访问WEB-INF目录下的JSP,不用采用重定向的方式请求该目录里面的任何资源同一个请求周期中，HttpServletResponse的getWriter()与getOutputStream()只能择一使用，否则会丢出IllegalStateException","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Servlet  上传文件","slug":"Servlet上传文件","date":"2017-04-08T13:51:08.000Z","updated":"2017-04-08T14:00:18.459Z","comments":true,"path":"2017/04/08/Servlet上传文件/","link":"","permalink":"http://yoursite.com/2017/04/08/Servlet上传文件/","excerpt":"更改form的enctype属性enctype属性默认是application/x-www-form-urlencoded，发送文件时需要更改为multipart/form-data 发送一个图片时的http请求如下：","text":"更改form的enctype属性enctype属性默认是application/x-www-form-urlencoded，发送文件时需要更改为multipart/form-data 发送一个图片时的http请求如下：1234567891011121314151617POST /File/Photo HTTP/1.1Accept: text/html, application/xhtml+xml, */*X-HttpWatch-RID: 90747-10177Referer: http://localhost:8080/File/photo.htmlAccept-Language: zh-CNUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like GeckoContent-Type: multipart/form-data; boundary=---------------------------7e179f4038aAccept-Encoding: gzip, deflateHost: localhost:8080Content-Length: 566814DNT: 1Connection: Keep-AliveCache-Control: no-cache-----------------------------7e179f4038aContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;D:\\鍥剧墖\\Camera Roll\\b.jpg&quot;Content-Type: image/jpeg 表单如下:1234&lt;form action=&quot;/File/Photo_Stream&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&apos;file&apos; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt; 使用Part对象接受文件Part对象也可以获取http头部信息part.getHeader(“name”) ：获取头部信息中name对应的值part.write(fileName) ： 将part对象写入到文件中，文件的路径在 @MultipartConfig中配置 getHeader(“Content-Disposition”)的结果是： form-data; name=”file”; filename=”D:\\鍥剧墖\\Camera Roll\\b.jpg”因此可以根据Content-Disposition属性的值获取文件的名称 getPart(name)Part对象不需要通过构造函数创建，可以通过req.getPart()方法返回对应的文件对象1234567Part part = req.getPart(&quot;file&quot;);// 获取文件名String header = part.getHeader(&quot;Content-Disposition&quot;);String fileName = header.substring(header.indexOf(&quot;filename=\\&quot;&quot;)+10,header.length()-1);fileName = fileName.substring(3);// 写入到文件part.write(fileName); getParts()getParts() 返回所有的文件对象，返回类型是Collection集合。需要遍历集合才能处理所有文件 1234567891011Collection&lt;Part&gt; part = req.getParts();for(Part temp :part)&#123; String header = temp.getHeader(&quot;Content-Disposition&quot;); // 获取文件名 String fileName = header.substring(header.indexOf(&quot;filename=\\&quot;&quot;)+10,header.length()-1); output.println(&quot;&lt;br/&gt;Content-Disposition:&quot;+header); output.println(&quot;&lt;br/&gt;fileName:&quot;+fileName); fileName = fileName.substring(3); // 写入到文件 temp.write(fileName);&#125; @MultipartConfigTomcat中必须标注@MultipartConfig才能使用 Part @MultipartConfig可以设置上传文件的相关信息： fileSizeThreshold : 上传文件大小的门槛location : 配置文件的保存位置maxRequestSize : 设置请求个数，默认值为-1L，表示不限个数 12// 表示上传的文件在write()时保存到E盘@MultipartConfig(location=&quot;E:/&quot;) 也可以在web.xml中配置@MultipartConfig123456789101112&lt;servlet&gt; &lt;servlet-name&gt;Photo&lt;/servlet-name&gt; &lt;servlet-class&gt;Files.Photo&lt;/servlet-class&gt; &lt;multipart-config&gt; &lt;location&gt;E:/&lt;/location&gt; &lt;/multipart-config&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Photo&lt;/servlet-name&gt; &lt;url-pattern&gt;/Photo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 使用Part的InputStream可以使用Part的getInputStream()方法返回一个输入流，再使用传统的方式将输入流输出到文件 1234567891011121314151617181920protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;utf-8&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); // 获取part对象 Part part = req.getPart(&quot;file&quot;); // 获取输入流 InputStream data = part.getInputStream(); byte [] temp = new byte [1024]; FileOutputStream output = new FileOutputStream(new File(&quot;E:/s.jpg&quot;)); int len = 0 ; while(-1 != (len = data.read(temp)))&#123; output.write(temp, 0, len); &#125; output.flush(); output.close();&#125; 参考：JonnyWei的专栏","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Servlet入门","slug":"Servlet入门","date":"2017-04-06T14:29:26.000Z","updated":"2017-04-06T14:52:50.650Z","comments":true,"path":"2017/04/06/Servlet入门/","link":"","permalink":"http://yoursite.com/2017/04/06/Servlet入门/","excerpt":"JSP的运行周期：1，加载 ClassLoader2，实例化 调用构造函数创建对象3，初始化 init（ServletConfig）4，处理请求 service() doGet() doPost()5，退出服务 destroy()","text":"JSP的运行周期：1，加载 ClassLoader2，实例化 调用构造函数创建对象3，初始化 init（ServletConfig）4，处理请求 service() doGet() doPost()5，退出服务 destroy()PS: 对象只创建一次，init只调用一次，deGet()多次执行 获取参数response.setContentType(“text/html”);设置类型getParameter();获取name对应的第一个值getParameterValues(“name”); 获取所有name为”name”的值（数组）getParameterNames();获取所有name，返回Enumeration对象getParameterMap()返回name-value键值对 使用getParameterNames获取所有name1234567891011121314151617181920212223242526272829303132protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html; charset=utf-8\"); PrintWriter out = resp.getWriter(); out.println(\"&lt;html&gt;&lt;head&gt;&lt;title&gt;BookAdd&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\"); out.println(\"&lt;table border='1' align='center'&gt;\"); Enumeration&lt;String&gt; names = req.getParameterNames(); while(names.hasMoreElements())&#123; String name = names.nextElement(); String [] values = req.getParameterValues(name); out.println(\"&lt;/tr&gt;\"); out.println(\"&lt;td&gt;\"+name+\"&lt;/td&gt;\"); if(values.length == 1)&#123; out.println(\"&lt;td&gt;\"+values[0]+\"&lt;/td&gt;\"); &#125;else&#123; out.println(\"&lt;ul&gt;\"); for(int i = 0 ; i &lt; values.length; i++)&#123; out.println(\"&lt;li&gt;\"+values[i]+\"&lt;/li&gt;\"); &#125; out.println(\"&lt;/ul&gt;\"); &#125; out.println(\"&lt;/tr&gt;\"); &#125; out.println(\"&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\"); &#125; 使用getParameterMap()获取所有name的键值对1234567891011121314151617181920212223242526public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html charset='utf-8'\"); request.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); out.println(\"&lt;!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"&gt;\"); out.println(\"&lt;HTML&gt;\"); out.println(\" &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;\"); out.println(\" &lt;BODY&gt;\"); Map&lt;String,String []&gt; data = request.getParameterMap(); Enumeration&lt;String&gt; names = request.getParameterNames(); for(int i = 0 ; i &lt; data.size() ; i++)&#123; out.println(data.get(names.nextElement())[0]); &#125; out.print(\" This is \"); out.print(this.getClass()); out.println(\", using the POST method\"); out.println(\" &lt;/BODY&gt;\"); out.println(\"&lt;/HTML&gt;\"); out.flush(); out.close();&#125; 获取head参数getHeader(name)返回返回name对应的值getHeaders(name) 返回enumerationgetHeaderNames()返回http头部信息中的所有name。返回类型是Enumeration迭代器,getIntegerHeader()自动转换为int类型getDateHeader()自动转化为date类型 12345Enumeration&lt;String &gt; headNames = req.getHeaderNames(); // 获取所有namewhile(headNames.hasMoreElements())&#123; String name = headNames.nextElement(); out.println(name+&quot;:&quot;+req.getHeader(name)+&quot;&lt;br/&gt;&quot;); // 用getHeader获取name对应的值&#125;","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"CSS-精灵图","slug":"CSS-精灵图","date":"2017-03-24T14:18:47.000Z","updated":"2017-08-26T00:26:29.447Z","comments":true,"path":"2017/03/24/CSS-精灵图/","link":"","permalink":"http://yoursite.com/2017/03/24/CSS-精灵图/","excerpt":"之前就发现一些网站吧所有的小图标拼接在一张图片中，但是一直不知道这是怎么做到的，今天特地了解了一下，才知道这种用法叫做精灵图。他的优点是可以减少浏览器请求的次数，把所有图片拼接在一张图中就只需要请求一次，当浏览器需要用到图片时再从大图片中解析。这样可以加快访问的次数。先来看看效果图：","text":"之前就发现一些网站吧所有的小图标拼接在一张图片中，但是一直不知道这是怎么做到的，今天特地了解了一下，才知道这种用法叫做精灵图。他的优点是可以减少浏览器请求的次数，把所有图片拼接在一张图中就只需要请求一次，当浏览器需要用到图片时再从大图片中解析。这样可以加快访问的次数。先来看看效果图： 拼接的图片： 他的原理是，先规定好每个小图标的大小，创建一个和小图标大小相同的容器，再通过移动背景图片的方法将大图中需要的部分暴露在这个容器中。就是说这张图片就像被一块布遮住，只是在想要的地方留了一个空，好让背景图片暴露出来，这样只要将将背景图片一道合适的位置就可以只显示我们想要的部分。 具体步骤：1，创建合适大小的容器2，将拼接的大图作为容器的背景，并设置为no-repeat3，改变背景的位置 对于改变背景的位置我们需要知道小图标在大图片的的坐标（以大图的左上角为原点），例如如果小图标在大图中的坐标是(10,20)，那么将背景图片向左移动10px,向上移动20px就可以抵消小图标在大图的位置。获取这个坐标可以用PS中的切片工具，将小图标选择出来后右击选择编辑即可看到小图标的坐标 完整源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;html&gt; &lt;head&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .div0&#123; margin:10px; &#125; .demo1,.demo2,.demo3,.demo4,.demo5,.demo6&#123; display:inline-block; width:17px; height:17px; background-color:transparent; background-image:url(ico.png); background-repeat:no-repeat; &#125; .demo1&#123; background-position:-38px -37px;&#125; .demo2&#123; background-position:-62px -37px;&#125; .demo3&#123; background-position:-86px -37px;&#125; .demo4&#123; background-position:-110px -37px;&#125; .demo5&#123; background-position:-134px -37px;&#125; .demo6&#123; background-position:-159px -37px;&#125; ul&#123; list-style:none; &#125; ul li &#123; margin:10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div0&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt; 图标1&lt;/li&gt; &lt;li&gt;&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt; 图标2&lt;/li&gt; &lt;li&gt;&lt;div class=&quot;demo3&quot;&gt;&lt;/div&gt; 图标3&lt;/li&gt; &lt;li&gt;&lt;div class=&quot;demo4&quot;&gt;&lt;/div&gt; 图标4&lt;/li&gt; &lt;li&gt;&lt;div class=&quot;demo5&quot;&gt;&lt;/div&gt; 图标5&lt;/li&gt; &lt;li&gt;&lt;div class=&quot;demo6&quot;&gt;&lt;/div&gt; 图标6&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"javascript_操作表单","slug":"javascript-操作表单","date":"2017-03-24T14:17:58.000Z","updated":"2017-03-24T14:26:25.409Z","comments":true,"path":"2017/03/24/javascript-操作表单/","link":"","permalink":"http://yoursite.com/2017/03/24/javascript-操作表单/","excerpt":"获取表单1，getElementById()2，getElementsByTagName()3，documents.forms[] 每个form为一个数组元素4，document.forms[‘name’] 通过name获取5，docment.name 使用name直接获取。较方便。","text":"获取表单1，getElementById()2，getElementsByTagName()3，documents.forms[] 每个form为一个数组元素4，document.forms[‘name’] 通过name获取5，docment.name 使用name直接获取。较方便。 PS:event.preventDefault()：方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）IE: window.event.returnValue = false; 123456789function stopDefault(evt)&#123; var e = evt || window.event //非IE if(e &amp;&amp; e.preventDefault) e.preventDefault(); //IE else window.event.returnValue = false; &#125; 使用preventDefault() 阻止默认提交行为：1234window.onload = function()&#123;var submit = document.forms[0];submit.onsubmit = preventDefault; // 使用所在的表单调用submit函数&#125; 普通按钮实现提交事件（其他元素也可以）：1234var data = document.getElementById(&quot;button&quot;);data.onclick = function()&#123; document.forms[0].submit();&#125; 获取表单字段elements: 所有表单控件的集合，非表单控件会被忽略elements.length: 获取表单控件的数量name: 获取name属性值type: 获取控件的type属性，可以更改（不建议修改）form: 获取所在的form对象value: 获取表单控件的value值disabled: 关闭控件focus(): 自动将焦点移入blur(): 自动将焦点移出 也可以通过name获取获取表单控件： document.表单名.表单元素名 (在表单和控件都有name属性的情况下) 访问值： document.表单名.表单元素名.value 事件：blur 失去焦点时触发（鼠标点击）focus 获得焦点时触发change 文本框的文本改变时触发 也可以使用 elements[“name”] 获取表单控件元素,如果多个元素使用同一个name，则返回一个集合 12345678910window.onload=function()&#123; var form = document.forms[0].elements; alert(&quot;表单控件的数量: &quot;+form.length); // 3 alert(&quot;name: &quot; +form[0].name); // input alert(&quot;type: &quot; +form[0].type); // input alert(&quot;form: &quot; +form[0].form); // 对象 alert(&quot;form[0].value: &quot; +form[0].value); //twilight form[1].disabled = true; // 控件被禁用 form[0].focus(); // 加载完毕时自动获得焦点 &#125; 表单如下：12345&lt;form name=&quot;form1&quot; method=&quot;get&quot;&gt; 姓名: &lt;input type=&quot;text&quot; name=&quot;input&quot; size=10 /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot; id=&quot;button&quot; /&gt;&lt;/form&gt; 文本框脚本value 获取文本框中的值（HTML DOM）defaultValue 获取默认值select() 选定文本 textarea没有value属性，但是在js中可以用value获取textarea的文本内容 12345678function showValue()&#123; var data = document.forms[0].elements[0]; alert(data.value); // 获取文本框中的值 alert(data.defaultValue); // 获取默认值 data.select(); // 选定文本框中的文本 date.focus(); // 自动获得焦点 alert(&quot;文本框的内容：&quot;+document.forms[0].elements[1].value); // 通过value获得textarea的内容&#125; 赋值粘贴copy 复制时触发cut 剪切时触发paste 粘贴时触发beforecopy 复制前beforecut 剪贴前beforepaste 粘贴前 自动切换焦点12345678910111213141516171819202122232425262728 &lt;script&gt; window.onload = function()&#123; var form = document.forms[0]; var elem = form.elements; elem[0].onkeyup = transform; elem[1].onkeyup = transform; elem[2].onkeyup = transform; function transform(evt)&#123; var event = evt || window.event;// alert(this); var maxlength = this.maxLength; var length = this.value.length;// alert(maxlength+&quot;:&quot;+length); if(length==maxlength)&#123; for(var i=0;i&lt;form.length;i++)&#123; if(form[i] === this)&#123; form[++i].focus(); return; &#125; &#125; &#125; &#125; &#125; &lt;/script&gt; 123456&lt;form&gt; &lt;input type=&quot;text&quot; size=&quot;10&quot; maxlength=&quot;1&quot; /&gt; &lt;input type=&quot;text&quot; size=&quot;10&quot; maxlength=&quot;3&quot; /&gt; &lt;input type=&quot;text&quot; size=&quot;10&quot; maxlength=&quot;5&quot; /&gt; &lt;input type=&quot;text&quot; size=&quot;10&quot; maxlength=&quot;10&quot; /&gt;&lt;/form&gt; 下拉选择框通过elements获得对象1，multiple 多选2，selected 判断当前对象是否被选中（由option调用）3，options获取option集合4，value 选项的值5，text 选项标签中的文本6，selectedIndex 选中的索引（从0开始），默认是-1（可改变，会自动定位）（由select对象调用） options[selectIndex].value 获取选中的value 1234var form = document.form1; // 通过name获取表单var option = form.school.options; // 获取select标签下的option对象集合alert(option[0].value); // 获取第一个option对象的valuealert(form.school.selectedIndex); // 用selectedIndex获得选中的索引，由表单控件select对象调用 对于单选下拉框，可以用下面的方式获取选中的对象的值： document.form1.schools.value 但是对于复选下拉框，这种方法无法获得选中的值，schools是select标签上的name，但是对于复选下拉框会返回一个数组，数组内容是所有的option对象的集合 123alert(document.form1.schools.value); //可以直接获取单选下拉框中被选择的value，但是多选下拉框不可以alert(document.form1.schools[0].value); //对于复选下拉框，可用select对象获取option的valuealert(document.form1.schools[0].selected); //复选下拉框用selected判断是否被选择，而单选按钮用checked判断是否被选择 添加选项：用构造函数创建对象: var option = new Option(“text”,”value”)city.appendChild(option); 或者： add(对象，位置)—–IE : add(对象,undefined) 移除选项：remove(index); 互换位置insertBefore(对象，对象); 单选按钮用 document.myForm.gender 获得单选按钮数组 访问元素的值： document.myForm.gender[索引].value判断是否被选中： document.myForm.gender[索引].checked1234&lt;form name = “myForm” &gt; &lt;input type=“radio” name=“gender” value=“male”/&gt; &lt;input type=“radio” name=“gender” value=“female”/&gt;&lt;/form&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML-框架","slug":"HTML框架","date":"2017-03-24T14:17:23.000Z","updated":"2017-08-26T10:17:36.692Z","comments":true,"path":"2017/03/24/HTML框架/","link":"","permalink":"http://yoursite.com/2017/03/24/HTML框架/","excerpt":"frameset可以将页面划分为几个不同的区域，用以显示不同的页面,与frame混合使用，类似于select与option的关系。属性：1，cols 列数。一组用逗号分开的数值（可以用百分比数值，也可以用具体像素值），指定各子窗口的高度2，rows 行数。一组用逗号分开的数值（可以用百分比数值，也可以用具体像素值），指定各子窗口的宽度3，noresize 固定框架大小。不可移动 有框架的页面不可与body共同使用12345&lt;frameset cols=&quot;30%,30%,*&quot;&gt; &lt;frame src = &quot;http://baidu.com&quot;&gt;&lt;/frame&gt; &lt;frame src = &quot;http://www.sohu.com/&quot;&gt;&lt;/frame&gt; &lt;frame src = &quot;http://www.qq.com/&quot;&gt;&lt;/frame&gt;&lt;/frameset&gt;","text":"frameset可以将页面划分为几个不同的区域，用以显示不同的页面,与frame混合使用，类似于select与option的关系。属性：1，cols 列数。一组用逗号分开的数值（可以用百分比数值，也可以用具体像素值），指定各子窗口的高度2，rows 行数。一组用逗号分开的数值（可以用百分比数值，也可以用具体像素值），指定各子窗口的宽度3，noresize 固定框架大小。不可移动 有框架的页面不可与body共同使用12345&lt;frameset cols=&quot;30%,30%,*&quot;&gt; &lt;frame src = &quot;http://baidu.com&quot;&gt;&lt;/frame&gt; &lt;frame src = &quot;http://www.sohu.com/&quot;&gt;&lt;/frame&gt; &lt;frame src = &quot;http://www.qq.com/&quot;&gt;&lt;/frame&gt;&lt;/frameset&gt; 一种导航窗格的效果1234567&lt;frameset rows=&quot;30%,*&quot;&gt; &lt;frame src=&quot;frame/frame.html&quot;&gt;&lt;/frame&gt; &lt;frameset cols=&quot;30%,*&quot;&gt; &lt;frame src=&quot;frame/left.html&quot;&gt;&lt;/frame&gt; &lt;frame src=&quot;&quot; name=&quot;right&quot;&gt;&lt;/frame&gt; &lt;/frameset&gt;&lt;/frameset&gt; 在链接的target属性中可以写上指定框架的name，这样这个链接打开的页面会显示在指定的框架中123456789&lt;html&gt; &lt;body&gt; &lt;center&gt; &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;right&quot;&gt;百度&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://www.sohu.com/&quot; target=&quot;right&quot;&gt;搜狐&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://www.qq.com&quot; target=&quot;right&quot;&gt;腾讯&lt;/a&gt;&lt;br/&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"第一次晨跑","slug":"第一次晨跑","date":"2017-02-20T23:43:06.000Z","updated":"2017-06-28T08:05:45.986Z","comments":true,"path":"2017/02/21/第一次晨跑/","link":"","permalink":"http://yoursite.com/2017/02/21/第一次晨跑/","excerpt":"","text":"本学期的第一次晨跑，此时此刻记录下我现在的感觉：很累，从二期到三期我是跑着去的，回来就基本是走回来的了，来回大概花了25分钟，跑完后，腿很疼，浑身不自在，在食堂吃法时也没有胃口。感觉自己的体质还是太差，虽然不知道当时为什么一时冲动选了晨跑，但是现在看来还是很有必要的。听说很多人因为坚持不下来导致晨跑挂科，我不知道我能不能坚持到最后，但是，这第一天还是一个不错的开始。恩，就说这么多 2017-6-28日更新好吧，尴尬，这学期的体育课创下了入学以来的最低分，好在还及格了。及格万岁，及格万岁。。。。","categories":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/categories/日常/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]},{"title":"CSS_overflow-溢出","slug":"css_溢出","date":"2017-02-01T13:53:40.000Z","updated":"2017-03-23T13:05:18.979Z","comments":true,"path":"2017/02/01/css_溢出/","link":"","permalink":"http://yoursite.com/2017/02/01/css_溢出/","excerpt":"overflow 溢出 值 描述 visible 内容不会被修剪，会呈现在元素框之外。默认值 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。","text":"overflow 溢出 值 描述 visible 内容不会被修剪，会呈现在元素框之外。默认值 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 判断IE版本 不等于：[if !ie 8]小于：[if lt ie 5.5]大于：[if gt ie 5]小于或等于：[if lte ie 6]大于或等于：[if gte IE 7]大于和小于之间：[if (gt ie 5)&amp;(lt ie 7)]或：[if(ie 6)|(ie 7)]","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS_定位","slug":"CSS-定位","date":"2017-01-31T09:09:37.000Z","updated":"2017-08-26T00:39:43.849Z","comments":true,"path":"2017/01/31/CSS-定位/","link":"","permalink":"http://yoursite.com/2017/01/31/CSS-定位/","excerpt":"position属性 absolute： 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。","text":"position属性 absolute： 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。fixed： 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。relative： 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。static： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。inherit： 规定应该从父元素继承 position 属性的值。 相对定位设置为相对定位的元素框会偏移某个距离。元素仍然保持其未定位前的形状，它原本所占的空间仍保留。position:relative; 将 top 设置为 100px，框出现在在原位置顶部下面 100 像素的地方。将 left 设置为 50 px，那么会在元素左边创建 50 像素的空间，也就是将元素向右移动。 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;style&gt; .relative_left&#123; position:relative; left:50px; &#125; .relative_top&#123; position:relative; top:100px; &#125; div&#123; background:yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"relative_left\"&gt; 这是一个相对定位的段落，left:50&lt;/div&gt; &lt;div&gt;这是一个普通段落&lt;/div&gt; &lt;div class=\"relative_top\"&gt; 这是一个相对定位的段落，top:100px&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 绝对定位绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; .absolute&#123; position:absolute; left:200px; top:200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"absolute\"&gt;这是一个绝对定位的段落,他的位置是相对于原点(200,200)&lt;/p&gt; &lt;div style=\"position:absolute;left:100px;top:100px;\"&gt; &lt;p class=\"absolute\"&gt;这是一个绝对定位的段落，他相对于div的位置是(200,200),实际位置应该是(300,300)&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 所以绝对定位的位置也是相对的，相对于父元素的位置 z-index 属性z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴。如果为正数，则离用户更近，为负数则表示离用户更远。元素可拥有负的 z-index 属性值。 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; .z-index&#123; position:absolute; left:10px; z-index:-1; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img class=\"z-index\" src=\"素材/1.png\"&gt;&lt;img&gt; &lt;p&gt;这是一个普通段落&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 浮动float可能的值：|值|描述||:—-:|:—–:||left： |向左浮动||right： |向右浮动||none： |不浮动，默认值||inherit：| 继承| clearclear 属性规定元素的哪一侧不允许其他浮动元素。 值 描述 left 在左侧不允许浮动元素。 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 none 默认值。允许浮动元素出现在两侧。 inherit 规定应该从父元素继承 clear 属性的值。 1234567891011121314151617181920212223242526272829303132&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; .a&#123; float:left; clear:both; width:200; height:200; background-color:green; &#125; .b&#123; float:left; clear:both; width:200; height:200; background-color:blue; &#125; .d&#123; float:left; clear:both; width:200; height:200; background-color:gray; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;a&quot;&gt;&lt;/div&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;d&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如果需要完成以下的效果，可以在第二段之前加上一个外边距，将第二段挤到下方区域 当div中的元素都是浮动的时，因为内部元素不占据空间，所以div会变得非常小，并且不可见，为了看到div的效果，需要加上一个看不见的clear标记效果如图： 不过，还有一种法法可以避免这种问题，就是讲div进行浮动，这样div中就会显示出真实的大小。但是这样会影响下一个元素的样式。 1234567891011121314151617181920212223242526272829&lt;!--使用没有意义的clear元素--&gt;&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; .news &#123; background-color: yellow; border: solid 1px black; &#125; .news img &#123; float: left; &#125; .news p &#123; float: right; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"news\"&gt; &lt;img src=\"素材/1.png\" /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;!--没有意义的标记，但是可以看到浮动的div--&gt; &lt;div style=\"clear:both\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; display显示属性定义建立布局时元素生成的显示框类型 可能的值： none: 此元素不会被显示。block: 此元素将显示为块级元素，此元素前后会带有换行符。inline: 此元素会被显示为内联元素，元素前后没有换行符。默认。inline-block: 行内块元素。（CSS2.1 新增的值）list-item: 此元素会作为列表显示。run-in: 此元素会根据上下文作为块级元素或内联元素显示。compact: CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。marker: CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。table: 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。inline-table: 此元素会作为内联表格来显示（类似&lt;table&gt;），表格前后没有换行符。table-row-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。table-header-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。table-footer-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。table-row: 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。table-column-group: 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。table-column: 此元素会作为一个单元格列显示（类似 &lt;col&gt;）table-cell: 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;）table-caption: 此元素会作为一个表格标题显示（类似 &lt;caption&gt;）inherit: 规定应该从父元素继承 display 属性的值。 常见的块级元素有 DIV, FORM, TABLE, P, PRE, H1~H6, DL, OL, UL 等。常见的内联元素有 SPAN, A, STRONG, EM, LABEL, INPUT, SELECT, TEXTAREA, IMG, BR 等。 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;style&gt; .s&#123; display:block; &#125; .s2&#123; display:inline; &#125; p&#123; background:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p &gt;这是一个普通的段落&lt;/p&gt;&lt;p class=\"s\"&gt;这是一个块级段落&lt;/p&gt;&lt;p class=\"s2\"&gt;这是一个内联段落&lt;p&gt;&lt;/body&gt;&lt;/html&gt; 可见p元素是一个块级元素 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;style&gt; .s&#123; display:block; &#125; .s2&#123; display:inline; &#125; span&#123; background:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;span &gt;这是一个普通的段落&lt;/span&gt;&lt;span class=\"s\"&gt;这是一个块级段落&lt;/span&gt;&lt;span class=\"s2\"&gt;这是一个内联段落&lt;span&gt;&lt;span&gt;这是一个普通段落&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 块级段落前后会自带换行，而内联元素不会，他们会显示在一行内联元素不能定义宽度inline-block与block的区别在于inline-block可以控制大小，而且显示时像内联元素一样没有换行，排列在同一行中。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS_列表","slug":"CSS-列表","date":"2017-01-25T10:34:55.000Z","updated":"2017-01-25T10:36:13.349Z","comments":true,"path":"2017/01/25/CSS-列表/","link":"","permalink":"http://yoursite.com/2017/01/25/CSS-列表/","excerpt":"list-style-type改变列表项的标志。以下的所有的标志类型： none 无标记disc 实心圆，默认circle 空心圆square 方块decimal 数字","text":"list-style-type改变列表项的标志。以下的所有的标志类型： none 无标记disc 实心圆，默认circle 空心圆square 方块decimal 数字 decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。)lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。)upper-roman 大写罗马数字(I, II, III, IV, V, 等。)lower-alpha 小写英文字母(a, b, c, d, e, 等。)upper-alpha 大写英文字母(A, B, C, D, E, 等。)lower-greek 小写希腊字母(alpha, beta, gamma, 等。)lower-latin 小写拉丁字母(a, b, c, d, e, 等。)upper-latin 大写拉丁字母(A, B, C, D, E, 等。)hebrew 传统的希伯来编号方式armenian 传统的亚美尼亚编号方式georgian 传统的乔治亚编号方式(an, ban, gan, 等。)cjk-ideographic 简单的表意数字hiragana 标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）katakana 标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）hiragana-iroha 标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）katakana-iroha 标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名） 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; .disc&#123; list-style-type:disc; &#125; .circle&#123; list-style-type:circle; &#125; .square&#123; list-style-type:square; &#125; .decimal&#123; list-style-type:decimal; &#125; .lower-roman&#123; list-style-type:lower-roman; &#125; .lower-alpha&#123; list-style-type:lower-alpha; &#125; .lower-greek&#123; list-style-type:lower-greek; &#125; .lower-latin&#123; list-style-type:lower-latin; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=\"disc\"&gt;disc 实心圆，默认&lt;/li&gt; &lt;li class=\"circle\"&gt;circle 空心圆&lt;/li&gt; &lt;li class=\"square\"&gt;square 方块&lt;/li&gt; &lt;li class=\"decimal\"&gt;decimal 数字&lt;/li&gt; &lt;li class=\"lower-roman\"&gt;lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。) &lt;/li&gt; &lt;li class=\"lower-alpha\"&gt;lower-alpha 小写英文字母(a, b, c, d, e, 等。) &lt;/li&gt; &lt;li class=\"lower-greek\"&gt;lower-greek 小写希腊字母(alpha, beta, gamma, 等。) &lt;/li&gt; &lt;li class=\"lower-latin\"&gt;lower-latin 小写拉丁字母(a, b, c, d, e, 等。) &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; list-style-positioninside 列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside 默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。 1234567891011121314151617181920212223242526272829303132&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; .inside&#123; list-style-position:inside; &#125; .outside&#123; list-style-position:outside; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"inside\"&gt; &lt;li&gt;inside inside inside&lt;/li&gt; &lt;li&gt;inside inside inside&lt;/li&gt; &lt;li&gt;inside inside inside&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;normal normal normal&lt;/li&gt; &lt;li&gt;normal normal normal&lt;/li&gt; &lt;li&gt;normal normal normal&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"outside\"&gt; &lt;li&gt;outside outside outside&lt;/li&gt; &lt;li&gt;outside outside outside&lt;/li&gt; &lt;li&gt;outside outside outside&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; list-style-image以图片作为标志 list-style-image:url(url); none 无inherit 继承 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; .image&#123; list-style-image:url(\"素材/五角星.png\"); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"image\"&gt; &lt;li&gt;图片 图片 图片 &lt;/li&gt; &lt;li&gt;图片 图片 图片 &lt;/li&gt; &lt;li&gt;图片 图片 图片 &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; list-style简写，将所有属性按照一定顺序写在list-style后，可以不设置某个值，未设置的值将采用默认值。 li {list-style : url(example.gif) square inside}","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS_边框样式","slug":"CSS-边框样式","date":"2017-01-25T06:11:23.000Z","updated":"2017-01-25T06:13:32.241Z","comments":true,"path":"2017/01/25/CSS-边框样式/","link":"","permalink":"http://yoursite.com/2017/01/25/CSS-边框样式/","excerpt":"CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。 element : 元素。padding : 内边距，也有资料将其翻译为填充。border : 边框。margin : 外边距，也有资料将其翻译为空白或空白边。","text":"CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。 element : 元素。padding : 内边距，也有资料将其翻译为填充。border : 边框。margin : 外边距，也有资料将其翻译为空白或空白边。 padding 内边距padding 属性接受长度值或百分比值，但不允许使用负值。 可以按照上、右、下、左的顺序分别设置各边的内边距，各边均可以使用不同的单位或百分比值（相对父元素的width）： h1 {padding: 10px 0.25em 2ex 20%;} 1个值 表示4条边的边距 2个值 上 下 3个值 上 左右 下 4个值 上 下 左 右 也可以通过单独的属性指定： padding-方向(top/right/bottom/left) 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; .padding&#123; padding:10px 20px 30px 40px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td class=\"padding\"&gt;这个表格的内边距设置为padding:10px 20px 30px 40px; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; margin 外边距围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em。可以设置为 auto。更常见的做法是为外边距设置长度值 也可使用单个属性来表示外边距：margin-topmargin-rightmargin-bottommargin-left 123456789101112&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; p.s&#123; margin : 0 100px 20px 0px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"s\"&gt; 这个段落的外边距为： 0 100px 20px 0px;这个段落的外边距为： 0 100px 20px 0px;这个段落的外边距为： 0 100px 20px 0px;这个段落的外边距为： 0 100px 20px 0px;这个段落的外边距为： 0 100px 20px 0px;这个段落的外边距为： 0 100px 20px 0px;这个段落的外边距为： 0 100px 20px 0px;这个段落的外边距为： 0 100px 20px 0px;这个段落的外边距为： 0 100px 20px 0px;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 外边距合并外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 1.当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。请看下图： 2.当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。请看下图： 3.假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并： border-style 边框风格单独定义的 none 无边框hidden 对于表,可用于解决边框冲突。solid 实线dashed 虚线dotted 点状double 双线groove 凹槽边框ridge 垄状边框insertoutsertinherit 继承 使用单独属性表示样式：border-方向-style(left/right/bottom/top) 123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt; p.dotted &#123;border-style: dotted&#125; p.dashed &#123;border-style: dashed&#125; p.solid &#123;border-style: solid&#125; p.double &#123;border-style: double&#125; p.groove &#123;border-style: groove&#125; p.ridge &#123;border-style: ridge&#125; p.inset &#123;border-style: inset&#125; p.outset &#123;border-style: outset&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"dotted\"&gt;A dotted border&lt;/p&gt;&lt;p class=\"dashed\"&gt;A dashed border&lt;/p&gt;&lt;p class=\"solid\"&gt;A solid border&lt;/p&gt;&lt;p class=\"double\"&gt;A double border&lt;/p&gt;&lt;p class=\"groove\"&gt;A groove border&lt;/p&gt;&lt;p class=\"ridge\"&gt;A ridge border&lt;/p&gt;&lt;p class=\"inset\"&gt;An inset border&lt;/p&gt;&lt;p class=\"outset\"&gt;An outset border&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; border-width 边框宽度thin 细medium 中等thick 粗边框数字px 固定值inherit 继承 border-color 边框颜色rgb()rgba()transparent 透明inherit 继承","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS_文本样式","slug":"css_文本样式","date":"2017-01-24T13:26:40.000Z","updated":"2017-01-24T13:27:11.924Z","comments":true,"path":"2017/01/24/css_文本样式/","link":"","permalink":"http://yoursite.com/2017/01/24/css_文本样式/","excerpt":"text-align 水平对齐left/center/right左中右justify 两端对齐inherit 继承","text":"text-align 水平对齐left/center/right左中右justify 两端对齐inherit 继承 line-height 文本行间距行高不够时，行与行之间后重叠数字px 数字em数字% 基于字体大小的百分比 text-indent 缩进文本数字% 父元素的百分比数字px/数字em 固定值默认为0inherit继承 letter-spacing 字母间距normal 默认数字px 固定值（可为负值）inherit 继承 word-spacing 单词间距normal 标准间距数字px 固定值（可正可负）inherit 继承 direction 文本方向ltr 从左到右rtl 从右到左（类似右对齐）inherit 继承 text-transform 字符转换capitalize 每个单词首字母大写uppercase 全部大写lowercase 全部小写none 不做改动 text-decoration 文本装饰underline 下划线overline 上划线line-through 在文本中间的贯穿线blink 文本闪烁none 关闭原本应用到一个元素上的所有装饰 white-space 处理空白符normal 像正常的方式那样忽略换行和多余的空格pre 可以实现pre标签的样式，不忽略空格和换行nowrap 防止元素换行pre-wrap 不仅会保留空白符并保留换行符，还允许自动换行pre-line 保留换行符，并允许自动换行，但是会合并空白符，这是与 pre-wrap 值的不同之处。 他们的区别总结如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; p.normal&#123; white-space:normal; &#125; p.pre&#123; white-space:pre; &#125; p.nowrap&#123; white-space:nowrap; &#125; p.pre-wrap&#123; white-space:pre-wrap; &#125; p.pre-line&#123; white-space:pre-line; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"normal\" &gt;normal: This is a normal line This paragraph has many spaces in it &lt;/p&gt; &lt;p class=\"pre\" &gt;pre: This is a normal line This paragraph has many spaces in it &lt;/p&gt; &lt;p class=\"nowrap\" &gt;newrap: This is a normal line This paragraph has many spaces in it &lt;/p&gt; &lt;p class=\"pre-wrap\" &gt;pre-wrap: This is a normal line This paragraph has many spaces in it &lt;/p&gt; &lt;p class=\"pre-line\" &gt;pre-line: This is a normal line This paragraph has many spaces in it &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS_背景","slug":"CSS-背景","date":"2017-01-24T09:08:22.000Z","updated":"2017-01-24T09:09:44.418Z","comments":true,"path":"2017/01/24/CSS-背景/","link":"","permalink":"http://yoursite.com/2017/01/24/CSS-背景/","excerpt":"background-color 背景颜色可以用padding指定颜色的边距","text":"background-color 背景颜色可以用padding指定颜色的边距1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;style text/css\"&gt; .s1&#123; background-color:red; &#125; .s2&#123; background-color:blue; padding:20px; &#125; .s3&#123; background-color:yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body class=\"s3\"&gt; &lt;p class=\"s1\"&gt;红色的段落&lt;/p&gt; &lt;p class=\"s2\"&gt;蓝色的段落，20px的外边距&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; background-image 背景图片background-image:url(路径) 1234567891011&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; .s1&#123; background-image:url(\"素材/1.png\"); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body class=\"s1\"&gt; &lt;/body&gt;&lt;/html&gt; background-repeat 重复repeat 全部重复repeat-x 沿着x重复repeat-y 沿着y重复no-repeat background-position 重复位置top 上bottom 下left 左right 右center 中间用数值表示位置：mpx npx(x,y)用百分数表示 123456&lt;!--表示图片位置在水平2/3，竖直1/3处--&gt; .s1&#123; background-image:url(\"素材/1.png\"); background-repeat:no-repeat; background-position: 66% 33%; &#125; background-attachment 背景图像是否固定或者随着页面的其余部分滚动。当background-attachment 的值为fixed时，随着页面的滚动图片的位置不会改变","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS(颜色_字体)","slug":"CSS-颜颜色-字体","date":"2017-01-24T07:35:40.000Z","updated":"2017-01-24T07:41:37.940Z","comments":true,"path":"2017/01/24/CSS-颜颜色-字体/","link":"","permalink":"http://yoursite.com/2017/01/24/CSS-颜颜色-字体/","excerpt":"颜色样式十六进制十六进制颜色是这样规定的：#RRGGBB，其中的 RR（红色）、GG（绿色）、BB（蓝色）十六进制整数规定了颜色的成分。所有值必须介于 0 与 FF 之间。所有浏览器都支持十六进制颜色值。 RGBRGB 颜色值是这样规定的：rgb(red, green, blue)。每个参数 (red、green 以及 blue) 定义颜色的强度，可以是介于 0 与 255 之间的整数，或者是百分比值（从 0% 到 100%）。所有浏览器都支持 RGB 颜色值。","text":"颜色样式十六进制十六进制颜色是这样规定的：#RRGGBB，其中的 RR（红色）、GG（绿色）、BB（蓝色）十六进制整数规定了颜色的成分。所有值必须介于 0 与 FF 之间。所有浏览器都支持十六进制颜色值。 RGBRGB 颜色值是这样规定的：rgb(red, green, blue)。每个参数 (red、green 以及 blue) 定义颜色的强度，可以是介于 0 与 255 之间的整数，或者是百分比值（从 0% 到 100%）。所有浏览器都支持 RGB 颜色值。 rgb(0,0,255) 和 rgb(0%,0%,100%)。同样表示蓝色 RGBARGBA 颜色值是这样规定的：rgba(red, green, blue, alpha)。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。 字体font-size: 字体大小数字px(像素);数字%(父元素的百分比,可以大于100%)数字em（与父元素的百分比，浏览器默认是16px。1em表示与父元素相同）smaller 比父元素更小larger 比父元素大inherit 及集成父元素的大小 如图： font-family: 字体后可以加上多个字体，字体与字体之间用逗号隔开。按从左往右的顺序读取，当左边不存在时使用右边的字体。为避免乱码时无法读取汉字，最好使用英文字体名 如图： font-weight: 加粗normal 400 默认值bold 700 粗bolder 更粗lighter 更细100~900的整百数字 如图： font-style: 字体样式（主要用来倾斜字体）normal 正常italic 斜体oblique 倾斜(与italic效果类似)inherit 继承 如图： font-variant: 小型大写字体或者正常字体显示文本。normal 正常small-capsinhert 继承 如图：","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS_选择器","slug":"CSS-选择器","date":"2017-01-23T13:56:37.000Z","updated":"2017-01-23T13:57:58.550Z","comments":true,"path":"2017/01/23/CSS-选择器/","link":"","permalink":"http://yoursite.com/2017/01/23/CSS-选择器/","excerpt":"类选择器class 属性规定元素的类名（classname）类选择器以一个点号显示 .center {text-align: center} class类似一个标记。“p.类名”表示标记了该类的p标签的样式，这个类的样式只能被p使用。即 p class=”标记名”","text":"类选择器class 属性规定元素的类名（classname）类选择器以一个点号显示 .center {text-align: center} class类似一个标记。“p.类名”表示标记了该类的p标签的样式，这个类的样式只能被p使用。即 p class=”标记名”而”.类名”表示元素也可以基于它们的类而被选择，所有标签都可以包含这个类*.important {color:red;}.important {color:red;}以上两者相等 一个标签可以包含多个类，包含多个类时用空格隔开，不分先后 当两个类有各自的样式，可以有同时包含两个类时才出现的样式 .important.warning {background:silver;} 123456789101112131415161718192021222324252627&lt;!--实例--&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;meta name=\"description\" content=\"\"/&gt; &lt;meta http-equiv=\"content-type\" content=\"type/html;charset=htf-8\"/&gt; &lt;style type=\"text/css\"&gt; &lt;!--元素基于它们的类而被选择--&gt; p.try1 &#123; color:blue; &#125; &lt;!--所有元素都可使用--&gt; .try2 &#123; text-align:center; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是单独的段落&lt;/p&gt; &lt;p class=\"try1 try2\"&gt;这是在\"class=try1 try2\"的段落&lt;/p&gt; &lt;h1 class=\"try2\"&gt;这是标题，class=try2&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526&lt;!--两个标记同时存在时的特殊样式--&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;meta name=\"description\" content=\"\"/&gt; &lt;meta http-equiv=\"content-type\" content=\"type/html;charset=htf-8\"/&gt; &lt;style type=\"text/css\"&gt; .s1&#123; color:red; &#125; .s2&#123; font-size:20px; &#125; .s1.s2&#123; font-style:italic; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"s1\"&gt; 段落s1&lt;/p&gt; &lt;p class=\"s2\"&gt; 段落s2&lt;/p&gt; &lt;p class=\"s1 s2\"&gt; 段落s1 s2 &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; class 也可被用作派生选择器： 12345678&lt;style type=\"text/css\"&gt; .s1 h1 &#123; font-size:10px; &#125; .s1 h2 &#123; background: #666; &#125;&lt;/style&gt; ID选择器id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。id 选择器以 “#” 来定义。例如： #red {color:red;}#green {color:green;} 在现代布局中，id 选择器常常用于建立派生选择器。 #sidebar p { font-style: italic; text-align: right; margin-top: 0.5em; } 上面的样式只会应用于出现在 id 是 sidebar 的元素内的段落。ID区分大小写即使被标注为特定ID的元素只能在文档中出现一次，这个 id 选择器作为派生选择器也可以被使用很多次：例如：12345678&lt;style type=\"text/css\"&gt;#s h2&#123; color:red;&#125;#s h1&#123; color:blue;&#125;&lt;/style&gt; 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;meta name=\"description\" content=\"\"/&gt; &lt;meta http-equiv=\"content-type\" content=\"type/html;charset=htf-8\"/&gt; &lt;style type=\"text/css\"&gt; #red &#123; color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=\"red\"&gt;这是ID=red的段落&lt;/p&gt; &lt;p&gt;这是普通段落&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 选择器的分组同时控制多个标签h1,h2,p{} 伪元素选择器a:link 正常样式a:hover 鼠标放上的样式a:active 鼠标按下时的样式a:visited 访问过的样式 优先级问题ID &gt; class &gt; html 派生选择器后代选择器1234li strong &#123; font-style: italic; font-weight: normal; &#125; 以上的代码表示在列表（li）中的strong标记所具有的样式。当strong单独使用时不具有以上样式。类似于 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;meta name=\"description\" content=\"\"/&gt; &lt;meta http-equiv=\"content-type\" content=\"type/html;charset=htf-8\"/&gt; &lt;style type=\"text/css\"&gt; li strong &#123; font-style: italic; font-weight: normal; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;strong&gt;This is a normal Strong&lt;/strong&gt; &lt;ul&gt; &lt;li&gt;&lt;strong&gt;This is a Strong in li&lt;/strong&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;meta name=\"description\" content=\"\"/&gt; &lt;meta http-equiv=\"content-type\" content=\"type/html;charset=htf-8\"/&gt; &lt;style type=\"text/css\"&gt; strong &#123; color: red; &#125; h2 &#123; color: red; &#125; h2 strong &#123; color: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;strong&gt;这是普通的strong&lt;/strong&gt; &lt;h2&gt;这是普通的h2&lt;/h2&gt; &lt;h2&gt;&lt;strong&gt;这是h2中的strong&lt;/strong&gt;&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; 子元素选择器h1 &gt; strong {color:red;}只将h1下一层的strong使用该样式。”&gt;”两端可以没有空格 与后代选择器的区别：个人认为可以将所有标签看成一个树结构后代选择器的范围包含孩子和孙子节点。子元素选择器的范围只包含孩子节点。 12345678910111213141516171819&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;meta name=\"description\" content=\"\"/&gt; &lt;meta http-equiv=\"content-type\" content=\"type/html;charset=htf-8\"/&gt; &lt;style type=\"text/css\"&gt; h1 &gt; strong &#123; color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是&lt;strong&gt;第一个&lt;/strong&gt;&lt;/h1&gt; &lt;h1&gt;这是&lt;p&gt;&lt;strong&gt;第二个&lt;/strong&gt;&lt;/p&gt;strong&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 相邻兄弟选择器h1+p{clolr:blue;}二者有相同父元素则称为兄弟。紧贴在h1后的p，并且h1和p具有相同父节点。则使用该样式 1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt;h1 + p &#123;color:blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is a heading.&lt;/h1&gt;&lt;p&gt;This is paragraph.&lt;/p&gt;&lt;p&gt;This is paragraph.&lt;/p&gt;&lt;p&gt;This is paragraph.&lt;/p&gt;&lt;p&gt;This is paragraph.&lt;/p&gt;&lt;p&gt;This is paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Tips HTML div标签可定义文档中的分区或节（division/section）,把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"html_表单","slug":"html-表单","date":"2017-01-21T05:41:20.000Z","updated":"2017-08-26T10:15:02.287Z","comments":true,"path":"2017/01/21/html-表单/","link":"","permalink":"http://yoursite.com/2017/01/21/html-表单/","excerpt":"客户端和服务端信息交流的途径 form创建一个表单，容器，表单元素必须在form种才能起作用。action: 规定当提交表单时，向何处发送表单数据。action=URL(传递目标，处理表单信息的服务器端应用程序)","text":"客户端和服务端信息交流的途径 form创建一个表单，容器，表单元素必须在form种才能起作用。action: 规定当提交表单时，向何处发送表单数据。action=URL(传递目标，处理表单信息的服务器端应用程序)method: 规定如何发送表单数据(POST/GET)name: 规定表单的名称。target: _blank/_parent/_self/_top/framename 规定在何处打开 action URL。 post 传递大量信息get将值附加在URL后适合传递少量信息 input定义输入域，用户可在其中输入数据。type和name属性是必须的，其他属性是可选的（所有表单元素都是这样）没有结束标签 单行文本框input name=’text’value=’初始值’size=’显示字符数’maxlength=’最多容纳字符数’readonly=’readonly’只能读，不可修改disabled=’disabled’不可操作 密码框input type=’password’ value=’初始值’ size=’显示字符数’与文本框类似 单选框input type=’radio’ value 单选框的值name 名称，不同的选项名称必须相同checked 默认选中(checked=’checked’) 下拉框&lt;select name=’下拉框名称’&gt;&lt;option selected=’selected’ value=’项目的值’&gt;列表显示的值&lt;/option&gt;&lt;/select&gt; 下拉分组: &lt;optgroup label=’分组名称’&gt;&lt;/optgroup&gt; size 显示的行数multiple是否允许多选 1234567 籍贯： &lt;select size='3' multiple='multiple'&gt;&lt;option&gt;合肥&lt;/option&gt;&lt;option&gt;南京&lt;/option&gt;&lt;option&gt;合肥&lt;/option&gt;&lt;option&gt;南京&lt;/option&gt; &lt;/select&gt; 多选框input type=”checkbox” name=”Car” value 项目的值name必须相同 文件上传input type=’file’ 按钮input type=’submit’ 提交input type=’reset’重置(清空所有输入的内容)input type=’button’普通按钮 123&lt;input type='submit' value='提交2'&gt;&lt;input type='reset' value='重置2'&gt;&lt;input type='button'value='普通按钮'&gt; 文本域&lt;textarea&gt;… &lt;/textarea&gt;cols =’每行显示的字符数’rows =’每列显示的字符数’ 1&lt;textarea cols='15' rows='6'&gt; &lt;/textarea&gt; 隐藏域input type=’hidden’看不见的组件 表单外框fieldset 定义围绕在表单周围的边框legend 标题 1234567&lt;fieldset&gt; &lt;legend&gt;性别&lt;/legend&gt; &lt;label for='man'&gt;男&lt;/label&gt; &lt;input type='radio' value='man' id='man' name='sex'&gt; &lt;label for='women'&gt;女&lt;/label&gt; &lt;input type='radio' value='women' id='women' name='sex'&gt;&lt;/fieldset&gt; 标注内容label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。 label标签的 for 属性应当与相关元素的 id 属性相同。 12345性别: &lt;label for='man'&gt;男&lt;/label&gt;&lt;input type='radio' value='man' name='sex' id='man' checked='checked'&gt; &lt;label for='women'&gt;女&lt;/label&gt;&lt;input type='radio' value='women' name='sex' id='women' &gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML_meta_body","slug":"html_meta_body","date":"2016-12-29T12:09:00.000Z","updated":"2017-08-26T10:14:54.675Z","comments":true,"path":"2016/12/29/html_meta_body/","link":"","permalink":"http://yoursite.com/2016/12/29/html_meta_body/","excerpt":"文档结构&lt; html\\&gt;…&lt;/html&gt; 表示网页的开始和结束&lt;head\\&gt;…&lt;/head&gt; 网页文件的头部信息：标题、搜索引擎关键字","text":"文档结构&lt; html\\&gt;…&lt;/html&gt; 表示网页的开始和结束&lt;head\\&gt;…&lt;/head&gt; 网页文件的头部信息：标题、搜索引擎关键字&lt;body\\&gt;…&lt;/body&gt; 网站主体 title 表示网页顶端的网页标题 meta标记用于定义文件信息，置于head 和 /head之间&lt;meta name=”keywords” content=”value”&gt;表示关键字&lt;meta name=”description” content=”value”&gt;描述网页的内容，是上面keywords的扩展&lt;meta name=”autor” content=”作者名”&gt;&lt;meta http-equiv=”content-type” content=”text/html;charset=gb2312”&gt;国内网站用GB2312，国际用utf-8text/html;charset=gb2312一个声明代码，指明这个是文本方式的网页文件，语言是 中文&lt;meta http-equiv=”refresh” content=”2;URL=http://www.baidu.com&quot;/&amp;gt;自动刷新 ，2表示时间 http-equiv中的属性：content-type 规定文档的字符编码。default-style 规定要使用的预定义的样式表?refresh 定义文档自动刷新的时间间隔。 body注释：&lt;!–注释–&gt; html元素-html标签-html标记 不推荐使用：bgcolor 背景颜色background 背景照片text 文字颜色leftmargin 左边距rightmargin 右边距topmargin 上边距bottommargin 下边距 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;meta name=\"description\" content=\"\"/&gt; &lt;meta http-equiv=\"content-type\" content=\"type/html;charset-htf-8\"/&gt; &lt;/head&gt; &lt;body background='1.png' bgcolor='black' background text='white' leftmargin=\"0\" rightmargin=\"0\" topmargin=\"0\" bottommargin='0' &gt; &lt;p&gt;This is a pharagraph&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; Tips 标记的属性：&lt;标记 属性1=参数1属性2=参数2 。。。&gt;内容&lt;/标记&gt;属性之间用空格分隔，属性不分先后且不是必须的。html不区分大小写，xhtml全部小写 属性和属性之间用空格隔开所有的标记都要关闭&lt;b&gt;加粗&lt;font color=”red” size=”7”&gt;内容 &lt;/font&gt;size(1~7) &lt;hr width=”50%” /&gt; 水平线","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"初识JavaScript","slug":"初识JavaScript","date":"2016-12-21T15:57:58.000Z","updated":"2016-12-29T10:56:15.690Z","comments":true,"path":"2016/12/21/初识JavaScript/","link":"","permalink":"http://yoursite.com/2016/12/21/初识JavaScript/","excerpt":"1. 以 &lt; script&gt;开头，以&lt;/script&gt;结尾,老式的浏览器中需要加上language，如： &lt; script language = “javascript” /script&gt; 表示该脚本是JavaScript，也可以写上其他脚本的名字。","text":"1. 以 &lt; script&gt;开头，以&lt;/script&gt;结尾,老式的浏览器中需要加上language，如： &lt; script language = “javascript” /script&gt; 表示该脚本是JavaScript，也可以写上其他脚本的名字。 2. JavaScript每条语句必须以冒号结尾。document.write();向页面上输出内容。 document.write(“hello!”); 1234// 在屏幕中输出加粗的hello&lt;script&gt; document.write(\"&lt;strong&gt;hello &lt;/strong&gt;\");&lt;/script&gt; 3.变量用 var+变量名 声明一个变量 可以不考虑变量的类型。所有类型都用var来声明。常用的类型有： var a = 16; //数字var falg = true; //布尔型var s = “hello”//字符串型 123456//字符串的相加运算&lt;script&gt; var a = \"abc\"; a += 'd'; document.write(a);&lt;/script&gt; 结果是abcd。 123456//html中将多个空格当成一个来处理&lt;script&gt; var s = 'hello '; s += ' world'; document.write(s);&lt;/script&gt; 结果是: hello world 4.运算 常见的运算符在JavaScript中都有，例如：加减乘除： +-*\\ %自加自减：++ –加法：+= -=逻辑： &amp;&amp; || ？： ！判断： ==（类似于C语言）字符串比较大小： &gt; &lt; == (小写字母大于大写字母) 5.注释 和C语言一样用//或/* */ 表示 6.判断与C语言基本相同 建议每一条if语句都加上{} 12345678910//不加括号时，else属于较近的if&lt;script&gt; var s = 'hello'; if (s == 'hello') if(s == 'world') document.write('world'); else document.write(s);&lt;/script&gt; 7.循环和c语言一样for(;;)while()do while() 8.函数function fun_name(形参){函数体}函数也被当成是一种类型，有时可以像变量一样使用 123456//定义一个函数function add(a,b)&#123; return a+b;&#125;//使用函数alert('加:'+add(1,2)) 12345678910111213//将函数类似于变量的用法function add(a,b)&#123; return a+b;&#125;function cal(x,y,z)&#123; return x(y,z);&#125;//将函数作为参数alert(cal(add,1,2)); 9.数组数组可以使用以下方法建立：1 var a = new Array();2 var b = new Array(10);3 var c = new Array(1,2,3,4,5);4 var d = [6,7,8,9,10]; 数组的特点：1，数组中的元素使用时才会被创建，即使创建了a[1]和a[10]，中间的元素依然是空。2，数组的长度a.length为最大的下标加1，不管中间的元素是否存在。3，数组的长度是可以人为修改的。修改后不属于长度内的元素会被清除。 123456//var a = new Array();a[1] = 10;a[10] = 20;document.write(a[9]+\"&lt;br/&gt;\");document.write(a.length); 在这里会输出：undefined11 换行只能在输出后面加上&lt; br/&gt; ，c中的\\n在这里不起作用 123456789//人为改变数组长度，等同于截取数组中的一段var a = new Array(1,2,3,4,5);document.write(a.length+\"&lt;br/&gt;\");a.length = 3;document.write(a+\"&lt;br/&gt;\");a.length = 5;document.write(a); 结果如下：51,2,31,2,3,, join(“&amp;”) 表示认为的改变输出时元素的分隔符如： document.write(a.join(“%”)); 会输出 1%2%3 10.栈和队列 对于数组a 栈： a.push(); 入栈 a.pop(); 出栈 队列： a.push() 入队 a.pop() 出队 一些方法： a.sort([可以自定义方法]) 排序 a.reserve() 倒序输出 a.concat() 连接 splice(开始位置，删除个数，插入位置) ??? 例：a.concat(6,7,8,9); 11.对象 声明：var o = new Object();var cidr = {x:2,y:0,radius:2}; 对象的元素是在使用时添加进类中的，第一次使用时就会自动为该类创建这个成员 删除属性：delete book.name;book.name=null; 遍历属性：for(var x in book ){ x是成员的名字，用法类似于数组的下标} 构造函数:…. 共享成员： 123456var book = new Object();book.name = '百年孤独';book.about = &#123;name:'马尔克斯',price:100&#125;;document.write(book.name+'&lt;br/&gt;');document.write(book.about.name); 结果：百年孤独马尔克斯 123456789var book = new Object();book.name = '百年孤独';book.about = &#123;name:'马尔克斯',price:100&#125;;//遍历for (var x in book )&#123; document.write(book[x]);&#125; 12.window 外部javascript文件&lt; script src = “url”&gt; &lt; /script&gt; 1&gt; &lt; p onMouseOver=”alert(‘Hi’);”\\&gt;abc&lt;/p&gt;&lt;p onMouseOut=”alert(‘bye’);”\\&gt;abc&lt;/p&gt; 12345678//鼠标移入段落时弹出in，移出段落时弹出out&lt;pre onmouseover=\"alert('in');\" onmouseout=\"alert('out');\"&gt;This is a pharagraphThis is a pharagraphThis is a pharagraphThis is a pharagraph&lt;/pre&gt; onLoad加载完后onUnload关闭之前 confirm(“string”)var name = prompt(“name is :”);确定则返回输入的内容，取消则返回空 123456&lt;script&gt;if(confirm(\"要不要继续?\"))&#123; alert(\"欢迎\");&#125;elsealert(\"再见\");&lt;/script&gt; 12var name = prompt(\"name:\");alert(name); status = “str” 在现实url的地方显示strdefaultStatus setInterval(函数,时间); window.open(); 打开一个新的窗口var w = window.open(“内容”,“窗口名字”，“参数”);//返回一个window对象，先判断浏览器中是否已经存在这个网页就直接跳转过去window.close();关掉自己w.moveTo(0,0); 123if(confirm(\"new one ?\"))&#123; open(\"D:/Code/HTML/图片.html\",\"new\");&#125; window.location当前文档的url 可以改写他，改写过后当前窗口会跳转到新的url 12var s =\"https://\" + prompt(\"请输入要跳转的页面:\");location(s);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Java网络编程","slug":"网络编程","date":"2016-12-10T08:48:20.000Z","updated":"2016-12-28T12:30:45.175Z","comments":true,"path":"2016/12/10/网络编程/","link":"","permalink":"http://yoursite.com/2016/12/10/网络编程/","excerpt":"端口号两个字节，范围0~65535 1、在同一个协议下端口号不能重复2、1024以下的端口号不要使用","text":"端口号两个字节，范围0~65535 1、在同一个协议下端口号不能重复2、1024以下的端口号不要使用 URL统一资源定位符 URI 统一资源 数据的传输1、协议 TCP/UDP 1) TCP（transfer control protocol） 面向连接 安全可靠，效率低下 2) UDP（userDatagram Protocol） 非面向连接 效率高 数据可能丢失 2、数据 先封装/后拆分 1、InetAddress InetSockAddress2、URL3、TCP：serverSocker Socket4、UDP：DatagramSocket DatagramPacket InetAddress 表示互联网的IP地址getHostAddress()返回IP地址getHostName() 返回域名/本机为计算机名InetAddress.getLocalHost()返回本机地址InetAddress.getByName(“192.168.1.1”); ip/域名 1234567891011121314// InetAddress public static void main (String [] args) throws UnknownHostException&#123; InetAddress inet = InetAddress.getLocalHost(); System.out.println(inet.getHostName()); System.out.println(inet.getHostAddress()); inet = InetAddress.getByName(&quot;twilight.net.cn&quot;); System.out.println(inet.getHostName()); System.out.println(inet.getHostAddress()); inet = InetAddress.getByName(&quot;151.101.16.133&quot;); System.out.println(inet.getHostName()); System.out.println(inet.getHostAddress()); &#125; InetSocketAddress 套接字（ip + 端口号） SocketAddress是一个抽象类，类中没有方法 1、创建对象 InetSocketAddress(InetAddress addr,int port)根据主机名和端口号创建套接字地址。InetSocketAddress(InetAddress addr, int port)根据 IP 地址和端口号创建套接字地址。InetSocketAddress(int port)创建套接字地址，其中 IP 地址为通配符地址，端口号为指定值。 2、方法 getAddress() 获取InetAddressgetHostName() 计算机名getHostAddress() 返回地址getPort() 获得端口号 //InetSocketAddress public static void main(String[] args) throws UnknownHostException { InetSocketAddress net = new InetSocketAddress(&quot;127.0.0.1&quot;, 2000); System.out.println(net.getPort()); System.out.println(net.getHostName()); System.out.println(net.getAddress().getHostAddress()); } URL组成： 协议+存放资源的主机域名+端口+资源名 创建：URL(String apec) 绝对路径构建URL (URL context,String s) 相对路径构建URL(String protocol, String host, int port, String file) 根据指定 协议、主机号、端口号、和文件创建 URL 对象。 getProtocol() 获取协议getHost() 获取主机名getPort() 获取端口getFile() 获取文件名getPath() 获取getRef() 锚点锚点getQuery() 获取查询部分（参数存在锚点返回null，不存在返回正确） 123456789public static void main (String [] args) throws MalformedURLException&#123; URL address = new URL(\"http://www.baidu.com:80/index.html#abc\"); System.out.println(\"协议\" + address.getProtocol()); System.out.println(\"文件名\"+address.getFile()); System.out.println(\"主机\"+address.getHost()); System.out.println(\"端口\"+address.getPort()); System.out.println(\"路径\"+address.getPath()); System.out.println(\"锚点\"+address.getRef());&#125; 运行结果：协议 http文件名 /index.html主机 www.baidu.com端口 80路径 /index.html锚点 abc 获取资源：主页/默认资源InputStream openStream() 获取网络流 123456789101112131415public static void main (String [] args) throws IOException&#123; URL address = new URL(\"https://www.baidu.com/index.html\"); BufferedReader input = new BufferedReader(new InputStreamReader(address.openStream(),\"utf-8\")); BufferedWriter output = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"url_1.html\"),\"utf-8\")); int len = 0; byte [] data = new byte[100]; String s = null; while(null != (s = input.readLine()))&#123; output.append(s); output.newLine(); output.flush(); &#125; input.close(); output.close();&#125; 对于乱码，目前两种解决方法：1：用InputStreamReader转换流 InputStreamReader( inputstream s ,charset ) 例： BufferedReader input = new BufferedReader(new InputStreamReader(address.openStream(),”utf-8”)); 2：用String的构造函数String(byte[] ,charset )将字符数组转化成对应的编码 例：System.out.println(new String (data,”utf-8”)); UDPUDP以数据为中心，不安全，数据可能丢失，效率高 DatagramSocket DatagramPacket1 客户端 1&gt;创建DatagramSocket类 + 指定端口2&gt;数据 字节数组3&gt;打包 DatagramPacket 服务器地址端口4&gt;发送5&gt;释放资源 2 服务器端 1&gt;创建服务端 DatagramSocket2&gt;准备接受容器，字节数组，封装DatagramPacket3&gt;包接受数据4&gt;分析5&gt;释放 DatagramSocket构造函数：此类表示用来发送和接收数据报包的套接字。 DatagramSocket()构造数据报套接字并将其绑定到本地主机上任何可用的端口。DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。DatagramSocket(int port, InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。DatagramSocket(SocketAddress bindaddr)创建数据报套接字，将其绑定到指定的本地套接字地址。 DatagramPacket 构造函数:此类表示数据报包。 接收：DatagramPacket(byte[] buf, int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 发送:DatagramPacket(byte[] buf, int length, InetAddress address, int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。DatagramPacket(byte[] buf, int length, SocketAddress address)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号 12345678910// 客户端 ublic class testUDPclient &#123; public static void main(String[] args) throws IOException &#123; DatagramSocket output = new DatagramSocket(1234); byte [] data = \"UDP数据\".getBytes(); DatagramPacket packet = new DatagramPacket(data,data.length,new InetSocketAddress(\"localhost\",2000)); output.send(packet); output.close(); &#125;&#125; 123456789101112131415 // 服务器端 public class testUDPserver &#123; public static void main (String [] args) throws IOException&#123; DatagramSocket input = new DatagramSocket(2000); byte [] data = new byte[1024]; DatagramPacket packet = new DatagramPacket(data,data.length); input.receive(packet); byte [] info = new byte [1024] ; info = packet.getData(); int len = packet.getLength(); System.out.println(\"已收到：\"+new String (info,0,len)); input.close(); &#125;&#125; 发送double类型的数据： 123456//服务器端，将接受的流转换为double型 private static double convert (byte [] data) throws IOException&#123; DataInputStream input = new DataInputStream( new ByteArrayInputStream(data)); double s = input.readDouble(); return s; &#125; 123456789//客户端，将带发送的double型转换为byte数组 private static byte [] convert(double num ) throws IOException&#123; byte [] data = new byte[1024]; ByteArrayOutputStream a = new ByteArrayOutputStream(); DataOutputStream b = new DataOutputStream(a); b.writeDouble(num); data = a.toByteArray(); return data; &#125; ByteArrayInputStream 和 ByteArrayOutputStream 将一个字节数组当作流输入、输出的来源 ByteArrayInputStream 将字节数组转换为流 byte[]—&gt;流—-read() 将字节数组读取到流中 ByteArrayOutputStream 将将流转换为字节数组 流—&gt; byte[]—-toByteArray() 返回数组—-write(byte [],int off,int len ) 将数组中的数据写入到流中 DataOutputStream 将double类型写入到流中。 double—&gt; 流—-writeXXX() DataInputStream 从流中读取数据，并转换为相应的类型 流—&gt;double—-readXXX() Socket通讯 （基于TCP）面向连接，安全可靠，效率低 1、面向连接： 请求-相应 request-response2、Socket编程 1&gt;服务器端创建服务器 指定端口 ServerSocket(int port)接受客户连接 accept() 返回Socket类型传递数据 2&gt;客户端创建客户端 指定服务器端+端口 Socket(String s ,int port )传递数据 发送信息：Socket.getOutputStream();write()flush() 接受数据：client.getInputStream();read() 1234567891011// 客户端public class testTCPclient &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; Socket socket = new Socket(\"localhost\",2000); String data = \"TCP信息\";// OutputStream output = socket.getOutputStream(); DataOutputStream output = new DataOutputStream(socket.getOutputStream()); output.writeUTF(data); &#125;&#125; 12345678910111213141516//服务器端 public static void main(String[] args) throws IOException &#123; ServerSocket socket = new ServerSocket(2000); try &#123; Socket server = socket.accept(); System.out.println(\"已连接\");// InputStream input = server.getInputStream(); DataInputStream input = new DataInputStream(server.getInputStream()); String s = input.readUTF(); System.out.println(s); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block System.out.println(\"连接失败\"); &#125; &#125; 不同的协议之间端口号可以重复，同一个协议中端口号不能重复","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java线程","slug":"Java线程","date":"2016-12-03T16:32:00.000Z","updated":"2016-12-07T13:44:46.789Z","comments":true,"path":"2016/12/04/Java线程/","link":"","permalink":"http://yoursite.com/2016/12/04/Java线程/","excerpt":"Callable 可以返回值 ExecutorServersExecutorServers ser = ExevuteServers.newFixedThread()Future result = sesr.submit(类);ser.shutdownNow();停止线程","text":"Callable 可以返回值 ExecutorServersExecutorServers ser = ExevuteServers.newFixedThread()Future result = sesr.submit(类);ser.shutdownNow();停止线程 线程类中定义线程体使用的标志线程提内使用该标志提供对外的方法改变该标识外部调用方法改变标识 run (){while(flag){}} 阻塞 join()合并线程yeild()暂停当前正在执行的线程，执行其他线程staticsleep()暂停，不释放锁–&gt; 与时间相关–&gt; 模拟网络延时system.currentTimeMillis()当前时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111 //join 合并线程，执行当前线程时加入另一个线程，并等待另一个线程执行完毕 import java.util.Locale.Category; public class Test1 &#123; public static void main(String [] args) throws InterruptedException&#123; home m = new home(); Thread cat = new Thread(m); cat.setName(\"cat\"); cat.start(); for(int i = 0 ; i&lt; 10; i++)&#123; cat.join(); System.out.println(\"main\"); &#125; &#125; &#125; class home implements Runnable&#123; public void run() &#123; for (int i = 0 ; i &lt; 10 ; i++)&#123; System.out.println(\"This is \"+Thread.currentThread().getName()+i); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;------------------------------------------------------------------------------- // yield 暂停本线程执行其他线程（虽然在我电脑上试没有任何反应。。。） for(int i = 0 ; i&lt; 10; i++)&#123; // if(i%2==0) Thread.yield(); System.out.println(\"main\"); &#125;#### 优先级*MAX_PRIOIRTY 10&lt;br/&gt;NORM_PRIOIRTY 5&lt;br/&gt;MIN_PRIOIRTY 1*&gt;isAlive() 判断线程是否还活着&gt;Thread.currentThread()当前线程 static&gt;getName() *setPriority()优先级代表概率，不是绝对的先后顺序*####**线程的同步与锁定**多个线程访问同一资源：线程安全StringBuffer--appendhashtable1.同步块/同步方法同步方法：```java package 线程; import java.util.*; import One.sss; public class tongbu &#123; public static void main(String [] args) throws InterruptedException&#123; a m = new a(); Thread cat = new Thread(m); Thread dog = new Thread(m); cat.setName(\"cat\"); dog.setName(\"dog\"); cat.start(); dog.start(); &#125; &#125; class a implements Runnable&#123; int s =10; @Override public void run() &#123; // TODO Auto-generated method stub test1(); &#125; private synchronized void test1()&#123; for (int i = 0 ; i &lt; 10 ; i++)&#123; if (s&lt;=0) break; System.out.println(Thread.currentThread().getName()+\"get\"+s--); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 同步块：synchronize(引用类型){ 同步的部分 } 12345678910111213141516 //同步块，参数为引用`private void test2()&#123; synchronized(this)&#123; for (int i = 0 ; i &lt; 10 ; i++)&#123; if (s&lt;=0) break; System.out.println(Thread.currentThread().getName()+\"get\"+s--); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 锁定范围难把握线程安全的效率相对低下 单例设计模式一个类只有一个对象双重检查1、懒汉式：将构造器设为私有。避免外部直接创建对象声明私有的静态属性对外部提供访问属性的静态方法，确保对象的存在锁定静态的信息（XXX.class） 2、饿汉式将构造器设为私有。避免外部直接创建对象声明私有的静态属性，同时创建对象对外部提供访问属性的静态方法RunTime 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 //懒汉式 //可以满足要求但是效率不高 package 线程; public class 单例 &#123; public static void main(String[] args) throws InterruptedException &#123; test s1 = new test(); test s2 = new test(); s1.start(); s2.start(); &#125; &#125; class Single &#123; private static Single data = null; // 私有的构造函数 private Single()&#123; &#125; //提供外界访问的函数 public static synchronized Single getInstance() throws InterruptedException&#123; if(null == data)&#123; Thread.sleep(1000); data = new Single(); &#125; return data; &#125; &#125; class test extends Thread&#123; public void run()&#123; try &#123; System.out.println(Single.getInstance()); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // System.out.println(b); &#125; &#125; -------------------------------------------------------------- //可以使用块同步 public static Single getInstance2() throws InterruptedException&#123; synchronized(Single.class)&#123; if(null == data)&#123; Thread.sleep(1000); data = new Single(); &#125; return data; &#125; &#125;-------------------------------------------------------------- //双重检查 public static Single getInstance3() throws InterruptedException &#123; if (null == data) &#123; synchronized (Single.class) &#123; if (null == data) &#123; Thread.sleep(1000); data = new Single(); &#125; &#125; &#125; return data; &#125; 饿汉式private static Single data = new Single();声明时创建","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"IO流（2）","slug":"IO流(2)","date":"2016-11-30T04:45:58.000Z","updated":"2016-12-10T08:52:41.215Z","comments":true,"path":"2016/11/30/IO流(2)/","link":"","permalink":"http://yoursite.com/2016/11/30/IO流(2)/","excerpt":"节点流：字节数组输入流 ByteArrayInputStream字节数组输出流 ByteArrayOutputStream","text":"节点流：字节数组输入流 ByteArrayInputStream字节数组输出流 ByteArrayOutputStream 将字节数组转化成流ByteArrayInputStream(byte [] )不用关闭toByteArray() 输出到字节数组 处理流输入流：DataInputStream(InputStream x) readXXX()输出流：DataOutputStream(OutputStream x) writeXXX() 123456789101112131415161718192021// DataInputStream/DataOutputStream 写入到文件/从文件读取 public static void main (String [] args) throws IOException&#123; File file = new File(&quot;D:/桌面/DataInputStream.txt&quot;); DataInputStream input = new DataInputStream(new FileInputStream(file));// DataOutputStream output = new DataOutputStream(new FileOutputStream(file)); int a = 100; double b = 200; String c = &quot;string&quot;;// output.writeInt(a);// output.writeDouble(b);// output.writeUTF(c); int d = input.readInt(); double e = input.readDouble(); String f = input.readUTF(); System.out.println(d); System.out.println(e); System.out.println(f);// output.close();// input.close(); &#125; 对象序列化：ObjectInputStream -&gt; readObject()ObjectOutputStream -&gt; writeObject()先序列化后反序列化,对象必须使用java.io.Seriallizable接口不是所有属性都需要序列化，用transient表示不需要序列化的属性 可变参数只能放在新蔡的最后一个位置（Closeable …）…可变参数，处理方式与数组一致try- with-resource ####打印流和输入流system.outsystem.inprintStream12PrintStream ps = System.outps.println(); 12ps = new PrintStream(new BufferedOutputStream(new FileOutputStream(src)))ps.println(); //输出到文件 System.outSystem.errSystem.in 键盘输入 12PrintStream output = new PrintStream(new FileOutputStream(new File(&quot;D:/桌面/2.txt&quot;)));output.print(&quot;printStream&quot;); InputStream in = System.in;//system.in 实际上是一个InputStream流 重定向setIn()setOut()setErr() System.setOut(new PrintStream(new FileOutputStream(“”)));System.out.println(“2333”);System.setOut(new PrintStream(new FileOutputStream(new FileDescripter.out)));//返回控制台 12System.setOut(new PrintStream(new FileOutputStream(&quot;D:/桌面/3.txt&quot;)));System.out.println(&quot;重定向&quot;);","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"IO流","slug":"IO流","date":"2016-11-30T04:35:58.000Z","updated":"2016-12-06T15:31:27.289Z","comments":true,"path":"2016/11/30/IO流/","link":"","permalink":"http://yoursite.com/2016/11/30/IO流/","excerpt":"File路径分隔符–File.pathSeparator文件分隔符–File.seprarator","text":"File路径分隔符–File.pathSeparator文件分隔符–File.seprarator 路径表示形式 path = “E://xp//test/2.jpg”path =”E:”+File.separator+”xp”+File.separator….课跨平台的路径path = “E:\\xp\\test\\2.jpg”–&gt;path = “E:/xp/test/2.jpg”(推荐的方式) 常用的方法： getName()getParent()返回上一级目录，没有上一级返回空exists()文件是否存在canRead()文件是否可读isFile()isDirectory() 判断length()长度，字节数/文件夹无法读出长度creatNewFile()创建文件(返回boolean类型)（若文件已经存在返回false）delete()删除文件返回（boolean）creatTempFile() 创建临时文件deleteOnExit() 退出时自动删除mkdir()创建目录，必须确保父目录存在makirs()创建目录，递归创建目录。String [] list()返回文件名称File [] listFiles() 返回目录中的文件listRoots() 根路径FilenameFilter 过滤器 1 字节流： 输入流: InputStream ,read(byte[]),read(byte[],int off,int len),close() FileInputStream()输出流: OutputStream,write(byte[]),write(char [] ,int off,int len),flush(),close() FileOutputStream() 2 字符流: 输入流: Reader read(char []) ,read(char [] ,int off,int len),close() FileReader()输出流: Writer write(char []),writer(char [] ,int off,int len),flush(),close() FileWriter() 字节流 建立联系 File 选择流 文件输入流 操作 关闭 12345678910111213141516171819202122232425262728// 读取文件public static void main(String [] args)&#123; File f = new File(\"D:/桌面/a.txt\"); byte [] file = new byte[1024]; InputStream in = null; try &#123; in = new FileInputStream(f); int len = 0; while(-1 != (len = in.read(file)))&#123; String s = new String(file, 0, len); System.out.print(s); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; try &#123; if (in!=null) in.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 建立联系 File 选择流 文件输出流 OutputStream FileOutputStream 操作 write() flush() 关闭 OutputStream 将数据写入到文件中，FileOutputStream将数据写入到流中InputStream 将数据从文件中读取，FileInputStream将从六中读取数据FileOutputStream(File , true)将数据追加到文件中，默认为false一定一定一定要记得关闭流 1234567891011121314151617181920212223242526272829//写入到文件 public static void main(String [] args)&#123; File file = new File(\"D:/桌面/b.txt\"); OutputStream out = null; try &#123; out = new FileOutputStream(file,false); String s = \"写入文件操作\\r\\n\"; byte [] s2 = s.getBytes(); out.write(s2); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; if (out!=null)&#123; try &#123; out.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940//复制文件 public static void main (String [] args)&#123; File file1 = new File(\"D:/桌面/tree.jpg\"); File file2 = new File(\"D:/桌面/trees.jpg\"); InputStream input = null; OutputStream output = null; try &#123; input = new FileInputStream(file1); output = new FileOutputStream(file2); byte [] data = new byte [1024*4]; int len = 0; while(-1 != (len = input.read(data)))&#123; output.write(data,0, len); System.out.println(data); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"没有找到文件\"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; output.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; input.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(\"写入成功\"); &#125; &#125; 字符流:只能处理纯文本.txt .htmlWriter FileWriterReader FileReader1 建立联系2 选择流 Writer FileWriter3 读取char[] dlush4 关闭 FileWriter(File ,true) 追加append()追加 12345678910111213141516171819202122232425262728293031323334353637//FileReader 读取文件public class testFileReader &#123; public static void main (String [] args)&#123; File file = new File(\"D:/桌面/switch.txt\"); File file2 = new File(\"D:/桌面/switch2.txt\"); Reader input = null; Writer output = null; try &#123; input = new FileReader(file); char [] data = new char [1024]; int len = 0; while (-1 != (len = input.read(data)))&#123; String s = new String(data, 0, len); System.out.println(s); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"文件读取失败\"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; input.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"关闭失败\"); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//FileWriter复制文件public class testFileReader &#123; public static void main (String [] args)&#123; File file = new File(\"D:/桌面/switch.txt\"); File file2 = new File(\"D:/桌面/switch2.txt\"); Reader input = null; Writer output = null; try &#123; input = new FileReader(file); output = new FileWriter(file2); char [] data = new char [1024]; int len = 0; while (-1 != (len = input.read(data)))&#123; String s = new String(data, 0, len); output.write(s); // System.out.println(s); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"文件读取失败\"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; input.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"关闭失败\"); &#125; try &#123; output.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"关闭输出流失败\"); &#125; &#125; &#125;&#125; 缓冲流1，字节缓冲流 BufferedInputStreamBufferedOutputStream 2,字符缓冲流 BufferedReader ReadLine()BufferedWriter newLine()换行字节流文件拷贝+缓冲流，提高性能缓冲流(节点流)//使用新增方法不能发生多态 12345678910111213//用BufferedReader包装 BufferedReader input = null; BufferedWriter output = null; try &#123; input = new BufferedReader(new FileReader(file)); output = new BufferedWriter(new FileWriter(file2)); String temp ; while(null != (temp = input.readLine()))&#123; System.out.println(temp); &#125;。。。。。。//输出方式同理，writer（String s ） 转换流 ： 字节流转字符流 处理乱码（编码集、解码集） String(byte [] bytes,Charset charset) 使用charset编码来编码byte数组String(byte [] bytes,int offset, int length,Charset charset) 编码byte数组的子数组getbytes()使用默认的编码方式返回字节数组getBytes(Charset charset)使用指定的编码方式返回字节数组 1234567//处理文件编码 public static void main (String [] args) throws UnsupportedEncodingException&#123; String str1 = \"字符串\"; byte [] data = str1.getBytes(\"utf-8\"); String str2 = new String(data, \"utf-8\"); System.out.println(str2); &#125; 字节转为字符:（转换流）InputStreamReader()OutputStreamWriter() //InputStreamReader(new FileInputStream(new File())) 12345678910111213141516171819//字节流转字符流 public static void main (String [] args) throws IOException&#123; File file1 = new File(\"D:/桌面/1.txt\"); File file2 = new File(\"D:/桌面/2.txt\"); try &#123; BufferedReader input = new BufferedReader( new InputStreamReader( new FileInputStream(file1),\"utf-8\") ); String len ; while (null != (len = input.readLine()))&#123; System.out.println(len); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java异常","slug":"异常","date":"2016-11-16T04:51:58.000Z","updated":"2016-12-06T15:26:42.762Z","comments":true,"path":"2016/11/16/异常/","link":"","permalink":"http://yoursite.com/2016/11/16/异常/","excerpt":"1.可以自定义一个异常，方法是继承Throwable类或者是继承Exception类。其实Exception类就是Throwable的子类。","text":"1.可以自定义一个异常，方法是继承Throwable类或者是继承Exception类。其实Exception类就是Throwable的子类。 2.当有一个函数会抛出我们自定义的异常，需要声明这个函数会抛出什么样的异常 例如： public static void a() throws wrong{ 这里，throw是抛出一个异常，而Throws是声明一个函数会抛出异常 e.getMessage() 异常中的信息println（e） 异常的名字和异常中储存的值e.printStacktrace() 跟踪异常出现位置 12345678910111213141516class wrong extends Throwable&#123;&#125;public class 异常 &#123; static int [] a = new int [10]; public static void main(String [] args)&#123; try&#123; a(); &#125;catch(wrong e )&#123; System.out.println(\"这是自定义的异常\"); &#125; &#125; public static void a() throws wrong&#123; throw new wrong(); &#125;&#125; 1.当一个异常继承于另一个异常时，捕捉父类异常时就可以同时捕捉子类的异常。也就是说因为Exception是所有异常的父类，所以捕捉Exception异常时就可以捕捉所有的异常 2.当同时捕捉多个异常时，只会有一个异常被捕捉到。 3.当语句中先捕捉父类异常再捕捉子类异常时会报错。提示这是一个永远不会执行到的异常。 Unreachable catch block for wrong2 123456789101112131415161718192021class wrong extends Exception &#123; //父类异常&#125;class wrong2 extends wrong&#123; //子类异常&#125;public class 异常 &#123; static int [] a = new int [10]; public static void main(String [] args)&#123; try&#123; a(); &#125;catch(wrong e )&#123; System.out.println(\"这是异常wrong\"); &#125; &#125; public static void a() throws wrong2&#123; throw new wrong2(); &#125;&#125; 1.当覆盖函数的时候，子类不能声明抛出比父类的版本更多的异常。2.在子类的构造函数中，必须声明父类可能抛出的全部异常。 如果有以下三种异常 class wrong1 extends Exception {} //父类异常 class wrong2 extends wrong1{} //子类异常 class wrong3 extends Exception{} 当父类的函数f()抛出异常wrong1时，子类中覆盖它的函数的异常不能比它抛出更多的异常,但是子类的构造函数必须包含父类的所有异常 123456789101112131415161718192021222324252627 //父类 class test &#123; public void f() throws wrong1,wrong3&#123;&#125; test()throws wrong1&#123;&#125; &#125;//子类 public class 异常 extends test &#123; //构造函数 异常()throws wrong1,wrong3&#123;&#125; //子类覆盖的函数 public void f()throws wrong1 ,wrong3 &#123;&#125; public static void main(String [] args)&#123; try&#123; a(); &#125;catch(wrong1 e )&#123; System.out.println(\"这是异常wrong1\"); &#125;catch(wrong3 e)&#123;&#125; &#125; public static void a() throws wrong1,wrong3&#123; test s = new test(); s.f(); &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2016-09-11T06:08:58.000Z","updated":"2017-07-24T12:16:16.351Z","comments":true,"path":"2016/09/11/linux常用命令/","link":"","permalink":"http://yoursite.com/2016/09/11/linux常用命令/","excerpt":"Linux ： 1 打开shell显示的第一行 twilight @ twilight ~ $分为三部分，第一部分是@前代表当前的登录用户，@后面的是电脑的主机名 ，~是当前所在的位置，表示家目录,我的家目录是/home/twilight。$是普通用户的提示符，root用户是#、","text":"Linux ： 1 打开shell显示的第一行 twilight @ twilight ~ $分为三部分，第一部分是@前代表当前的登录用户，@后面的是电脑的主机名 ，~是当前所在的位置，表示家目录,我的家目录是/home/twilight。$是普通用户的提示符，root用户是#、 2 用ls –lh查看当前目录下的文件的详细信息时第一列的内容： -rw-r- -r– 第一个-表示文件类型（-表示普通类型、d表示目录、l表示软连接），后面九个字符分三个一组分别表示：文件所属者的权限、同组用户的权限、其他组用户的权限。-rw-r- -r- -也可以表示成644，Chmod 644 test.txt 表示把以上权限赋给test.txt文件。 3 mkdir +目录名称 表示创建一个分组，。但是mkdir a/b/会报错，因为这时候需要用到递归创建（mkdir -p），递归创建可以同时创建路径中的子目录和上层的目录。 4 pwd 显示当前所在目录 5 rm –rf 强制删除目录和文件，rm –rf mt/* 表示删除目录中的文件。 6 cp /路径/文件名 /路径/文件名 复制命令， -r 复制目录 -a 复制完全相同的文件，包括创建时间和权限 7 mv 剪切命令 （将文件剪切到源目录可以改文件名） 8 locate +文件名 按文件名搜索以该文件名开头的文件，不是完全匹配，在数据库中搜索，速度快，数据库位置 /var/lib/mlocate 该数据库一天一更新，但是可以用updatedb强制更新 9 whereis 搜索命令的位置 -b 只查找可执行文件 -m 只查找帮助文件 10 find + 文件名 （完全匹配） find / -name filename按名称查找文件 find / -inamefilename 不分大小写 find / -userusername 按所有者查找 find /-nouser 查找没有所有者的文件 find /-mtime+10 查找10天外的文件 （-mtime修改内容 -ctime修改属性 -atime 访问时间） find / -size+25k 查找大于25k的文件 （25k小写，25M大写；） find / -size+20k -a -size -30k 查找大于20k小于30k文件 find / -size+20k -a -size -30k -exec ls -hl {} \\;查找并输出 （exec+命令+ {} \\; 对搜索结果操作） 11 grep 字符串 文件名 查找文件内容中的字符串， -i 忽略大小写 -v排除字符串 12 man -f /whatis +命令 查看命令级别和作用 13 man -k/apropos 查看包含该命令名的命令 14 zip 压缩文件名 源文件 压缩文件 zip -r 压缩文件名 源文件 压缩目录 unzip 文件名 解压 15 gzip 源文件 压缩源文件消失 gzip -r 压缩目录下的文件 gzip -c 源文件 &gt; 压缩文件（源文件不消失 ） ( &gt; 把命令结果写入指定文件 ） gzip -d / gunzip 解压文件 16 bzip2 源文件 压缩（源文件消失） bzip2 -k 源文件 （保留源文件） bzip -d/bunzip 解压 17 tar -cvf 打包文件名 源文件 打包 tar -cvf 打包文件名 解打包 18 tar -zcvf 压缩包名（tar .gz) 源文件 打包并压缩 tar -zxvf 压缩包名（tar .gz) 源文件 解打包并解压 tar -jcvf压缩包名（tar .bz2) 源文件 打包并压缩 tar -jxvf 压缩包名（tar .bz2) 源文件 解打包并解压 19 shutdown 【选项】 时间 （ -c 取消 -h关机 -r 重启 ） 28 mount 【-t 文件系统】 【-o 特殊选项】 设备文件名 挂载点 mount -a 所有设备自动挂载 （ 文件系统 ext3. Ext4 .ios9600 ） （ 挂载点 已存在的空白目录 ） 29 挂载光盘： 1 mkdir /mnt/cdrom/ 2mount /dev/sr0 /mnt/cdrom（sr0是光驱代号） 卸载光盘： umount /mnt/cdrom/ 或者 /dev/sr0 30 挂载u盘 mount -t vfat /dev/sdb1 /mnt/usb (vfat是fat32) 31 echo 内容 （当内容中有空格时 加” “ ） -e 支持反斜杠的字符转换 32 echo -e “\\e[1;34m” 开启颜色 echo -e “\\e[0m“ 关闭颜色 （30 红 ，32绿，34蓝） 33 脚本（输出hello world） #！/bin/bash （用bin/下的bash执行脚本） echo “ abcd” 执行方式 ： 1 bash hello.sh 2 chmod 755 hello.sh ./hello.sh 34 alias 查看系统所有别名 alias 别名=”原名” （临时生效，重启失效） unalias 临时删除别名 （将文件写入/.bashrc中重启永久生效） （source .bashrc 不重启直接生效） 35 输出重定向 正确命令： 1命令 &gt; 文件 命令结果输入到文件中（覆盖源文件） 2命令 &gt;&gt;文件 命令结果追加到文件中 （追加） 错误命令： 1命令 2&gt;文件 命令结果输入到文件中（覆盖源文件） （无空格） 2命令 2&gt;&gt;文件 命令结果追加到文件中 （追加） （无空格） 正确&amp;错误： 1 命令 &gt;&gt; 文件 2&gt;&amp;1 2 命令 &amp;&gt;&gt; 文件 3命令 &gt;&gt;文件1 2&gt;&gt;文件2 36 多命令顺序执行 1 ; 命令1 ; 命令2 命令之间无关 2 &amp;&amp; 命令1 &amp;&amp;命令2 1正确执行2 ，1错误不执行2 3 || 命令1 || 命令2 1错误执行2 ，1正确不执行2 37 管道符 命令1 | 命令2 （1的结果作为2 的对象）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"日期类","slug":"日期类","date":"2016-09-11T02:33:58.000Z","updated":"2016-12-06T15:25:51.200Z","comments":true,"path":"2016/09/11/日期类/","link":"","permalink":"http://yoursite.com/2016/09/11/日期类/","excerpt":"Date类从1970.1.1.0点开始到某个时刻的毫秒数，类型是long1970年之前用负数表示","text":"Date类从1970.1.1.0点开始到某个时刻的毫秒数，类型是long1970年之前用负数表示 toGMTString()不建议使用getTime() 返回时间的毫秒数setTime() 设置时间，毫秒数DateFormat(父类) , SimpleDateFormat(子类)字符串和时间类的转化new Date() 返回当前的时间 将时间类转化为字符串: 1234DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");Date d = new Date(1234567L);String str = df.format(d);print; yyyy-MM-dd hh:mm:ss 年月日时分秒 字符串转化为时间类: String str2 = &quot;1997-7-7&quot;; DateFormt df2 = new SimpleDateFormt(&quot;yyyy-MM-dd&quot;); Date d2 = df2.parse(str2); 字符串中的格式必须和SimDateFormat中的格式相同，否则会报错 Calendar 类（抽象类）–GregorianCalendar(子类)一月是0 二月是1,12月是11。周日是1，周一是2，周六是7.Calendar c = Calendar.getInstance();创建Calendar对象 12345678Calendar c = ne w GregorianCalendar();c.set(2001,1,10,12,23,34);Date d = c.getTime();//c.set(Calendar.YEAR,2001);单独定义一个属性，使用当前时刻的时分秒//c.setTime(new Date());//c.add(Calendar.YEAR,30);增加30年（-30表示减法）//getActualMaximun(Calendar.Date);返回一个月大最大天数print; 一个简单的日历程序： 源代码如下： 1234567891011121314151617181920212223242526272829303132333435import java.util.*;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;public class TestDate &#123; public static void main (String [] args)&#123; try &#123; System.out.println(\"请输入时间：（YYYY-MM-dd）\"); Scanner input = new Scanner(System.in); String time = input.nextLine(); DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = format.parse(time); Calendar c = new GregorianCalendar(); c.setTime(date); c.set(Calendar.DATE, 1); System.out.println(\"日\\t一\\t二\\t三\\t四\\t五\\t六\"); for(int j = 1 ; j &lt; c.get(Calendar.DAY_OF_WEEK); j++)&#123; System.out.print(\"\\t\"); &#125; for (int i = 1 ; i &lt; c.getMaximum(Calendar.DATE); i++)&#123; System.out.print(i+\"\\t\"); if(c.get(Calendar.DAY_OF_WEEK)==Calendar.SATURDAY)&#123; System.out.println(); &#125; c.add(Calendar.DATE, 1); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"不同编码类型的总结","slug":"不同字符编码类型的总结","date":"2016-09-11T02:33:58.000Z","updated":"2016-12-06T15:24:37.489Z","comments":true,"path":"2016/09/11/不同字符编码类型的总结/","link":"","permalink":"http://yoursite.com/2016/09/11/不同字符编码类型的总结/","excerpt":"1.ASCII计算机一开始在美国使用，字符编码也只包括英文字母。ANSCII编码由一个字节表示所有符号。一个字节可以表示的所有可能是256（2的8次方）种，对于美国人来说，26个英文字母，加上常用的符号，也只是用了127个。如果大家都用英文，那这套编码完全够用。","text":"1.ASCII计算机一开始在美国使用，字符编码也只包括英文字母。ANSCII编码由一个字节表示所有符号。一个字节可以表示的所有可能是256（2的8次方）种，对于美国人来说，26个英文字母，加上常用的符号，也只是用了127个。如果大家都用英文，那这套编码完全够用。但是不同国家的文字不同，如果加上其他国家的语言符号，那一个字节是不够的，之后ASCII做出了改进，将256种情况剩余的可能用来表示其他字符。一直排到了第255种可能，从128到255表示的字符成为“扩展字符集”，然而，新增的字符并不能解决所有问题。 2.GB2312计算机开始在我国普及时，ASCII中已经没有可以利用的字节状态来表示汉字。于是，我们将扩展字符集删除，将127后的字符状态重新编码。小于127的字符状态的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节称之为高字节，后面一个字节称之为低字节，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 后来GB2312也无法满足人们的需要，随后出现了GBK标准，再后来，还是不够用，于是出现了GB18030。这个标准几乎可以表示所有的中文字符，此标准在2006年5月1日被作为在中国境内所有软件产品支持的强制规格。 3.Unicode不只是我国，很多国家都制定了相应的符合本国文化的字符编码标准。这些标准再本国内可以正常使用，但是如果是不同国家之间通过文本文件的交流，就很有可能导致乱码。这时，国际标准化组织（osi）出现了，OSI致力于将全世界所有的字符用统一的标准编码，消除不同国家之间交流的障碍。 OSI将所有字符用两个字节表示，包括ANCSI中的前127个字符，所以对于钱127个字符来说，本来8位就可以表示的字符现在用16位来表示，这其实是一种资源的浪费。 4.UTF-8可以看出，Unicode虽然是一个很好的字符编码方式，但由于所有字符都用两个字节表示导致的资源的浪费，促使了UTF-8的出现，UTF-8编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。UTF-8有如下特点： 前128个US-ASCII字符只需一个字节编码（与ANCSI相同）。 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码。 其他基本多文种平面（BMP）中的字符（这包含了大部分常用字）使用三个字节编码。 其他极少使用的Unicode辅助平面的字符使用四字节编码。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"}]}]}